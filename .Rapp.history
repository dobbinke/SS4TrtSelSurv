summary(myPolynomialHH5)
summary(myPolynomialHH4)
myPolynomialHH1 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,1))#
myPolynomialHH2 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,2))#
myPolynomialHH3 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,3))#
myPolynomialHH4 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,4))#
myPolynomialHH5 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,5))#
myPolynomialHH6 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,6))#
myPolynomialHH7 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,7))#
anova(myPolynomialHH1,myPolynomialHH2,myPolynomialHH3,myPolynomialHH4,myPolynomialHH5,myPolynomialHH6,myPolynomialHH7)
myPolynomialHH6
myPolynomialHH1 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,1),raw=FALSE)#
myPolynomialHH2 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,2),raw=FALSE)#
myPolynomialHH3 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,3),raw=FALSE)#
myPolynomialHH4 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,4),raw=FALSE)#
myPolynomialHH5 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,5),raw=FALSE)#
myPolynomialHH6 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,6),raw=FALSE)#
myPolynomialHH7 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,7),raw=FALSE)#
anova(myPolynomialHH1,myPolynomialHH2,myPolynomialHH3,myPolynomialHH4,myPolynomialHH5,myPolynomialHH6,myPolynomialHH7)
myPolynomialHH1 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,1,raw=FALSE))#
myPolynomialHH2 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,2,raw=FALSE))#
myPolynomialHH3 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,3,raw=FALSE))#
myPolynomialHH4 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,4,raw=FALSE))#
myPolynomialHH5 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,5,raw=FALSE))#
myPolynomialHH6 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,6,raw=FALSE))#
myPolynomialHH7 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,7,raw=FALSE))#
anova(myPolynomialHH1,myPolynomialHH2,myPolynomialHH3,myPolynomialHH4,myPolynomialHH5,myPolynomialHH6,myPolynomialHH7)
# title: "For simulation tables"#
# date: 2023-08-22#
library(car)#
library(lme4)#
library(splines)#
install.packages("lmerTest")#
library(lmerTest)#
rm(list=ls())#
#
# Parameters#
#
mcruns = 5;#
#
reps.per.cell = 10;#
number_of_clusters = 20;#
number_of_clusters_per_crossover = 4#
number_of_time_periods = (number_of_clusters/number_of_clusters_per_crossover)+1;#
number_of_cells = number_of_clusters * number_of_time_periods;#
#
number.of.cells = number_of_cells;#
number.of.rows = number_of_clusters;#
number.of.columns = number_of_time_periods;#
#
Total_n = number.of.cells*reps.per.cell;#
#
noise.sd = 1; # the standard deviation of the general noise variance#
myintercept = 0;  # the intercept for the response model#
cluster.sd = 2; # the standard deviation for the cluster (row, clinic) main effects#
treatment.effect.size = 0; # the size of the treatment effect#
time_main_effects_sd = 1;#
#
sigmasq = noise.sd^2;#
tausq = cluster.sd^2;#
# Specify the time main effects for one rep#
time_main_effects = rnorm(n=number.of.columns,sd=time_main_effects_sd);#
time_main_effecs_onerep = rep(time_main_effects,each=number_of_clusters);#
# Create the full vector of treatment effects#
xtrts01_onerep = rep(0,number_of_cells);#
#
# column leftmost  #
xtrts01_onerep[1:number_of_clusters] = rep(0,number_of_clusters)#
# column rightmost#
xtrts01_onerep[((number_of_time_periods-1)*number_of_clusters+1):number_of_cells] = rep(1,number_of_clusters)#
for (j in 2:(number_of_time_periods-1)) {#
  equation1 = ((j-1)*number_of_clusters_per_crossover);#
  equation2 = number_of_clusters - equation1;#
  thiscolumn_asrowvec = c(rep(1,equation1), rep(0,equation2))#
  xtrts01_onerep[(1+number_of_clusters*(j-1)):(number_of_clusters*j)] = thiscolumn_asrowvec#
}#
xtrts01_onerep#
xtrts_onerep = xtrts01_onerep#
#
treatment.indicator.vec = rep(xtrts_onerep,reps.per.cell);#
treatment.effects.vec = treatment.effect.size * treatment.indicator.vec;#
treatment.fac = factor(treatment.indicator.vec)#
# Create vectors to store the Monte Carlo results#
HG.pvals.for.treatment = rep(NA,mcruns)#
HG.effect.size.treatment = rep(NA,mcruns)#
HG.time3.effect.size = rep(NA,mcruns)#
#
reml.HH.pvals.for.treatment = rep(NA,mcruns)#
reml.HH.effect.size.treatment = rep(NA,mcruns)#
reml.HH.time3.effect.size = rep(NA,mcruns)#
#
polynomial.HH.pvals.for.treatment = rep(NA,mcruns)#
polynomial.HH.effect.size.treatment = rep(NA,mcruns)#
#
spline.HH.pvals.for.treatment = rep(NA,mcruns)#
spline.HH.effect.size.treatment = rep(NA,mcruns);#
#
cluster_specific_Polypvals = rep(NA,mcruns)#
cluster_specific_Splinepvals = rep(NA,mcruns)#
#
GLS.effect.sizes = rep(NA,mcruns);#
############################################
############################################
############  GLS calculations#
############################################
############################################
#
# For variable name cross-reference, see matlabProgram4SWTDesigns.m#
#
xtimesbase = diag(number_of_time_periods)#
#
xtimes = kronecker(xtimesbase,t(rep(1,number_of_clusters)))#
#
dim(xtimes)#
#
xtrts01 = rep(0,number_of_cells)#
#
# leftmost column#
xtrts01[1:number_of_clusters] = rep(0,number_of_clusters);#
# rightmost column#
xtrts01[((number_of_time_periods-1)*number_of_clusters+1):number_of_cells] = rep(1,number_of_clusters);#
for (j in 2:(number_of_time_periods-1)){#
  equation1 = ((j-1)*number_of_clusters_per_crossover);#
  equation2 = number_of_clusters - equation1;#
  thiscolumn_asrowvec = c(rep(1,equation1),rep(0,equation2));#
  xtrts01[(1+number_of_clusters*(j-1)):(number_of_clusters*j)] = thiscolumn_asrowvec;#
}#
xtrts01 #
xtrts = 2 * (xtrts01-0.5);#
xtrts = t(xtrts)#
#
x = cbind(t(xtimes),t(xtrts))#
#
dim(x)#
#
z = diag(number_of_clusters);#
z = kronecker(t(rep(1,number_of_time_periods)),z)#
#
G = tausq * diag(number_of_clusters);#
R = sigmasq * diag(number_of_cells);#
V = t(z) %*% G %*% z + R;#
# V #
Vinv = solve(V)#
#
inv_xtxwithV_inv = solve(t(x)%*%Vinv%*%x)#
#
mysol = inv_xtxwithV_inv %*% t(x) %*% Vinv;#
#
trtestimator = 2*mysol[(1+number_of_time_periods),]#
#
length(trtestimator)#
#
mytrtmat = matrix(trtestimator,ncol=number_of_time_periods)#
#
mytrtmat#
############################################
############################################
############  SIMULATION LOOP#
############################################
############################################
#
mystarttime = Sys.time();#
#
for (thisrep in 1:mcruns){#
#
  # Specify the interaction pattern for one rep#
  time_by_cluster_interactions_onerep = rep(0,number_of_cells);#
  rowpattern1 = c(rep(0,6));#
  rowpattern2 = c(rep(0,6));#
  patternlist = list(rowpattern1,rowpattern2)#
  theserows =  c(rep(1,number_of_clusters/2),rep(2,number_of_clusters/2))#
  # theserows =  c(rep(1,5),rep(2,5))#
  byrowinteractions = matrix(NA,ncol=number_of_time_periods,nrow=number_of_clusters,byrow=T);#
  for (i in 1:number_of_clusters) {#
    byrowinteractions[i,] = patternlist[[theserows[i]]]#
  }#
  time_by_cluster_interactions_onerep = c(byrowinteractions);#
  time_by_cluster_interactions_onerep#
  # Create the full vector of cluster-specific time effects#
  cluster_specific_time_effects = #
  rep(time_main_effecs_onerep+time_by_cluster_interactions_onerep,reps.per.cell)#
#
  GLS.effect.sizes[thisrep] = sum(trtestimator*time_by_cluster_interactions_onerep);#
  mynoise = rnorm(n=number.of.cells*reps.per.cell,sd=noise.sd)#
#
  # Add a random cluster main effect#
  cluster.main.effects = rnorm(n=number.of.rows,sd=cluster.sd);#
  cluster.numbers.vec = rep(1:number.of.rows,(number.of.columns*reps.per.cell))#
  cluster.effects.vec = cluster.main.effects[cluster.numbers.vec]#
#
  # Generate the response #
  myresp = myintercept + cluster.effects.vec + treatment.effects.vec + #
   cluster_specific_time_effects + mynoise;#
  # Now fit the Hooper-Girling and H/H model#
  HG.cluster.factor = factor(cluster.numbers.vec);#
  HG.treatment.ind = treatment.indicator.vec;#
  times.vec = rep(rep(1:number_of_time_periods,each=number_of_clusters),reps.per.cell);#
  HG.time.factor = factor(times.vec);#
  HG.time.numeric = times.vec;#
#
  mylmerHG = lmer(myresp ~ (1|HG.cluster.factor) + HG.treatment.ind +#
               HG.time.factor + (1|(HG.cluster.factor:HG.time.factor)),REML=1);#
  summary(mylmerHG)#
#
  HG.pvals.for.treatment[thisrep] = anova(mylmerHG)[1,6]#
  HG.effect.size.treatment[thisrep] = summary(mylmerHG)$coefficients[2,1];#
#
  mylmerHHreml  = lmer(myresp ~ (1|HG.cluster.factor) + HG.treatment.ind +#
         HG.time.factor,REML=1 );#
  summary(mylmerHHreml)#
#
  reml.HH.pvals.for.treatment[thisrep] = anova(mylmerHHreml)[1,6]#
  reml.HH.effect.size.treatment[thisrep] = summary(mylmerHHreml)$coefficients[2,1];#
#
  thisdeltaHH = summary(mylmerHHreml)$coefficients[2,1];#
  myPolynomialHH = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
    + HG.cluster.factor:poly(HG.time.numeric,3,raw=TRUE))#
#
  myPolynomialHH_maineff = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor)+ poly(HG.time.numeric,2,raw=TRUE),#
    REML=1)#
  summary(myPolynomialHH_maineff)#
#
  anova(myPolynomialHH,myPolynomialHH_maineff)#
  cluster_specific_Polypvals[thisrep] <-   anova(myPolynomialHH,myPolynomialHH_maineff)[2,8]#
  summary(mylmerHHreml)#
#
  polynomial.HH.pvals.for.treatment[thisrep] = anova(myPolynomialHH)[1,6]#
  polynomial.HH.effect.size.treatment[thisrep] = summary(myPolynomialHH)$coefficients[2,1];#
#
# TRY  SPLINE#
#
  # mysplineHH = lmer(myresp ~  HG.treatment.ind + #
  #   bs(HG.time.numeric1,df=2) + #
  #   bs(HG.time.numeric2,df=2) + #
  #   bs(HG.time.numeric3,df=2) + #
  #   bs(HG.time.numeric4,df=2) + #
  #   bs(HG.time.numeric5,df=2) + #
  #   bs(HG.time.numeric6,df=2) + #
  #   bs(HG.time.numeric7,df=2) + #
  #   bs(HG.time.numeric8,df=2) + #
  #   bs(HG.time.numeric9,df=2) + #
  #   bs(HG.time.numeric10,df=2) +#
  #   bs(HG.time.numeric11,df=2) +#
  #   bs(HG.time.numeric12,df=2) +#
  #   bs(HG.time.numeric13,df=2) +#
  #   bs(HG.time.numeric14,df=2) +#
  #   bs(HG.time.numeric15,df=2) +#
  #   bs(HG.time.numeric16,df=2) +#
  #   bs(HG.time.numeric17,df=2) +#
  #   bs(HG.time.numeric18,df=2) +#
  #   bs(HG.time.numeric19,df=2) +#
  #   bs(HG.time.numeric20,df=2)  , #
  #   REML=1)#
  mySplineHH = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
    + HG.cluster.factor:bs(HG.time.numeric,df=3),REML=1)#
#
  mySplineHH_maineff = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor)+ bs(HG.time.numeric,df=3),#
    REML=1)#
#
  summary(mySplineHH)#
  spline.HH.pvals.for.treatment[thisrep] = anova(mySplineHH)[1,6]#
  spline.HH.effect.size.treatment[thisrep] = summary(mySplineHH)$coefficients[2,1];#
#
  summary(mySplineHH_maineff)#
#
  anova(mySplineHH,mySplineHH_maineff)#
  cluster_specific_Splinepvals[thisrep] <-   anova(mySplineHH,mySplineHH_maineff)[2,8]#
}#
summary(myPolynomialHH)#
#
mean(residuals(myPolynomialHH)^2)#
#
myPolynomialHH1 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,1,raw=FALSE))#
myPolynomialHH2 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,2,raw=FALSE))#
myPolynomialHH3 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,3,raw=FALSE))#
myPolynomialHH4 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,4,raw=FALSE))#
myPolynomialHH5 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,5,raw=FALSE))#
myPolynomialHH6 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,6,raw=FALSE))#
myPolynomialHH7 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,7,raw=FALSE))#
anova(myPolynomialHH1,myPolynomialHH2,myPolynomialHH3,myPolynomialHH4,myPolynomialHH5,myPolynomialHH6,myPolynomialHH7)
nova(myPolynomialHH1,myPolynomialHH2,myPolynomialHH3,myPolynomialHH4,myPolynomialHH5)
anova(myPolynomialHH1,myPolynomialHH2,myPolynomialHH3,myPolynomialHH4,myPolynomialHH5)
pnorm(-0.09)
help(beanplot)
install.packages("beanplot")
library(beanplot)
help(beanplot)
title: "For simulation tables"#
# date: 2023-08-22#
library(car)#
library(lme4)#
library(splines)#
install.packages("lmerTest")#
library(lmerTest)#
rm(list=ls())#
#
# Parameters#
#
mcruns = 5;#
#
reps.per.cell = 10;#
number_of_clusters = 20;#
number_of_clusters_per_crossover = 4#
number_of_time_periods = (number_of_clusters/number_of_clusters_per_crossover)+1;#
number_of_cells = number_of_clusters * number_of_time_periods;#
#
number.of.cells = number_of_cells;#
number.of.rows = number_of_clusters;#
number.of.columns = number_of_time_periods;#
#
Total_n = number.of.cells*reps.per.cell;#
#
noise.sd = 1; # the standard deviation of the general noise variance#
myintercept = 0;  # the intercept for the response model#
cluster.sd = 2; # the standard deviation for the cluster (row, clinic) main effects#
treatment.effect.size = 0; # the size of the treatment effect#
time_main_effects_sd = 1;#
#
sigmasq = noise.sd^2;#
tausq = cluster.sd^2;#
# Specify the time main effects for one rep#
time_main_effects = rnorm(n=number.of.columns,sd=time_main_effects_sd);#
time_main_effecs_onerep = rep(time_main_effects,each=number_of_clusters);#
# Create the full vector of treatment effects#
xtrts01_onerep = rep(0,number_of_cells);#
#
# column leftmost  #
xtrts01_onerep[1:number_of_clusters] = rep(0,number_of_clusters)#
# column rightmost#
xtrts01_onerep[((number_of_time_periods-1)*number_of_clusters+1):number_of_cells] = rep(1,number_of_clusters)#
for (j in 2:(number_of_time_periods-1)) {#
  equation1 = ((j-1)*number_of_clusters_per_crossover);#
  equation2 = number_of_clusters - equation1;#
  thiscolumn_asrowvec = c(rep(1,equation1), rep(0,equation2))#
  xtrts01_onerep[(1+number_of_clusters*(j-1)):(number_of_clusters*j)] = thiscolumn_asrowvec#
}#
xtrts01_onerep#
xtrts_onerep = xtrts01_onerep#
#
treatment.indicator.vec = rep(xtrts_onerep,reps.per.cell);#
treatment.effects.vec = treatment.effect.size * treatment.indicator.vec;#
treatment.fac = factor(treatment.indicator.vec)#
# Create vectors to store the Monte Carlo results#
HG.pvals.for.treatment = rep(NA,mcruns)#
HG.effect.size.treatment = rep(NA,mcruns)#
HG.time3.effect.size = rep(NA,mcruns)#
#
reml.HH.pvals.for.treatment = rep(NA,mcruns)#
reml.HH.effect.size.treatment = rep(NA,mcruns)#
reml.HH.time3.effect.size = rep(NA,mcruns)#
#
polynomial.HH.pvals.for.treatment = rep(NA,mcruns)#
polynomial.HH.effect.size.treatment = rep(NA,mcruns)#
#
spline.HH.pvals.for.treatment = rep(NA,mcruns)#
spline.HH.effect.size.treatment = rep(NA,mcruns);#
#
cluster_specific_Polypvals = rep(NA,mcruns)#
cluster_specific_Splinepvals = rep(NA,mcruns)#
#
GLS.effect.sizes = rep(NA,mcruns);#
############################################
############################################
############  GLS calculations#
############################################
############################################
#
# For variable name cross-reference, see matlabProgram4SWTDesigns.m#
#
xtimesbase = diag(number_of_time_periods)#
#
xtimes = kronecker(xtimesbase,t(rep(1,number_of_clusters)))#
#
dim(xtimes)#
#
xtrts01 = rep(0,number_of_cells)#
#
# leftmost column#
xtrts01[1:number_of_clusters] = rep(0,number_of_clusters);#
# rightmost column#
xtrts01[((number_of_time_periods-1)*number_of_clusters+1):number_of_cells] = rep(1,number_of_clusters);#
for (j in 2:(number_of_time_periods-1)){#
  equation1 = ((j-1)*number_of_clusters_per_crossover);#
  equation2 = number_of_clusters - equation1;#
  thiscolumn_asrowvec = c(rep(1,equation1),rep(0,equation2));#
  xtrts01[(1+number_of_clusters*(j-1)):(number_of_clusters*j)] = thiscolumn_asrowvec;#
}#
xtrts01 #
xtrts = 2 * (xtrts01-0.5);#
xtrts = t(xtrts)#
#
x = cbind(t(xtimes),t(xtrts))#
#
dim(x)#
#
z = diag(number_of_clusters);#
z = kronecker(t(rep(1,number_of_time_periods)),z)#
#
G = tausq * diag(number_of_clusters);#
R = sigmasq * diag(number_of_cells);#
V = t(z) %*% G %*% z + R;#
# V #
Vinv = solve(V)#
#
inv_xtxwithV_inv = solve(t(x)%*%Vinv%*%x)#
#
mysol = inv_xtxwithV_inv %*% t(x) %*% Vinv;#
#
trtestimator = 2*mysol[(1+number_of_time_periods),]#
#
length(trtestimator)#
#
mytrtmat = matrix(trtestimator,ncol=number_of_time_periods)#
#
mytrtmat#
############################################
############################################
############  SIMULATION LOOP#
############################################
############################################
#
mystarttime = Sys.time();#
#
for (thisrep in 1:mcruns){#
#
  # Specify the interaction pattern for one rep#
  time_by_cluster_interactions_onerep = rep(0,number_of_cells);#
  rowpattern1 = c(rep(0,6));#
  rowpattern2 = c(rep(0,6));#
  patternlist = list(rowpattern1,rowpattern2)#
  theserows =  c(rep(1,number_of_clusters/2),rep(2,number_of_clusters/2))#
  # theserows =  c(rep(1,5),rep(2,5))#
  byrowinteractions = matrix(NA,ncol=number_of_time_periods,nrow=number_of_clusters,byrow=T);#
  for (i in 1:number_of_clusters) {#
    byrowinteractions[i,] = patternlist[[theserows[i]]]#
  }#
  time_by_cluster_interactions_onerep = c(byrowinteractions);#
  time_by_cluster_interactions_onerep#
  # Create the full vector of cluster-specific time effects#
  cluster_specific_time_effects = #
  rep(time_main_effecs_onerep+time_by_cluster_interactions_onerep,reps.per.cell)#
#
  GLS.effect.sizes[thisrep] = sum(trtestimator*time_by_cluster_interactions_onerep);#
  mynoise = rnorm(n=number.of.cells*reps.per.cell,sd=noise.sd)#
#
  # Add a random cluster main effect#
  cluster.main.effects = rnorm(n=number.of.rows,sd=cluster.sd);#
  cluster.numbers.vec = rep(1:number.of.rows,(number.of.columns*reps.per.cell))#
  cluster.effects.vec = cluster.main.effects[cluster.numbers.vec]#
#
  # Generate the response #
  myresp = myintercept + cluster.effects.vec + treatment.effects.vec + #
   cluster_specific_time_effects + mynoise;#
  # Now fit the Hooper-Girling and H/H model#
  HG.cluster.factor = factor(cluster.numbers.vec);#
  HG.treatment.ind = treatment.indicator.vec;#
  times.vec = rep(rep(1:number_of_time_periods,each=number_of_clusters),reps.per.cell);#
  HG.time.factor = factor(times.vec);#
  HG.time.numeric = times.vec;#
#
  mylmerHG = lmer(myresp ~ (1|HG.cluster.factor) + HG.treatment.ind +#
               HG.time.factor + (1|(HG.cluster.factor:HG.time.factor)),REML=1);#
  summary(mylmerHG)#
#
  HG.pvals.for.treatment[thisrep] = anova(mylmerHG)[1,6]#
  HG.effect.size.treatment[thisrep] = summary(mylmerHG)$coefficients[2,1];#
#
  mylmerHHreml  = lmer(myresp ~ (1|HG.cluster.factor) + HG.treatment.ind +#
         HG.time.factor,REML=1 );#
  summary(mylmerHHreml)#
#
  reml.HH.pvals.for.treatment[thisrep] = anova(mylmerHHreml)[1,6]#
  reml.HH.effect.size.treatment[thisrep] = summary(mylmerHHreml)$coefficients[2,1];#
#
  thisdeltaHH = summary(mylmerHHreml)$coefficients[2,1];#
  myPolynomialHH = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
    + HG.cluster.factor:poly(HG.time.numeric,3,raw=TRUE))#
#
  myPolynomialHH_maineff = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor)+ poly(HG.time.numeric,2,raw=TRUE),#
    REML=1)#
  summary(myPolynomialHH_maineff)#
#
  anova(myPolynomialHH,myPolynomialHH_maineff)#
  cluster_specific_Polypvals[thisrep] <-   anova(myPolynomialHH,myPolynomialHH_maineff)[2,8]#
  summary(mylmerHHreml)#
#
  polynomial.HH.pvals.for.treatment[thisrep] = anova(myPolynomialHH)[1,6]#
  polynomial.HH.effect.size.treatment[thisrep] = summary(myPolynomialHH)$coefficients[2,1];#
#
# TRY  SPLINE#
#
  # mysplineHH = lmer(myresp ~  HG.treatment.ind + #
  #   bs(HG.time.numeric1,df=2) + #
  #   bs(HG.time.numeric2,df=2) + #
  #   bs(HG.time.numeric3,df=2) + #
  #   bs(HG.time.numeric4,df=2) + #
  #   bs(HG.time.numeric5,df=2) + #
  #   bs(HG.time.numeric6,df=2) + #
  #   bs(HG.time.numeric7,df=2) + #
  #   bs(HG.time.numeric8,df=2) + #
  #   bs(HG.time.numeric9,df=2) + #
  #   bs(HG.time.numeric10,df=2) +#
  #   bs(HG.time.numeric11,df=2) +#
  #   bs(HG.time.numeric12,df=2) +#
  #   bs(HG.time.numeric13,df=2) +#
  #   bs(HG.time.numeric14,df=2) +#
  #   bs(HG.time.numeric15,df=2) +#
  #   bs(HG.time.numeric16,df=2) +#
  #   bs(HG.time.numeric17,df=2) +#
  #   bs(HG.time.numeric18,df=2) +#
  #   bs(HG.time.numeric19,df=2) +#
  #   bs(HG.time.numeric20,df=2)  , #
  #   REML=1)#
  mySplineHH = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
    + HG.cluster.factor:bs(HG.time.numeric,df=3),REML=1)#
#
  mySplineHH_maineff = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor)+ bs(HG.time.numeric,df=3),#
    REML=1)#
#
  summary(mySplineHH)#
  spline.HH.pvals.for.treatment[thisrep] = anova(mySplineHH)[1,6]#
  spline.HH.effect.size.treatment[thisrep] = summary(mySplineHH)$coefficients[2,1];#
#
  summary(mySplineHH_maineff)#
#
  anova(mySplineHH,mySplineHH_maineff)#
  cluster_specific_Splinepvals[thisrep] <-   anova(mySplineHH,mySplineHH_maineff)[2,8]#
}#
summary(myPolynomialHH)#
#
mean(residuals(myPolynomialHH)^2)#
#
myPolynomialHH1 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,1,raw=FALSE))#
myPolynomialHH2 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,2,raw=FALSE))#
myPolynomialHH3 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,3,raw=FALSE))#
myPolynomialHH4 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,4,raw=FALSE))#
myPolynomialHH5 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,5,raw=FALSE))#
myPolynomialHH6 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,6,raw=FALSE))#
myPolynomialHH7 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,7,raw=FALSE))#
anova(myPolynomialHH1,myPolynomialHH2,myPolynomialHH3,myPolynomialHH4,myPolynomialHH5,myPolynomialHH6,myPolynomialHH7)#
#
mean(residuals(myPolynomialHH1)^2)#
mean(residuals(myPolynomialHH2)^2)#
mean(residuals(myPolynomialHH3)^2)#
mean(residuals(myPolynomialHH4)^2)#
mean(residuals(myPolynomialHH5)^2)#
mean(residuals(myPolynomialHH6)^2)#
mean(residuals(myPolynomialHH7)^2)#
#
summary(myPolynomialHH1)#
summary(myPolynomialHH2)#
summary(myPolynomialHH3)#
summary(myPolynomialHH4)#
summary(myPolynomialHH5)#
summary(myPolynomialHH6)#
summary(myPolynomialHH7)
# title: "For simulation tables"#
# date: 2023-08-22#
library(car)#
library(lme4)#
library(splines)#
install.packages("lmerTest")#
library(lmerTest)#
rm(list=ls())#
#
# Parameters#
#
mcruns = 5;#
#
reps.per.cell = 10;#
number_of_clusters = 20;#
number_of_clusters_per_crossover = 4#
number_of_time_periods = (number_of_clusters/number_of_clusters_per_crossover)+1;#
number_of_cells = number_of_clusters * number_of_time_periods;#
#
number.of.cells = number_of_cells;#
number.of.rows = number_of_clusters;#
number.of.columns = number_of_time_periods;#
#
Total_n = number.of.cells*reps.per.cell;#
#
noise.sd = 1; # the standard deviation of the general noise variance#
myintercept = 0;  # the intercept for the response model#
cluster.sd = 2; # the standard deviation for the cluster (row, clinic) main effects#
treatment.effect.size = 0; # the size of the treatment effect#
time_main_effects_sd = 1;#
#
sigmasq = noise.sd^2;#
tausq = cluster.sd^2;#
# Specify the time main effects for one rep#
time_main_effects = rnorm(n=number.of.columns,sd=time_main_effects_sd);#
time_main_effecs_onerep = rep(time_main_effects,each=number_of_clusters);#
# Create the full vector of treatment effects#
xtrts01_onerep = rep(0,number_of_cells);#
#
# column leftmost  #
xtrts01_onerep[1:number_of_clusters] = rep(0,number_of_clusters)#
# column rightmost#
xtrts01_onerep[((number_of_time_periods-1)*number_of_clusters+1):number_of_cells] = rep(1,number_of_clusters)#
for (j in 2:(number_of_time_periods-1)) {#
  equation1 = ((j-1)*number_of_clusters_per_crossover);#
  equation2 = number_of_clusters - equation1;#
  thiscolumn_asrowvec = c(rep(1,equation1), rep(0,equation2))#
  xtrts01_onerep[(1+number_of_clusters*(j-1)):(number_of_clusters*j)] = thiscolumn_asrowvec#
}#
xtrts01_onerep#
xtrts_onerep = xtrts01_onerep#
#
treatment.indicator.vec = rep(xtrts_onerep,reps.per.cell);#
treatment.effects.vec = treatment.effect.size * treatment.indicator.vec;#
treatment.fac = factor(treatment.indicator.vec)#
# Create vectors to store the Monte Carlo results#
HG.pvals.for.treatment = rep(NA,mcruns)#
HG.effect.size.treatment = rep(NA,mcruns)#
HG.time3.effect.size = rep(NA,mcruns)#
#
reml.HH.pvals.for.treatment = rep(NA,mcruns)#
reml.HH.effect.size.treatment = rep(NA,mcruns)#
reml.HH.time3.effect.size = rep(NA,mcruns)#
#
polynomial.HH.pvals.for.treatment = rep(NA,mcruns)#
polynomial.HH.effect.size.treatment = rep(NA,mcruns)#
#
spline.HH.pvals.for.treatment = rep(NA,mcruns)#
spline.HH.effect.size.treatment = rep(NA,mcruns);#
#
cluster_specific_Polypvals = rep(NA,mcruns)#
cluster_specific_Splinepvals = rep(NA,mcruns)#
#
GLS.effect.sizes = rep(NA,mcruns);#
############################################
############################################
############  GLS calculations#
############################################
############################################
#
# For variable name cross-reference, see matlabProgram4SWTDesigns.m#
#
xtimesbase = diag(number_of_time_periods)#
#
xtimes = kronecker(xtimesbase,t(rep(1,number_of_clusters)))#
#
dim(xtimes)#
#
xtrts01 = rep(0,number_of_cells)#
#
# leftmost column#
xtrts01[1:number_of_clusters] = rep(0,number_of_clusters);#
# rightmost column#
xtrts01[((number_of_time_periods-1)*number_of_clusters+1):number_of_cells] = rep(1,number_of_clusters);#
for (j in 2:(number_of_time_periods-1)){#
  equation1 = ((j-1)*number_of_clusters_per_crossover);#
  equation2 = number_of_clusters - equation1;#
  thiscolumn_asrowvec = c(rep(1,equation1),rep(0,equation2));#
  xtrts01[(1+number_of_clusters*(j-1)):(number_of_clusters*j)] = thiscolumn_asrowvec;#
}#
xtrts01 #
xtrts = 2 * (xtrts01-0.5);#
xtrts = t(xtrts)#
#
x = cbind(t(xtimes),t(xtrts))#
#
dim(x)#
#
z = diag(number_of_clusters);#
z = kronecker(t(rep(1,number_of_time_periods)),z)#
#
G = tausq * diag(number_of_clusters);#
R = sigmasq * diag(number_of_cells);#
V = t(z) %*% G %*% z + R;#
# V #
Vinv = solve(V)#
#
inv_xtxwithV_inv = solve(t(x)%*%Vinv%*%x)#
#
mysol = inv_xtxwithV_inv %*% t(x) %*% Vinv;#
#
trtestimator = 2*mysol[(1+number_of_time_periods),]#
#
length(trtestimator)#
#
mytrtmat = matrix(trtestimator,ncol=number_of_time_periods)#
#
mytrtmat#
############################################
############################################
############  SIMULATION LOOP#
############################################
############################################
#
mystarttime = Sys.time();#
#
for (thisrep in 1:mcruns){#
#
  # Specify the interaction pattern for one rep#
  time_by_cluster_interactions_onerep = rep(0,number_of_cells);#
  rowpattern1 = c(1,2,3,3,2,1);#
  rowpattern2 = c(3,2,1,1,2,3);#
  patternlist = list(rowpattern1,rowpattern2)#
  theserows =  c(rep(1,number_of_clusters/2),rep(2,number_of_clusters/2))#
  # theserows =  c(rep(1,5),rep(2,5))#
  byrowinteractions = matrix(NA,ncol=number_of_time_periods,nrow=number_of_clusters,byrow=T);#
  for (i in 1:number_of_clusters) {#
    byrowinteractions[i,] = patternlist[[theserows[i]]]#
  }#
  time_by_cluster_interactions_onerep = c(byrowinteractions);#
  time_by_cluster_interactions_onerep#
  # Create the full vector of cluster-specific time effects#
  cluster_specific_time_effects = #
  rep(time_main_effecs_onerep+time_by_cluster_interactions_onerep,reps.per.cell)#
#
  GLS.effect.sizes[thisrep] = sum(trtestimator*time_by_cluster_interactions_onerep);#
  mynoise = rnorm(n=number.of.cells*reps.per.cell,sd=noise.sd)#
#
  # Add a random cluster main effect#
  cluster.main.effects = rnorm(n=number.of.rows,sd=cluster.sd);#
  cluster.numbers.vec = rep(1:number.of.rows,(number.of.columns*reps.per.cell))#
  cluster.effects.vec = cluster.main.effects[cluster.numbers.vec]#
#
  # Generate the response #
  myresp = myintercept + cluster.effects.vec + treatment.effects.vec + #
   cluster_specific_time_effects + mynoise;#
  # Now fit the Hooper-Girling and H/H model#
  HG.cluster.factor = factor(cluster.numbers.vec);#
  HG.treatment.ind = treatment.indicator.vec;#
  times.vec = rep(rep(1:number_of_time_periods,each=number_of_clusters),reps.per.cell);#
  HG.time.factor = factor(times.vec);#
  HG.time.numeric = times.vec;#
#
  mylmerHG = lmer(myresp ~ (1|HG.cluster.factor) + HG.treatment.ind +#
               HG.time.factor + (1|(HG.cluster.factor:HG.time.factor)),REML=1);#
  summary(mylmerHG)#
#
  HG.pvals.for.treatment[thisrep] = anova(mylmerHG)[1,6]#
  HG.effect.size.treatment[thisrep] = summary(mylmerHG)$coefficients[2,1];#
#
  mylmerHHreml  = lmer(myresp ~ (1|HG.cluster.factor) + HG.treatment.ind +#
         HG.time.factor,REML=1 );#
  summary(mylmerHHreml)#
#
  reml.HH.pvals.for.treatment[thisrep] = anova(mylmerHHreml)[1,6]#
  reml.HH.effect.size.treatment[thisrep] = summary(mylmerHHreml)$coefficients[2,1];#
#
  thisdeltaHH = summary(mylmerHHreml)$coefficients[2,1];#
  myPolynomialHH = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
    + HG.cluster.factor:poly(HG.time.numeric,3,raw=TRUE))#
#
  myPolynomialHH_maineff = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor)+ poly(HG.time.numeric,2,raw=TRUE),#
    REML=1)#
  summary(myPolynomialHH_maineff)#
#
  anova(myPolynomialHH,myPolynomialHH_maineff)#
  cluster_specific_Polypvals[thisrep] <-   anova(myPolynomialHH,myPolynomialHH_maineff)[2,8]#
  summary(mylmerHHreml)#
#
  polynomial.HH.pvals.for.treatment[thisrep] = anova(myPolynomialHH)[1,6]#
  polynomial.HH.effect.size.treatment[thisrep] = summary(myPolynomialHH)$coefficients[2,1];#
#
# TRY  SPLINE#
#
  # mysplineHH = lmer(myresp ~  HG.treatment.ind + #
  #   bs(HG.time.numeric1,df=2) + #
  #   bs(HG.time.numeric2,df=2) + #
  #   bs(HG.time.numeric3,df=2) + #
  #   bs(HG.time.numeric4,df=2) + #
  #   bs(HG.time.numeric5,df=2) + #
  #   bs(HG.time.numeric6,df=2) + #
  #   bs(HG.time.numeric7,df=2) + #
  #   bs(HG.time.numeric8,df=2) + #
  #   bs(HG.time.numeric9,df=2) + #
  #   bs(HG.time.numeric10,df=2) +#
  #   bs(HG.time.numeric11,df=2) +#
  #   bs(HG.time.numeric12,df=2) +#
  #   bs(HG.time.numeric13,df=2) +#
  #   bs(HG.time.numeric14,df=2) +#
  #   bs(HG.time.numeric15,df=2) +#
  #   bs(HG.time.numeric16,df=2) +#
  #   bs(HG.time.numeric17,df=2) +#
  #   bs(HG.time.numeric18,df=2) +#
  #   bs(HG.time.numeric19,df=2) +#
  #   bs(HG.time.numeric20,df=2)  , #
  #   REML=1)#
  mySplineHH = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
    + HG.cluster.factor:bs(HG.time.numeric,df=3),REML=1)#
#
  mySplineHH_maineff = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor)+ bs(HG.time.numeric,df=3),#
    REML=1)#
#
  summary(mySplineHH)#
  spline.HH.pvals.for.treatment[thisrep] = anova(mySplineHH)[1,6]#
  spline.HH.effect.size.treatment[thisrep] = summary(mySplineHH)$coefficients[2,1];#
#
  summary(mySplineHH_maineff)#
#
  anova(mySplineHH,mySplineHH_maineff)#
  cluster_specific_Splinepvals[thisrep] <-   anova(mySplineHH,mySplineHH_maineff)[2,8]#
}#
summary(myPolynomialHH)#
#
mean(residuals(myPolynomialHH)^2)#
#
myPolynomialHH1 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,1,raw=FALSE))#
myPolynomialHH2 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,2,raw=FALSE))#
myPolynomialHH3 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,3,raw=FALSE))#
myPolynomialHH4 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,4,raw=FALSE))#
myPolynomialHH5 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,5,raw=FALSE))#
myPolynomialHH6 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,6,raw=FALSE))#
myPolynomialHH7 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,7,raw=FALSE))#
anova(myPolynomialHH1,myPolynomialHH2,myPolynomialHH3,myPolynomialHH4,myPolynomialHH5,myPolynomialHH6,myPolynomialHH7)
# title: "For simulation tables"#
# date: 2023-08-22#
library(car)#
library(lme4)#
library(splines)#
install.packages("lmerTest")#
library(lmerTest)#
rm(list=ls())#
#
# Parameters#
#
mcruns = 5;#
#
reps.per.cell = 10;#
number_of_clusters = 20;#
number_of_clusters_per_crossover = 4#
number_of_time_periods = (number_of_clusters/number_of_clusters_per_crossover)+1;#
number_of_cells = number_of_clusters * number_of_time_periods;#
#
number.of.cells = number_of_cells;#
number.of.rows = number_of_clusters;#
number.of.columns = number_of_time_periods;#
#
Total_n = number.of.cells*reps.per.cell;#
#
noise.sd = 1; # the standard deviation of the general noise variance#
myintercept = 0;  # the intercept for the response model#
cluster.sd = 2; # the standard deviation for the cluster (row, clinic) main effects#
treatment.effect.size = 0; # the size of the treatment effect#
time_main_effects_sd = 1;#
#
sigmasq = noise.sd^2;#
tausq = cluster.sd^2;#
# Specify the time main effects for one rep#
time_main_effects = rnorm(n=number.of.columns,sd=time_main_effects_sd);#
time_main_effecs_onerep = rep(time_main_effects,each=number_of_clusters);#
# Create the full vector of treatment effects#
xtrts01_onerep = rep(0,number_of_cells);#
#
# column leftmost  #
xtrts01_onerep[1:number_of_clusters] = rep(0,number_of_clusters)#
# column rightmost#
xtrts01_onerep[((number_of_time_periods-1)*number_of_clusters+1):number_of_cells] = rep(1,number_of_clusters)#
for (j in 2:(number_of_time_periods-1)) {#
  equation1 = ((j-1)*number_of_clusters_per_crossover);#
  equation2 = number_of_clusters - equation1;#
  thiscolumn_asrowvec = c(rep(1,equation1), rep(0,equation2))#
  xtrts01_onerep[(1+number_of_clusters*(j-1)):(number_of_clusters*j)] = thiscolumn_asrowvec#
}#
xtrts01_onerep#
xtrts_onerep = xtrts01_onerep#
#
treatment.indicator.vec = rep(xtrts_onerep,reps.per.cell);#
treatment.effects.vec = treatment.effect.size * treatment.indicator.vec;#
treatment.fac = factor(treatment.indicator.vec)#
# Create vectors to store the Monte Carlo results#
HG.pvals.for.treatment = rep(NA,mcruns)#
HG.effect.size.treatment = rep(NA,mcruns)#
HG.time3.effect.size = rep(NA,mcruns)#
#
reml.HH.pvals.for.treatment = rep(NA,mcruns)#
reml.HH.effect.size.treatment = rep(NA,mcruns)#
reml.HH.time3.effect.size = rep(NA,mcruns)#
#
polynomial.HH.pvals.for.treatment = rep(NA,mcruns)#
polynomial.HH.effect.size.treatment = rep(NA,mcruns)#
#
spline.HH.pvals.for.treatment = rep(NA,mcruns)#
spline.HH.effect.size.treatment = rep(NA,mcruns);#
#
cluster_specific_Polypvals = rep(NA,mcruns)#
cluster_specific_Splinepvals = rep(NA,mcruns)#
#
GLS.effect.sizes = rep(NA,mcruns);#
############################################
############################################
############  GLS calculations#
############################################
############################################
#
# For variable name cross-reference, see matlabProgram4SWTDesigns.m#
#
xtimesbase = diag(number_of_time_periods)#
#
xtimes = kronecker(xtimesbase,t(rep(1,number_of_clusters)))#
#
dim(xtimes)#
#
xtrts01 = rep(0,number_of_cells)#
#
# leftmost column#
xtrts01[1:number_of_clusters] = rep(0,number_of_clusters);#
# rightmost column#
xtrts01[((number_of_time_periods-1)*number_of_clusters+1):number_of_cells] = rep(1,number_of_clusters);#
for (j in 2:(number_of_time_periods-1)){#
  equation1 = ((j-1)*number_of_clusters_per_crossover);#
  equation2 = number_of_clusters - equation1;#
  thiscolumn_asrowvec = c(rep(1,equation1),rep(0,equation2));#
  xtrts01[(1+number_of_clusters*(j-1)):(number_of_clusters*j)] = thiscolumn_asrowvec;#
}#
xtrts01 #
xtrts = 2 * (xtrts01-0.5);#
xtrts = t(xtrts)#
#
x = cbind(t(xtimes),t(xtrts))#
#
dim(x)#
#
z = diag(number_of_clusters);#
z = kronecker(t(rep(1,number_of_time_periods)),z)#
#
G = tausq * diag(number_of_clusters);#
R = sigmasq * diag(number_of_cells);#
V = t(z) %*% G %*% z + R;#
# V #
Vinv = solve(V)#
#
inv_xtxwithV_inv = solve(t(x)%*%Vinv%*%x)#
#
mysol = inv_xtxwithV_inv %*% t(x) %*% Vinv;#
#
trtestimator = 2*mysol[(1+number_of_time_periods),]#
#
length(trtestimator)#
#
mytrtmat = matrix(trtestimator,ncol=number_of_time_periods)#
#
mytrtmat#
############################################
############################################
############  SIMULATION LOOP#
############################################
############################################
#
mystarttime = Sys.time();#
#
for (thisrep in 1:mcruns){#
#
  # Specify the interaction pattern for one rep#
  time_by_cluster_interactions_onerep = rep(0,number_of_cells);#
  rowpattern1 = c(1,2,3,3,2,1);#
  rowpattern2 = c(3,2,1,1,2,3);#
  patternlist = list(rowpattern1,rowpattern2)#
  theserows =  c(rep(1,number_of_clusters/2),rep(2,number_of_clusters/2))#
  # theserows =  c(rep(1,5),rep(2,5))#
  byrowinteractions = matrix(NA,ncol=number_of_time_periods,nrow=number_of_clusters,byrow=T);#
  for (i in 1:number_of_clusters) {#
    byrowinteractions[i,] = patternlist[[theserows[i]]]#
  }#
  time_by_cluster_interactions_onerep = c(byrowinteractions);#
  time_by_cluster_interactions_onerep#
  # Create the full vector of cluster-specific time effects#
  cluster_specific_time_effects = #
  rep(time_main_effecs_onerep+time_by_cluster_interactions_onerep,reps.per.cell)#
#
  GLS.effect.sizes[thisrep] = sum(trtestimator*time_by_cluster_interactions_onerep);#
  mynoise = rnorm(n=number.of.cells*reps.per.cell,sd=noise.sd)#
#
  # Add a random cluster main effect#
  cluster.main.effects = rnorm(n=number.of.rows,sd=cluster.sd);#
  cluster.numbers.vec = rep(1:number.of.rows,(number.of.columns*reps.per.cell))#
  cluster.effects.vec = cluster.main.effects[cluster.numbers.vec]#
#
  # Generate the response #
  myresp = myintercept + cluster.effects.vec + treatment.effects.vec + #
   cluster_specific_time_effects + mynoise;#
  # Now fit the Hooper-Girling and H/H model#
  HG.cluster.factor = factor(cluster.numbers.vec);#
  HG.treatment.ind = treatment.indicator.vec;#
  times.vec = rep(rep(1:number_of_time_periods,each=number_of_clusters),reps.per.cell);#
  HG.time.factor = factor(times.vec);#
  HG.time.numeric = times.vec;#
#
  mylmerHG = lmer(myresp ~ (1|HG.cluster.factor) + HG.treatment.ind +#
               HG.time.factor + (1|(HG.cluster.factor:HG.time.factor)),REML=1);#
  summary(mylmerHG)#
#
  HG.pvals.for.treatment[thisrep] = anova(mylmerHG)[1,6]#
  HG.effect.size.treatment[thisrep] = summary(mylmerHG)$coefficients[2,1];#
#
  mylmerHHreml  = lmer(myresp ~ (1|HG.cluster.factor) + HG.treatment.ind +#
         HG.time.factor,REML=1 );#
  summary(mylmerHHreml)#
#
  reml.HH.pvals.for.treatment[thisrep] = anova(mylmerHHreml)[1,6]#
  reml.HH.effect.size.treatment[thisrep] = summary(mylmerHHreml)$coefficients[2,1];#
#
  thisdeltaHH = summary(mylmerHHreml)$coefficients[2,1];#
  myPolynomialHH = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
    + HG.cluster.factor:poly(HG.time.numeric,3,raw=TRUE))#
#
  myPolynomialHH_maineff = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor)+ poly(HG.time.numeric,2,raw=TRUE),#
    REML=1)#
  summary(myPolynomialHH_maineff)#
#
  anova(myPolynomialHH,myPolynomialHH_maineff)#
  cluster_specific_Polypvals[thisrep] <-   anova(myPolynomialHH,myPolynomialHH_maineff)[2,8]#
  summary(mylmerHHreml)#
#
  polynomial.HH.pvals.for.treatment[thisrep] = anova(myPolynomialHH)[1,6]#
  polynomial.HH.effect.size.treatment[thisrep] = summary(myPolynomialHH)$coefficients[2,1];#
#
# TRY  SPLINE#
#
  # mysplineHH = lmer(myresp ~  HG.treatment.ind + #
  #   bs(HG.time.numeric1,df=2) + #
  #   bs(HG.time.numeric2,df=2) + #
  #   bs(HG.time.numeric3,df=2) + #
  #   bs(HG.time.numeric4,df=2) + #
  #   bs(HG.time.numeric5,df=2) + #
  #   bs(HG.time.numeric6,df=2) + #
  #   bs(HG.time.numeric7,df=2) + #
  #   bs(HG.time.numeric8,df=2) + #
  #   bs(HG.time.numeric9,df=2) + #
  #   bs(HG.time.numeric10,df=2) +#
  #   bs(HG.time.numeric11,df=2) +#
  #   bs(HG.time.numeric12,df=2) +#
  #   bs(HG.time.numeric13,df=2) +#
  #   bs(HG.time.numeric14,df=2) +#
  #   bs(HG.time.numeric15,df=2) +#
  #   bs(HG.time.numeric16,df=2) +#
  #   bs(HG.time.numeric17,df=2) +#
  #   bs(HG.time.numeric18,df=2) +#
  #   bs(HG.time.numeric19,df=2) +#
  #   bs(HG.time.numeric20,df=2)  , #
  #   REML=1)#
  mySplineHH = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
    + HG.cluster.factor:bs(HG.time.numeric,df=3),REML=1)#
#
  mySplineHH_maineff = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor)+ bs(HG.time.numeric,df=3),#
    REML=1)#
#
  summary(mySplineHH)#
  spline.HH.pvals.for.treatment[thisrep] = anova(mySplineHH)[1,6]#
  spline.HH.effect.size.treatment[thisrep] = summary(mySplineHH)$coefficients[2,1];#
#
  summary(mySplineHH_maineff)#
#
  anova(mySplineHH,mySplineHH_maineff)#
  cluster_specific_Splinepvals[thisrep] <-   anova(mySplineHH,mySplineHH_maineff)[2,8]#
}#
summary(myPolynomialHH)#
#
mean(residuals(myPolynomialHH)^2)#
#
myPolynomialHH1 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,1,raw=FALSE))#
myPolynomialHH2 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,2,raw=FALSE))#
myPolynomialHH3 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,3,raw=FALSE))#
myPolynomialHH4 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,4,raw=FALSE))#
myPolynomialHH5 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,5,raw=FALSE))#
myPolynomialHH6 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,6,raw=FALSE))#
myPolynomialHH7 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,7,raw=FALSE))#
anova(myPolynomialHH1,myPolynomialHH2,myPolynomialHH3,myPolynomialHH4,myPolynomialHH5)
# title: "For simulation tables"#
# date: 2023-08-22#
library(car)#
library(lme4)#
library(splines)#
install.packages("lmerTest")#
library(lmerTest)#
rm(list=ls())#
#
# Parameters#
#
mcruns = 5;#
#
reps.per.cell = 10;#
number_of_clusters = 20;#
number_of_clusters_per_crossover = 4#
number_of_time_periods = (number_of_clusters/number_of_clusters_per_crossover)+1;#
number_of_cells = number_of_clusters * number_of_time_periods;#
#
number.of.cells = number_of_cells;#
number.of.rows = number_of_clusters;#
number.of.columns = number_of_time_periods;#
#
Total_n = number.of.cells*reps.per.cell;#
#
noise.sd = 1; # the standard deviation of the general noise variance#
myintercept = 0;  # the intercept for the response model#
cluster.sd = 2; # the standard deviation for the cluster (row, clinic) main effects#
treatment.effect.size = 0; # the size of the treatment effect#
time_main_effects_sd = 1;#
#
sigmasq = noise.sd^2;#
tausq = cluster.sd^2;#
# Specify the time main effects for one rep#
time_main_effects = rnorm(n=number.of.columns,sd=time_main_effects_sd);#
time_main_effecs_onerep = rep(time_main_effects,each=number_of_clusters);#
# Create the full vector of treatment effects#
xtrts01_onerep = rep(0,number_of_cells);#
#
# column leftmost  #
xtrts01_onerep[1:number_of_clusters] = rep(0,number_of_clusters)#
# column rightmost#
xtrts01_onerep[((number_of_time_periods-1)*number_of_clusters+1):number_of_cells] = rep(1,number_of_clusters)#
for (j in 2:(number_of_time_periods-1)) {#
  equation1 = ((j-1)*number_of_clusters_per_crossover);#
  equation2 = number_of_clusters - equation1;#
  thiscolumn_asrowvec = c(rep(1,equation1), rep(0,equation2))#
  xtrts01_onerep[(1+number_of_clusters*(j-1)):(number_of_clusters*j)] = thiscolumn_asrowvec#
}#
xtrts01_onerep#
xtrts_onerep = xtrts01_onerep#
#
treatment.indicator.vec = rep(xtrts_onerep,reps.per.cell);#
treatment.effects.vec = treatment.effect.size * treatment.indicator.vec;#
treatment.fac = factor(treatment.indicator.vec)#
# Create vectors to store the Monte Carlo results#
HG.pvals.for.treatment = rep(NA,mcruns)#
HG.effect.size.treatment = rep(NA,mcruns)#
HG.time3.effect.size = rep(NA,mcruns)#
#
reml.HH.pvals.for.treatment = rep(NA,mcruns)#
reml.HH.effect.size.treatment = rep(NA,mcruns)#
reml.HH.time3.effect.size = rep(NA,mcruns)#
#
polynomial.HH.pvals.for.treatment = rep(NA,mcruns)#
polynomial.HH.effect.size.treatment = rep(NA,mcruns)#
#
spline.HH.pvals.for.treatment = rep(NA,mcruns)#
spline.HH.effect.size.treatment = rep(NA,mcruns);#
#
cluster_specific_Polypvals = rep(NA,mcruns)#
cluster_specific_Splinepvals = rep(NA,mcruns)#
#
GLS.effect.sizes = rep(NA,mcruns);#
############################################
############################################
############  GLS calculations#
############################################
############################################
#
# For variable name cross-reference, see matlabProgram4SWTDesigns.m#
#
xtimesbase = diag(number_of_time_periods)#
#
xtimes = kronecker(xtimesbase,t(rep(1,number_of_clusters)))#
#
dim(xtimes)#
#
xtrts01 = rep(0,number_of_cells)#
#
# leftmost column#
xtrts01[1:number_of_clusters] = rep(0,number_of_clusters);#
# rightmost column#
xtrts01[((number_of_time_periods-1)*number_of_clusters+1):number_of_cells] = rep(1,number_of_clusters);#
for (j in 2:(number_of_time_periods-1)){#
  equation1 = ((j-1)*number_of_clusters_per_crossover);#
  equation2 = number_of_clusters - equation1;#
  thiscolumn_asrowvec = c(rep(1,equation1),rep(0,equation2));#
  xtrts01[(1+number_of_clusters*(j-1)):(number_of_clusters*j)] = thiscolumn_asrowvec;#
}#
xtrts01 #
xtrts = 2 * (xtrts01-0.5);#
xtrts = t(xtrts)#
#
x = cbind(t(xtimes),t(xtrts))#
#
dim(x)#
#
z = diag(number_of_clusters);#
z = kronecker(t(rep(1,number_of_time_periods)),z)#
#
G = tausq * diag(number_of_clusters);#
R = sigmasq * diag(number_of_cells);#
V = t(z) %*% G %*% z + R;#
# V #
Vinv = solve(V)#
#
inv_xtxwithV_inv = solve(t(x)%*%Vinv%*%x)#
#
mysol = inv_xtxwithV_inv %*% t(x) %*% Vinv;#
#
trtestimator = 2*mysol[(1+number_of_time_periods),]#
#
length(trtestimator)#
#
mytrtmat = matrix(trtestimator,ncol=number_of_time_periods)#
#
mytrtmat#
############################################
############################################
############  SIMULATION LOOP#
############################################
############################################
#
mystarttime = Sys.time();#
#
for (thisrep in 1:mcruns){#
#
  # Specify the interaction pattern for one rep#
  time_by_cluster_interactions_onerep = rep(0,number_of_cells);#
  rowpattern1 = c(1,2,3,4,4,4);#
  rowpattern2 = c(4,3,2,1,1,1);#
  patternlist = list(rowpattern1,rowpattern2)#
  theserows =  c(rep(1,number_of_clusters/2),rep(2,number_of_clusters/2))#
  # theserows =  c(rep(1,5),rep(2,5))#
  byrowinteractions = matrix(NA,ncol=number_of_time_periods,nrow=number_of_clusters,byrow=T);#
  for (i in 1:number_of_clusters) {#
    byrowinteractions[i,] = patternlist[[theserows[i]]]#
  }#
  time_by_cluster_interactions_onerep = c(byrowinteractions);#
  time_by_cluster_interactions_onerep#
  # Create the full vector of cluster-specific time effects#
  cluster_specific_time_effects = #
  rep(time_main_effecs_onerep+time_by_cluster_interactions_onerep,reps.per.cell)#
#
  GLS.effect.sizes[thisrep] = sum(trtestimator*time_by_cluster_interactions_onerep);#
  mynoise = rnorm(n=number.of.cells*reps.per.cell,sd=noise.sd)#
#
  # Add a random cluster main effect#
  cluster.main.effects = rnorm(n=number.of.rows,sd=cluster.sd);#
  cluster.numbers.vec = rep(1:number.of.rows,(number.of.columns*reps.per.cell))#
  cluster.effects.vec = cluster.main.effects[cluster.numbers.vec]#
#
  # Generate the response #
  myresp = myintercept + cluster.effects.vec + treatment.effects.vec + #
   cluster_specific_time_effects + mynoise;#
  # Now fit the Hooper-Girling and H/H model#
  HG.cluster.factor = factor(cluster.numbers.vec);#
  HG.treatment.ind = treatment.indicator.vec;#
  times.vec = rep(rep(1:number_of_time_periods,each=number_of_clusters),reps.per.cell);#
  HG.time.factor = factor(times.vec);#
  HG.time.numeric = times.vec;#
#
  mylmerHG = lmer(myresp ~ (1|HG.cluster.factor) + HG.treatment.ind +#
               HG.time.factor + (1|(HG.cluster.factor:HG.time.factor)),REML=1);#
  summary(mylmerHG)#
#
  HG.pvals.for.treatment[thisrep] = anova(mylmerHG)[1,6]#
  HG.effect.size.treatment[thisrep] = summary(mylmerHG)$coefficients[2,1];#
#
  mylmerHHreml  = lmer(myresp ~ (1|HG.cluster.factor) + HG.treatment.ind +#
         HG.time.factor,REML=1 );#
  summary(mylmerHHreml)#
#
  reml.HH.pvals.for.treatment[thisrep] = anova(mylmerHHreml)[1,6]#
  reml.HH.effect.size.treatment[thisrep] = summary(mylmerHHreml)$coefficients[2,1];#
#
  thisdeltaHH = summary(mylmerHHreml)$coefficients[2,1];#
  myPolynomialHH = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
    + HG.cluster.factor:poly(HG.time.numeric,3,raw=TRUE))#
#
  myPolynomialHH_maineff = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor)+ poly(HG.time.numeric,2,raw=TRUE),#
    REML=1)#
  summary(myPolynomialHH_maineff)#
#
  anova(myPolynomialHH,myPolynomialHH_maineff)#
  cluster_specific_Polypvals[thisrep] <-   anova(myPolynomialHH,myPolynomialHH_maineff)[2,8]#
  summary(mylmerHHreml)#
#
  polynomial.HH.pvals.for.treatment[thisrep] = anova(myPolynomialHH)[1,6]#
  polynomial.HH.effect.size.treatment[thisrep] = summary(myPolynomialHH)$coefficients[2,1];#
#
# TRY  SPLINE#
#
  # mysplineHH = lmer(myresp ~  HG.treatment.ind + #
  #   bs(HG.time.numeric1,df=2) + #
  #   bs(HG.time.numeric2,df=2) + #
  #   bs(HG.time.numeric3,df=2) + #
  #   bs(HG.time.numeric4,df=2) + #
  #   bs(HG.time.numeric5,df=2) + #
  #   bs(HG.time.numeric6,df=2) + #
  #   bs(HG.time.numeric7,df=2) + #
  #   bs(HG.time.numeric8,df=2) + #
  #   bs(HG.time.numeric9,df=2) + #
  #   bs(HG.time.numeric10,df=2) +#
  #   bs(HG.time.numeric11,df=2) +#
  #   bs(HG.time.numeric12,df=2) +#
  #   bs(HG.time.numeric13,df=2) +#
  #   bs(HG.time.numeric14,df=2) +#
  #   bs(HG.time.numeric15,df=2) +#
  #   bs(HG.time.numeric16,df=2) +#
  #   bs(HG.time.numeric17,df=2) +#
  #   bs(HG.time.numeric18,df=2) +#
  #   bs(HG.time.numeric19,df=2) +#
  #   bs(HG.time.numeric20,df=2)  , #
  #   REML=1)#
  mySplineHH = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
    + HG.cluster.factor:bs(HG.time.numeric,df=3),REML=1)#
#
  mySplineHH_maineff = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor)+ bs(HG.time.numeric,df=3),#
    REML=1)#
#
  summary(mySplineHH)#
  spline.HH.pvals.for.treatment[thisrep] = anova(mySplineHH)[1,6]#
  spline.HH.effect.size.treatment[thisrep] = summary(mySplineHH)$coefficients[2,1];#
#
  summary(mySplineHH_maineff)#
#
  anova(mySplineHH,mySplineHH_maineff)#
  cluster_specific_Splinepvals[thisrep] <-   anova(mySplineHH,mySplineHH_maineff)[2,8]#
}#
summary(myPolynomialHH)#
#
mean(residuals(myPolynomialHH)^2)#
#
myPolynomialHH1 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,1,raw=FALSE))#
myPolynomialHH2 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,2,raw=FALSE))#
myPolynomialHH3 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,3,raw=FALSE))#
myPolynomialHH4 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,4,raw=FALSE))#
myPolynomialHH5 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,5,raw=FALSE))#
anova(myPolynomialHH1,myPolynomialHH2,myPolynomialHH3,myPolynomialHH4,myPolynomialHH5)
# title: "For simulation tables"#
# date: 2023-08-22#
library(car)#
library(lme4)#
library(splines)#
install.packages("lmerTest")#
library(lmerTest)#
rm(list=ls())#
#
# Parameters#
#
mcruns = 5;#
#
reps.per.cell = 10;#
number_of_clusters = 20;#
number_of_clusters_per_crossover = 4#
number_of_time_periods = (number_of_clusters/number_of_clusters_per_crossover)+1;#
number_of_cells = number_of_clusters * number_of_time_periods;#
#
number.of.cells = number_of_cells;#
number.of.rows = number_of_clusters;#
number.of.columns = number_of_time_periods;#
#
Total_n = number.of.cells*reps.per.cell;#
#
noise.sd = 1; # the standard deviation of the general noise variance#
myintercept = 0;  # the intercept for the response model#
cluster.sd = 2; # the standard deviation for the cluster (row, clinic) main effects#
treatment.effect.size = 0; # the size of the treatment effect#
time_main_effects_sd = 1;#
#
sigmasq = noise.sd^2;#
tausq = cluster.sd^2;#
# Specify the time main effects for one rep#
time_main_effects = rnorm(n=number.of.columns,sd=time_main_effects_sd);#
time_main_effecs_onerep = rep(time_main_effects,each=number_of_clusters);#
# Create the full vector of treatment effects#
xtrts01_onerep = rep(0,number_of_cells);#
#
# column leftmost  #
xtrts01_onerep[1:number_of_clusters] = rep(0,number_of_clusters)#
# column rightmost#
xtrts01_onerep[((number_of_time_periods-1)*number_of_clusters+1):number_of_cells] = rep(1,number_of_clusters)#
for (j in 2:(number_of_time_periods-1)) {#
  equation1 = ((j-1)*number_of_clusters_per_crossover);#
  equation2 = number_of_clusters - equation1;#
  thiscolumn_asrowvec = c(rep(1,equation1), rep(0,equation2))#
  xtrts01_onerep[(1+number_of_clusters*(j-1)):(number_of_clusters*j)] = thiscolumn_asrowvec#
}#
xtrts01_onerep#
xtrts_onerep = xtrts01_onerep#
#
treatment.indicator.vec = rep(xtrts_onerep,reps.per.cell);#
treatment.effects.vec = treatment.effect.size * treatment.indicator.vec;#
treatment.fac = factor(treatment.indicator.vec)#
# Create vectors to store the Monte Carlo results#
HG.pvals.for.treatment = rep(NA,mcruns)#
HG.effect.size.treatment = rep(NA,mcruns)#
HG.time3.effect.size = rep(NA,mcruns)#
#
reml.HH.pvals.for.treatment = rep(NA,mcruns)#
reml.HH.effect.size.treatment = rep(NA,mcruns)#
reml.HH.time3.effect.size = rep(NA,mcruns)#
#
polynomial.HH.pvals.for.treatment = rep(NA,mcruns)#
polynomial.HH.effect.size.treatment = rep(NA,mcruns)#
#
spline.HH.pvals.for.treatment = rep(NA,mcruns)#
spline.HH.effect.size.treatment = rep(NA,mcruns);#
#
cluster_specific_Polypvals = rep(NA,mcruns)#
cluster_specific_Splinepvals = rep(NA,mcruns)#
#
GLS.effect.sizes = rep(NA,mcruns);#
############################################
############################################
############  GLS calculations#
############################################
############################################
#
# For variable name cross-reference, see matlabProgram4SWTDesigns.m#
#
xtimesbase = diag(number_of_time_periods)#
#
xtimes = kronecker(xtimesbase,t(rep(1,number_of_clusters)))#
#
dim(xtimes)#
#
xtrts01 = rep(0,number_of_cells)#
#
# leftmost column#
xtrts01[1:number_of_clusters] = rep(0,number_of_clusters);#
# rightmost column#
xtrts01[((number_of_time_periods-1)*number_of_clusters+1):number_of_cells] = rep(1,number_of_clusters);#
for (j in 2:(number_of_time_periods-1)){#
  equation1 = ((j-1)*number_of_clusters_per_crossover);#
  equation2 = number_of_clusters - equation1;#
  thiscolumn_asrowvec = c(rep(1,equation1),rep(0,equation2));#
  xtrts01[(1+number_of_clusters*(j-1)):(number_of_clusters*j)] = thiscolumn_asrowvec;#
}#
xtrts01 #
xtrts = 2 * (xtrts01-0.5);#
xtrts = t(xtrts)#
#
x = cbind(t(xtimes),t(xtrts))#
#
dim(x)#
#
z = diag(number_of_clusters);#
z = kronecker(t(rep(1,number_of_time_periods)),z)#
#
G = tausq * diag(number_of_clusters);#
R = sigmasq * diag(number_of_cells);#
V = t(z) %*% G %*% z + R;#
# V #
Vinv = solve(V)#
#
inv_xtxwithV_inv = solve(t(x)%*%Vinv%*%x)#
#
mysol = inv_xtxwithV_inv %*% t(x) %*% Vinv;#
#
trtestimator = 2*mysol[(1+number_of_time_periods),]#
#
length(trtestimator)#
#
mytrtmat = matrix(trtestimator,ncol=number_of_time_periods)#
#
mytrtmat#
############################################
############################################
############  SIMULATION LOOP#
############################################
############################################
#
mystarttime = Sys.time();#
#
for (thisrep in 1:mcruns){#
#
  # Specify the interaction pattern for one rep#
  time_by_cluster_interactions_onerep = rep(0,number_of_cells);#
  rowpattern1 = c(1,2,3,4,4,4);#
  rowpattern2 = c(4,3,2,1,1,1);#
  patternlist = list(rowpattern1,rowpattern2)#
  theserows =  c(rep(1,number_of_clusters/2),rep(2,number_of_clusters/2))#
  # theserows =  c(rep(1,5),rep(2,5))#
  byrowinteractions = matrix(NA,ncol=number_of_time_periods,nrow=number_of_clusters,byrow=T);#
  for (i in 1:number_of_clusters) {#
    byrowinteractions[i,] = patternlist[[theserows[i]]]#
  }#
  time_by_cluster_interactions_onerep = c(byrowinteractions);#
  time_by_cluster_interactions_onerep#
  # Create the full vector of cluster-specific time effects#
  cluster_specific_time_effects = #
  rep(time_main_effecs_onerep+time_by_cluster_interactions_onerep,reps.per.cell)#
#
  GLS.effect.sizes[thisrep] = sum(trtestimator*time_by_cluster_interactions_onerep);#
  mynoise = rnorm(n=number.of.cells*reps.per.cell,sd=noise.sd)#
#
  # Add a random cluster main effect#
  cluster.main.effects = rnorm(n=number.of.rows,sd=cluster.sd);#
  cluster.numbers.vec = rep(1:number.of.rows,(number.of.columns*reps.per.cell))#
  cluster.effects.vec = cluster.main.effects[cluster.numbers.vec]#
#
  # Generate the response #
  myresp = myintercept + cluster.effects.vec + treatment.effects.vec + #
   cluster_specific_time_effects + mynoise;#
  # Now fit the Hooper-Girling and H/H model#
  HG.cluster.factor = factor(cluster.numbers.vec);#
  HG.treatment.ind = treatment.indicator.vec;#
  times.vec = rep(rep(1:number_of_time_periods,each=number_of_clusters),reps.per.cell);#
  HG.time.factor = factor(times.vec);#
  HG.time.numeric = times.vec;#
#
  mylmerHG = lmer(myresp ~ (1|HG.cluster.factor) + HG.treatment.ind +#
               HG.time.factor + (1|(HG.cluster.factor:HG.time.factor)),REML=1);#
  summary(mylmerHG)#
#
  HG.pvals.for.treatment[thisrep] = anova(mylmerHG)[1,6]#
  HG.effect.size.treatment[thisrep] = summary(mylmerHG)$coefficients[2,1];#
#
  mylmerHHreml  = lmer(myresp ~ (1|HG.cluster.factor) + HG.treatment.ind +#
         HG.time.factor,REML=1 );#
  summary(mylmerHHreml)#
#
  reml.HH.pvals.for.treatment[thisrep] = anova(mylmerHHreml)[1,6]#
  reml.HH.effect.size.treatment[thisrep] = summary(mylmerHHreml)$coefficients[2,1];#
#
  thisdeltaHH = summary(mylmerHHreml)$coefficients[2,1];#
  myPolynomialHH = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
    + HG.cluster.factor:poly(HG.time.numeric,3,raw=TRUE))#
#
  myPolynomialHH_maineff = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor)+ poly(HG.time.numeric,2,raw=TRUE),#
    REML=1)#
  summary(myPolynomialHH_maineff)#
#
  anova(myPolynomialHH,myPolynomialHH_maineff)#
  cluster_specific_Polypvals[thisrep] <-   anova(myPolynomialHH,myPolynomialHH_maineff)[2,8]#
  summary(mylmerHHreml)#
#
  polynomial.HH.pvals.for.treatment[thisrep] = anova(myPolynomialHH)[1,6]#
  polynomial.HH.effect.size.treatment[thisrep] = summary(myPolynomialHH)$coefficients[2,1];#
#
# TRY  SPLINE#
#
  # mysplineHH = lmer(myresp ~  HG.treatment.ind + #
  #   bs(HG.time.numeric1,df=2) + #
  #   bs(HG.time.numeric2,df=2) + #
  #   bs(HG.time.numeric3,df=2) + #
  #   bs(HG.time.numeric4,df=2) + #
  #   bs(HG.time.numeric5,df=2) + #
  #   bs(HG.time.numeric6,df=2) + #
  #   bs(HG.time.numeric7,df=2) + #
  #   bs(HG.time.numeric8,df=2) + #
  #   bs(HG.time.numeric9,df=2) + #
  #   bs(HG.time.numeric10,df=2) +#
  #   bs(HG.time.numeric11,df=2) +#
  #   bs(HG.time.numeric12,df=2) +#
  #   bs(HG.time.numeric13,df=2) +#
  #   bs(HG.time.numeric14,df=2) +#
  #   bs(HG.time.numeric15,df=2) +#
  #   bs(HG.time.numeric16,df=2) +#
  #   bs(HG.time.numeric17,df=2) +#
  #   bs(HG.time.numeric18,df=2) +#
  #   bs(HG.time.numeric19,df=2) +#
  #   bs(HG.time.numeric20,df=2)  , #
  #   REML=1)#
  mySplineHH = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
    + HG.cluster.factor:bs(HG.time.numeric,df=3),REML=1)#
#
  mySplineHH_maineff = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor)+ bs(HG.time.numeric,df=3),#
    REML=1)#
#
  summary(mySplineHH)#
  spline.HH.pvals.for.treatment[thisrep] = anova(mySplineHH)[1,6]#
  spline.HH.effect.size.treatment[thisrep] = summary(mySplineHH)$coefficients[2,1];#
#
  summary(mySplineHH_maineff)#
#
  anova(mySplineHH,mySplineHH_maineff)#
  cluster_specific_Splinepvals[thisrep] <-   anova(mySplineHH,mySplineHH_maineff)[2,8]#
}#
summary(myPolynomialHH)#
#
mean(residuals(myPolynomialHH)^2)#
#
myPolynomialHH1 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,1,raw=FALSE))#
myPolynomialHH2 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,2,raw=FALSE))#
myPolynomialHH3 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,3,raw=FALSE))#
myPolynomialHH4 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,4,raw=FALSE))#
myPolynomialHH5 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,5,raw=FALSE))#
anova(myPolynomialHH_maineff,myPolynomialHH1,myPolynomialHH2,myPolynomialHH3,myPolynomialHH4,myPolynomialHH5)
# title: "For simulation tables"#
# date: 2023-08-22#
library(car)#
library(lme4)#
library(splines)#
install.packages("lmerTest")#
library(lmerTest)#
rm(list=ls())#
#
# Parameters#
#
mcruns = 5;#
#
reps.per.cell = 10;#
number_of_clusters = 20;#
number_of_clusters_per_crossover = 4#
number_of_time_periods = (number_of_clusters/number_of_clusters_per_crossover)+1;#
number_of_cells = number_of_clusters * number_of_time_periods;#
#
number.of.cells = number_of_cells;#
number.of.rows = number_of_clusters;#
number.of.columns = number_of_time_periods;#
#
Total_n = number.of.cells*reps.per.cell;#
#
noise.sd = 1; # the standard deviation of the general noise variance#
myintercept = 0;  # the intercept for the response model#
cluster.sd = 2; # the standard deviation for the cluster (row, clinic) main effects#
treatment.effect.size = 0; # the size of the treatment effect#
time_main_effects_sd = 1;#
#
sigmasq = noise.sd^2;#
tausq = cluster.sd^2;#
# Specify the time main effects for one rep#
time_main_effects = rnorm(n=number.of.columns,sd=time_main_effects_sd);#
time_main_effecs_onerep = rep(time_main_effects,each=number_of_clusters);#
# Create the full vector of treatment effects#
xtrts01_onerep = rep(0,number_of_cells);#
#
# column leftmost  #
xtrts01_onerep[1:number_of_clusters] = rep(0,number_of_clusters)#
# column rightmost#
xtrts01_onerep[((number_of_time_periods-1)*number_of_clusters+1):number_of_cells] = rep(1,number_of_clusters)#
for (j in 2:(number_of_time_periods-1)) {#
  equation1 = ((j-1)*number_of_clusters_per_crossover);#
  equation2 = number_of_clusters - equation1;#
  thiscolumn_asrowvec = c(rep(1,equation1), rep(0,equation2))#
  xtrts01_onerep[(1+number_of_clusters*(j-1)):(number_of_clusters*j)] = thiscolumn_asrowvec#
}#
xtrts01_onerep#
xtrts_onerep = xtrts01_onerep#
#
treatment.indicator.vec = rep(xtrts_onerep,reps.per.cell);#
treatment.effects.vec = treatment.effect.size * treatment.indicator.vec;#
treatment.fac = factor(treatment.indicator.vec)#
# Create vectors to store the Monte Carlo results#
HG.pvals.for.treatment = rep(NA,mcruns)#
HG.effect.size.treatment = rep(NA,mcruns)#
HG.time3.effect.size = rep(NA,mcruns)#
#
reml.HH.pvals.for.treatment = rep(NA,mcruns)#
reml.HH.effect.size.treatment = rep(NA,mcruns)#
reml.HH.time3.effect.size = rep(NA,mcruns)#
#
polynomial.HH.pvals.for.treatment = rep(NA,mcruns)#
polynomial.HH.effect.size.treatment = rep(NA,mcruns)#
#
spline.HH.pvals.for.treatment = rep(NA,mcruns)#
spline.HH.effect.size.treatment = rep(NA,mcruns);#
#
cluster_specific_Polypvals = rep(NA,mcruns)#
cluster_specific_Splinepvals = rep(NA,mcruns)#
#
GLS.effect.sizes = rep(NA,mcruns);#
############################################
############################################
############  GLS calculations#
############################################
############################################
#
# For variable name cross-reference, see matlabProgram4SWTDesigns.m#
#
xtimesbase = diag(number_of_time_periods)#
#
xtimes = kronecker(xtimesbase,t(rep(1,number_of_clusters)))#
#
dim(xtimes)#
#
xtrts01 = rep(0,number_of_cells)#
#
# leftmost column#
xtrts01[1:number_of_clusters] = rep(0,number_of_clusters);#
# rightmost column#
xtrts01[((number_of_time_periods-1)*number_of_clusters+1):number_of_cells] = rep(1,number_of_clusters);#
for (j in 2:(number_of_time_periods-1)){#
  equation1 = ((j-1)*number_of_clusters_per_crossover);#
  equation2 = number_of_clusters - equation1;#
  thiscolumn_asrowvec = c(rep(1,equation1),rep(0,equation2));#
  xtrts01[(1+number_of_clusters*(j-1)):(number_of_clusters*j)] = thiscolumn_asrowvec;#
}#
xtrts01 #
xtrts = 2 * (xtrts01-0.5);#
xtrts = t(xtrts)#
#
x = cbind(t(xtimes),t(xtrts))#
#
dim(x)#
#
z = diag(number_of_clusters);#
z = kronecker(t(rep(1,number_of_time_periods)),z)#
#
G = tausq * diag(number_of_clusters);#
R = sigmasq * diag(number_of_cells);#
V = t(z) %*% G %*% z + R;#
# V #
Vinv = solve(V)#
#
inv_xtxwithV_inv = solve(t(x)%*%Vinv%*%x)#
#
mysol = inv_xtxwithV_inv %*% t(x) %*% Vinv;#
#
trtestimator = 2*mysol[(1+number_of_time_periods),]#
#
length(trtestimator)#
#
mytrtmat = matrix(trtestimator,ncol=number_of_time_periods)#
#
mytrtmat#
############################################
############################################
############  SIMULATION LOOP#
############################################
############################################
#
mystarttime = Sys.time();#
#
for (thisrep in 1:mcruns){#
#
  # Specify the interaction pattern for one rep#
  time_by_cluster_interactions_onerep = rep(0,number_of_cells);#
  rowpattern1 = c(0,0,0,0,0,0);#
  rowpattern2 = c(0,0,0,0,0,0);#
  patternlist = list(rowpattern1,rowpattern2)#
  theserows =  c(rep(1,number_of_clusters/2),rep(2,number_of_clusters/2))#
  # theserows =  c(rep(1,5),rep(2,5))#
  byrowinteractions = matrix(NA,ncol=number_of_time_periods,nrow=number_of_clusters,byrow=T);#
  for (i in 1:number_of_clusters) {#
    byrowinteractions[i,] = patternlist[[theserows[i]]]#
  }#
  time_by_cluster_interactions_onerep = c(byrowinteractions);#
  time_by_cluster_interactions_onerep#
  # Create the full vector of cluster-specific time effects#
  cluster_specific_time_effects = #
  rep(time_main_effecs_onerep+time_by_cluster_interactions_onerep,reps.per.cell)#
#
  GLS.effect.sizes[thisrep] = sum(trtestimator*time_by_cluster_interactions_onerep);#
  mynoise = rnorm(n=number.of.cells*reps.per.cell,sd=noise.sd)#
#
  # Add a random cluster main effect#
  cluster.main.effects = rnorm(n=number.of.rows,sd=cluster.sd);#
  cluster.numbers.vec = rep(1:number.of.rows,(number.of.columns*reps.per.cell))#
  cluster.effects.vec = cluster.main.effects[cluster.numbers.vec]#
#
  # Generate the response #
  myresp = myintercept + cluster.effects.vec + treatment.effects.vec + #
   cluster_specific_time_effects + mynoise;#
  # Now fit the Hooper-Girling and H/H model#
  HG.cluster.factor = factor(cluster.numbers.vec);#
  HG.treatment.ind = treatment.indicator.vec;#
  times.vec = rep(rep(1:number_of_time_periods,each=number_of_clusters),reps.per.cell);#
  HG.time.factor = factor(times.vec);#
  HG.time.numeric = times.vec;#
#
  mylmerHG = lmer(myresp ~ (1|HG.cluster.factor) + HG.treatment.ind +#
               HG.time.factor + (1|(HG.cluster.factor:HG.time.factor)),REML=1);#
  summary(mylmerHG)#
#
  HG.pvals.for.treatment[thisrep] = anova(mylmerHG)[1,6]#
  HG.effect.size.treatment[thisrep] = summary(mylmerHG)$coefficients[2,1];#
#
  mylmerHHreml  = lmer(myresp ~ (1|HG.cluster.factor) + HG.treatment.ind +#
         HG.time.factor,REML=1 );#
  summary(mylmerHHreml)#
#
  reml.HH.pvals.for.treatment[thisrep] = anova(mylmerHHreml)[1,6]#
  reml.HH.effect.size.treatment[thisrep] = summary(mylmerHHreml)$coefficients[2,1];#
#
  thisdeltaHH = summary(mylmerHHreml)$coefficients[2,1];#
  myPolynomialHH = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
    + HG.cluster.factor:poly(HG.time.numeric,3,raw=TRUE))#
#
  myPolynomialHH_maineff = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor)+ poly(HG.time.numeric,2,raw=TRUE),#
    REML=1)#
  summary(myPolynomialHH_maineff)#
#
  anova(myPolynomialHH,myPolynomialHH_maineff)#
  cluster_specific_Polypvals[thisrep] <-   anova(myPolynomialHH,myPolynomialHH_maineff)[2,8]#
  summary(mylmerHHreml)#
#
  polynomial.HH.pvals.for.treatment[thisrep] = anova(myPolynomialHH)[1,6]#
  polynomial.HH.effect.size.treatment[thisrep] = summary(myPolynomialHH)$coefficients[2,1];#
#
# TRY  SPLINE#
#
  # mysplineHH = lmer(myresp ~  HG.treatment.ind + #
  #   bs(HG.time.numeric1,df=2) + #
  #   bs(HG.time.numeric2,df=2) + #
  #   bs(HG.time.numeric3,df=2) + #
  #   bs(HG.time.numeric4,df=2) + #
  #   bs(HG.time.numeric5,df=2) + #
  #   bs(HG.time.numeric6,df=2) + #
  #   bs(HG.time.numeric7,df=2) + #
  #   bs(HG.time.numeric8,df=2) + #
  #   bs(HG.time.numeric9,df=2) + #
  #   bs(HG.time.numeric10,df=2) +#
  #   bs(HG.time.numeric11,df=2) +#
  #   bs(HG.time.numeric12,df=2) +#
  #   bs(HG.time.numeric13,df=2) +#
  #   bs(HG.time.numeric14,df=2) +#
  #   bs(HG.time.numeric15,df=2) +#
  #   bs(HG.time.numeric16,df=2) +#
  #   bs(HG.time.numeric17,df=2) +#
  #   bs(HG.time.numeric18,df=2) +#
  #   bs(HG.time.numeric19,df=2) +#
  #   bs(HG.time.numeric20,df=2)  , #
  #   REML=1)#
  mySplineHH = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
    + HG.cluster.factor:bs(HG.time.numeric,df=3),REML=1)#
#
  mySplineHH_maineff = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor)+ bs(HG.time.numeric,df=3),#
    REML=1)#
#
  summary(mySplineHH)#
  spline.HH.pvals.for.treatment[thisrep] = anova(mySplineHH)[1,6]#
  spline.HH.effect.size.treatment[thisrep] = summary(mySplineHH)$coefficients[2,1];#
#
  summary(mySplineHH_maineff)#
#
  anova(mySplineHH,mySplineHH_maineff)#
  cluster_specific_Splinepvals[thisrep] <-   anova(mySplineHH,mySplineHH_maineff)[2,8]#
}#
summary(myPolynomialHH)#
#
mean(residuals(myPolynomialHH)^2)#
#
myPolynomialHH1 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,1,raw=FALSE))#
myPolynomialHH2 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,2,raw=FALSE))#
myPolynomialHH3 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,3,raw=FALSE))#
myPolynomialHH4 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,4,raw=FALSE))#
myPolynomialHH5 = lmer(myresp ~ HG.treatment.ind + (1|HG.cluster.factor) #
     + HG.cluster.factor:poly(HG.time.numeric,5,raw=FALSE))#
anova(myPolynomialHH_maineff,myPolynomialHH1,myPolynomialHH2,myPolynomialHH3,myPolynomialHH4,myPolynomialHH5)
162/170
updateR()
1.26e-5/(5.06e-6)
2*pnorm(=2.49)
2*pnorm(-2.49)
1.22e-5/(5.6e-6)
2*pnorm(-2.18)
q()
(7/8)^(1/3)
1/2^2
1/2^3
.75^2
.5^(1/3)
8^3
10^3
help(power.t.test)
power.t.test(n=8,delta=1.5)
power.t.test(n=4,delta=1.5)
power.t.test(n=4,delta=2.4)
pwr.r.test
install.packages("pwr")
library(pwr)
pwr.r.test(n=32,r=0)
pwr.r.test(n=32,r=.48)
help(pwr.r.test)
help(power.t.test)
power.t.test(n=4,delta=2.4,type="paired")
power.t.test(n=8,delta=1.2,type="paired")
18/45
27/45
7/11
8/153
83/145
3*11/(7*5)
3*5/(7*2)
(3*5)/(7*2)
14/15
(.2/.04)^2
i.	(180+67)/(180+100+67+193)
(180+67)/(180+100+67+193)
(260+10)/(260+263+10+13)
3.3-1.3
120-47
(42.1-39.7)/sqrt(200.7*(1/300+1/300))
(42.1-39.7)/(200.7*sqrt(1/300+1/300)))
(42.1-39.7)/(200.7*sqrt(1/300+1/300))
(42.1-39.7)/200.7
(42.1-39.7)/sqrt(200.7)
(42.1-39.7)/(200.7*sqrt(1/600))
(42.1-39.7)/(sqrt(200.7)*sqrt(1/600))
44.8=36.1
44.8-36.1
180/(180+100)
260/260+263
260/(260+263)
= (10)/(10+13)
(10)/(10+13)
67/(67+93)
67/(67+193)
.43-.26
(1.96+1.28)^2
.9*.25*(log(1.3))^2
10.4976/0.01548788
678/2
help(chisq.test)
mymat = matrix(c(663,182,43,51,467,86,38,30),nrow=2,byrow=T)
mymar
mymat
chisq.test(mymat)
chisq.test(mymat,correct=FALSE)
chisq.test(mymat,correct=TRUE)
chisq.test(mymat)
mymat2 = matrix(c(14785,1654,684,310,7332,880,332,178),nrow=2,byrow=T)
mymat2
mymat2 = matrix(c(7332,880,332,178,7453,774,352,132),nrow=2,byrow=T)
table mymat2
mymat2
chisq.test(mymat2)
chisq.test(mymat2,correct=FALSE)
chisq.test(mymat2,correct=TRUE)
mytabAnyfall = matrix(c(14785,1654,684,310,7332,880,332,178),byrow=T,ncol=4)#
#
mytab1fall = matrix(c(7453,880,332,178,7399,530,255,72),byrow=T,ncol=4)#
mytab2to5fall = matrix(c(3104,457,184,91,3152,399,164,66),byrow=T,ncol=4)#
mytab6plusfall = matrix(c(663,182,43,51,467,86,38,30),byrow=T,ncol=4)#
#
mytabinjuryfall = matrix(c(2825,526,151,120,2512,368,133,66),byrow=T,ncol=4)#
mytabAnyfall #
mytab1fall #
mytab2to5fall #
mytab6plusfall #
mytabinjuryfall
mytabAnyfall = matrix(c(7332,880,332,178,7453,774,352,132),byrow=T,ncol=4)#
#
mytab1fall = matrix(c(3565,241,105,36,3834,289,150,36),byrow=T,ncol=4)#
mytab2to5fall = matrix(c(3104,457,184,91,3152,399,164,66),byrow=T,ncol=4)#
mytab6plusfall = matrix(c(663,182,43,51,467,86,38,30),byrow=T,ncol=4)#
#
mytabinjuryfall = matrix(c(2825,526,151,120,2512,368,133,66),byrow=T,ncol=4)#
mytabAnyfall #
mytab1fall #
mytab2to5fall #
mytab6plusfall #
mytabinjuryfall
chisq.test(mytabAnyfall) #
chisq.test(mytab1fall) #
chisq.test(mytab2to5fall) #
chisq.test(mytab6plusfall) #
chisq.test(mytabinjuryfall)
help(chisq.test)
chisq.test(matrix(c(14785,1654,684,310),ncol=2))
chisq.test(matrix(c(7399,530,255,72),ncol=2))
chisq.test(matrix(c(7399,530,255,72),ncol=2),correct=FALSE)
17433/65046
mytab2try = matrix(c(14785,1654,684,310,58858-14785,3868-1654,1761-684,559-310),ncol=4,byrow=T)#
#
mytab2try #
#
chisq.test(mytab2try)
mytab3try = matrix(c(7399,530,255,72,58858-7399,3868-530,1761-255,559-72),ncol=4,byrow=T)#
#
mytab3try #
#
chisq.test(mytab3try)
39/65
44/80
3/5
7/11
11/13
89/99
77/94
0.5 * sqrt(3.9^2+2.7^2)
(3.4-5.1)/2.4
sqrt(0.5*(3.9^2+2.7^2))
(3.4-5.1)/3.35
sqrt(0.5*(1.7+0.6))
(1.1067-.1565)/1.072381
sqrt(0.5*(4.3+4.2))
sqrt(0.5*(1.7^2+0.6^2))
(1.1067-.1565)/1.27
(3.65-3.91)/4.24
(.76-.87)/1.35
mytabAnyfall = matrix(c(7332,880,332,178,7453,774,352,132),byrow=T,ncol=4)#
#
mytab1fall = matrix(c(3565,241,105,36,3834,289,150,36),byrow=T,ncol=4)#
mytab2to5fall = matrix(c(3104,457,184,91,3152,399,164,66),byrow=T,ncol=4)#
mytab6plusfall = matrix(c(663,182,43,51,467,86,38,30),byrow=T,ncol=4)#
#
mytabinjuryfall = matrix(c(2825,526,151,120,2512,368,133,66),byrow=T,ncol=4)#
#
mytabAnyfall #
mytab1fall #
mytab2to5fall #
mytab6plusfall #
mytabinjuryfall #
#
chisq.test(mytabAnyfall) #
chisq.test(mytab1fall) #
chisq.test(mytab2to5fall) #
chisq.test(mytab6plusfall) #
chisq.test(mytabinjuryfall)
69000/15
help(power.t.test)
power.t.test(delta=0.6)
power.t.test(delta=0.6,power=0.98)
sqrt( (((11-1)*3.93585)+((5-1)*2.70185))/(11+5-2) )
sqrt( (((11-1)*3.93585^2)+((5-1)*2.70185^2))/(11+5-2) )
2/3.63
help(power.t.test)
power.t.test(n=188,delta=.60)
power.t.test(n=188,delta=.55)
power.t.test(n=160,delta=.55)
power.t.test(n=120,delta=.55)
power.t.test(n=100,delta=.55)
power.t.test(n=94,delta=.60)
power.t.test(n=94,delta=.55)
1.7/3.63
power.t.test(n=94,delta=.47)
sqrt( (3.93585^2+2.70185^2)/(2) )
sqrt( (((11-1)*1.73906^2+(5-1)*.64313^2))/(11+5-2)  )
.5/1/51
.5/1.51
power.t.test(n=94,delta=.33)
mean(c(1.73906,0.64313))
sqrt(mean(c(1.73906^2,0.64313^2))
)
sqrt(mean(c(1.73906^2,0.64313^2)))
sqrt(mean(c(3.93585^2,2.70185^2)))
.5/1.31
power.t.test(n=94,delta=.38)
actsd = sqrt(mean(c(3.93585^2,2.70185^2)))#
#
junipersd = sqrt(mean(c(1.73906^2,0.64313^2)))#
#
actsd#
#
junipersd
.5/1.3
2/3.4
power.t.test(n=94,delta=.59)
power.t.test(n=94,delta=.38)
help(power.prop.test)
power.prop.test(n=94,p1=.59,p2=.46)
power.prop.test(n=94,p1=.78,p2=.61)
power.prop.test(n=94,p1=.78,p2=.60)
asthmamedsSD = sqrt(mean(c(1.79^2,1.43^2)))#
asthmamedsSD
power.t.test(n=94,delta=2/1.72)
power.t.test(n=94,delta=.5/1.72)
power.t.test(n=94,delta=.6/1.72)
power.t.test(n=94,delta=.7/1.72)
power.t.test(n=94,delta=.8/1.72)
power.t.test(power=.8,delta=.38)
version
.7/1.72
power.t.test(n=110,delta=0.38)#
power.t.test(n=110,delta=0.59)#
power.t.test(n=110,delta=0.41)
220/.8
188/.2
188/.8
276/2
236/5
276/5
276/2
55*5
help(power.prop.test)
power.prop.test(n=110,p1=0.2,p2=0.4)
prop.t.test(110,p1=0.402,p2=0.202)
power.prop.test(110,p1=0.402,p2=0.202)
power.prop.test(110,p1=0.16.3,p2=0.023)
power.prop.test(110,p1=0.163,p2=0.023)
power.prop.test(110,p1=0.054,p2=0.012)
# Reasoning, there should be half in each group for the #
# randomized trial#
#
actsd = sqrt(mean(c(3.93585^2,2.70185^2)))#
#
junipersd = sqrt(mean(c(1.73906^2,0.64313^2)))#
#
actsd#
#
junipersd #
asthmamedsSD = sqrt(mean(c(1.79^2,1.43^2)))#
asthmamedsSD#
power.t.test(n=110,delta=0.38)#
power.t.test(n=110,delta=0.59)#
power.t.test(n=110,delta=0.41)#
#
power.prop.test(110,p1=0.402,p2=0.202)#
power.prop.test(110,p1=0.163,p2=0.023)#
power.prop.test(110,p1=0.054,p2=0.012)
power.prop.test(110,p1=.772,p2=.698)#
power.prop.test(110,p1=.783,p2=.605)#
power.prop.test(110,p1=.592,p2=.459)#
power.prop.test(110,p1=.223,p2=.128)
meaned_intervention = mean(c(.772,.783,.592,.223))#
meaned_control = mean(c(.698,.605,.459,.128))#
power.prop.test(110,p1=meaned_intervention,p2=meaned_control)
power.t.test(delta=0.38,power=.9)
power.t.test(delta=0.38,power=.85)
power.prop.test(147,p1=.772,p2=.698)#
power.prop.test(147,p1=.783,p2=.605)#
power.prop.test(147,p1=.592,p2=.459)#
power.prop.test(147,p1=.223,p2=.128)
# Reasoning, there should be half in each group for the #
# randomized trial#
#
actsd = sqrt(mean(c(3.93585^2,2.70185^2)))#
#
junipersd = sqrt(mean(c(1.73906^2,0.64313^2)))#
#
actsd#
#
junipersd #
asthmamedsSD = sqrt(mean(c(1.79^2,1.43^2)))#
asthmamedsSD#
power.t.test(n=110,delta=0.38)#
power.t.test(n=110,delta=0.59)#
power.t.test(n=110,delta=0.41)#
#
power.prop.test(110,p1=0.402,p2=0.202)#
power.prop.test(110,p1=0.163,p2=0.023)#
power.prop.test(110,p1=0.054,p2=0.012)#
#
power.prop.test(110,p1=.772,p2=.698)#
power.prop.test(110,p1=.783,p2=.605)#
power.prop.test(110,p1=.592,p2=.459)#
power.prop.test(110,p1=.223,p2=.128)#
#
# meaned_intervention = mean(c(.772,.783,.592,.223))#
# meaned_control = mean(c(.698,.605,.459,.128))#
# power.prop.test(110,p1=meaned_intervention,p2=meaned_control)#
#
power.prop.test(147,p1=.772,p2=.698)#
power.prop.test(147,p1=.783,p2=.605)#
power.prop.test(147,p1=.592,p2=.459)#
power.prop.test(147,p1=.223,p2=.128)
library(haven)#
mydata = read_sav("/Users/kdobbin/Desktop/git/SteppedWedge/PAPER/DatasetAngerEtAl/dataverse_files/UBT introduction_SWCRT_PPHcases.sav")#
dim(mydata)#
# This file has 2394 rows#
# That is exactly equal to the number of women with PPH, as reported in abstract#
#    where there are 1357 with pph in control and 1037 with pph in intervention.#
#
names(mydata)#
#
# this looks challenging#
# Let's try the weekly data#
#
# First remove the more complicated data for now #
rm(mydata)#
mydata2 = read_sav("/Users/kdobbin/Desktop/git/SteppedWedge/PAPER2/Dataset_AngerEtAl/dataverse_files/UBT introduction_SWCRT_weekly data.sav")#
dim(mydata2)#
# this file has 1174 rows#
# That is close to half the total number of women diagnosed with PPH #
names(mydata2)#
#
table(mydata2$Site)#
dim(table(mydata2$Site))#
# There are 20 sites here, but 18 hospitals (six per country) in the methods section of paper#
# Although one site has one observation, one has 5, and the rest 65 approximately -- so maybe?#
#
table(mydata2$country)#
# There are 3 numbered countries, which matches the abstract#
#
table(mydata2$country,mydata2$Site)#
# It looks like 6 hospitals per country if we ignore the ones with small numbers#
#
table(mydata2$study_step)#
# There are three study steps, with around 400 in each#
#
# The treatment variable is study_phase according to the data dictionary#
table(mydata2$study_phase)#
#
table(mydata2$study_phase,mydata2$study_step)#
# The rows are study phase, the columns study step#
# This indicates that all are on control in step 1, then half on control in step 2, then all on trt in step 2#
#
table(mydata2$study_step,mydata2$Site)#
# Here it indicates that there are about 22 observations(?) at each time-by-site combination#
# Here is the outcome variable:#
sum(mydata2$p_outcome_pdata)#
# It looks like I could do this using either the primary outcome (after adjusting data to remove effect)#
#  OR the secondary outcome (meaternal death due to PPH) without adjustment#
#
# First, make a dataset that correct the typographical errors#
#
table(mydata2$Site)#
#
mydata2$Site[which(mydata2$Site=="Ismailiya")] <- "Ismailia"#
#
mydata2$Site[which(mydata2$Site=="Roi Baudouin")] <- "Roi Baudoin"#
#
table(mydata2$Site)#
table(mydata2$study_step,mydata2$Site)#
# Here it indicates that there are about 22 observations(?) at each time-by-site combination#
#
table(mydata2$study_step,mydata2$country)#
# using countries as clusters provides 3 clusgters and larger sample sizes#
myresponse1 = mydata2$p_outcome_pdata#
mytimes = factor(mydata2$study_step)#
myclusters = factor(mydata2$Site)#
#
myglm = glm(myresponse1 ~ mytimes*myclusters,family="poisson")#
#
myglm#
#
summary(myglm)#
#
pchisq(myglm$deviance,df=myglm$df.residual,lower.tail=FALSE)#
anova(myglm)#
#
myresponse2 = mydata2$mdeath_pdata#
#
myglm2 = glm(myresponse2 ~ mytimes*myclusters,family="poisson")#
#
myglm2#
#
summary(myglm2)#
#
anova(myglm2)#
#
myresponse3 = mydata2$aa_bt_pdata#
myresponse3 = as.numeric(myresponse3)#
myglm3 = glm(myresponse3 ~ mytimes*myclusters,family="poisson")#
#
myglm3#
#
summary(myglm3)#
#
anova(myglm3)#
#
mycoefs = coef(myglm3)#
#
library(lme4)#
mytrt = mydata2$study_phase#
myglme1 = glmer(myresponse3 ~ mytimes + mytrt + (1|myclusters) ,family="poisson")#
myglme2 = glmer(myresponse3 ~ mytimes + mytrt + (1|myclusters) + (1|mytimes:myclusters),family="poisson")#
#
anova(myglme1,myglme2)#
myfun = function(x) mean(log(x+0.02))#
#
interaction.plot(#
	x.factor = mytimes,#
	trace.factor = myclusters,#
	response = myresponse3,#
	fun = myfun,#
	xlab="Time",#
	ylab="Log (Mean+0.02) Blood Transfusions",#
	trace.label = "Cluster")#
mean_table = matrix(rep(NA,18*3),ncol=3)#
my_cluster_names = levels(myclusters)#
for (i in 1:18) {#
	for (j in 1:3) {#
		theseindices = intersect(which(myclusters==my_cluster_names[i]),#
			                     which(mytimes==(j-1)));#
		mean_table[i,j] = mean(myresponse3[theseindices])#
	}#
}#
#
mean_table#
plot(rep(1:3,18),c(mean_table),type="n",xlab="Time",ylab="Mean Response")#
lines(1:3,mean_table[1,],type="b",lty=1,pch=2)#
lines(1:3,mean_table[2,],type="b",lty=1,pch=2)#
lines(1:3,mean_table[3,],type="b",lty=1,pch=2)#
lines(1:3,mean_table[4,],type="b",lty=1,pch=2)#
lines(1:3,mean_table[5,],type="b",lty=1,pch=2)#
lines(1:3,mean_table[6,],type="b",lty=1,pch=2)#
lines(1:3,mean_table[7,],type="b",lty=1,pch=2)#
lines(1:3,mean_table[8,],type="b",lty=1,pch=2)#
lines(1:3,mean_table[9,],type="b",lty=1,pch=2)#
lines(1:3,mean_table[10,],type="b",lty=1,pch=2)#
lines(1:3,mean_table[11,],type="b",lty=1,pch=2)#
lines(1:3,mean_table[12,],type="b",lty=1,pch=2)#
lines(1:3,mean_table[13,],type="b",lty=1,pch=2)#
lines(1:3,mean_table[14,],type="b",lty=1,pch=2)#
lines(1:3,mean_table[15,],type="b",lty=1,pch=2)#
lines(1:3,mean_table[16,],type="b",lty=1,pch=2)#
lines(1:3,mean_table[17,],type="b",lty=1,pch=2)#
lines(1:3,mean_table[18,],type="b",lty=1,pch=2)#
#
mean_table2 = mean_table + 0.02#
log_mean_table2 = log(mean_table2)#
#
plot(rep(1:3,18),c(log_mean_table2),type="n",xlab="Time",ylab="Log Mean Response")#
lines(1:3,log_mean_table2[1,],type="b",lty=1,pch=2)#
lines(1:3,log_mean_table2[2,],type="b",lty=1,pch=2)#
lines(1:3,log_mean_table2[3,],type="b",lty=1,pch=2)#
lines(1:3,log_mean_table2[4,],type="b",lty=1,pch=2)#
lines(1:3,log_mean_table2[5,],type="b",lty=1,pch=2)#
lines(1:3,log_mean_table2[6,],type="b",lty=1,pch=2)#
lines(1:3,log_mean_table2[7,],type="b",lty=1,pch=2)#
lines(1:3,log_mean_table2[8,],type="b",lty=1,pch=2)#
lines(1:3,log_mean_table2[9,],type="b",lty=1,pch=2)#
lines(1:3,log_mean_table2[10,],type="b",lty=1,pch=2)#
lines(1:3,log_mean_table2[11,],type="b",lty=1,pch=2)#
lines(1:3,log_mean_table2[12,],type="b",lty=1,pch=2)#
lines(1:3,log_mean_table2[13,],type="b",lty=1,pch=2)#
lines(1:3,log_mean_table2[14,],type="b",lty=1,pch=2)#
lines(1:3,log_mean_table2[15,],type="b",lty=1,pch=2)#
lines(1:3,log_mean_table2[16,],type="b",lty=1,pch=2)#
lines(1:3,log_mean_table2[17,],type="b",lty=1,pch=2)#
lines(1:3,log_mean_table2[18,],type="b",lty=1,pch=2)#
# Try the spline regression method#
#
HG.time.numeric = as.numeric(mytimes);#
HG.time.numeric1 = HG.time.numeric*(myclusters==my_cluster_names[1])#
HG.time.numeric2 = HG.time.numeric*(myclusters==my_cluster_names[2])#
HG.time.numeric3 = HG.time.numeric*(myclusters==my_cluster_names[3])#
HG.time.numeric4 = HG.time.numeric*(myclusters==my_cluster_names[4])#
HG.time.numeric5 = HG.time.numeric*(myclusters==my_cluster_names[5])#
HG.time.numeric6 = HG.time.numeric*(myclusters==my_cluster_names[6])#
HG.time.numeric7 = HG.time.numeric*(myclusters==my_cluster_names[7])#
HG.time.numeric8 = HG.time.numeric*(myclusters==my_cluster_names[8])#
HG.time.numeric9 = HG.time.numeric*(myclusters==my_cluster_names[9])#
HG.time.numeric10 = HG.time.numeric*(myclusters==my_cluster_names[10])#
HG.time.numeric11 = HG.time.numeric*(myclusters==my_cluster_names[11])#
HG.time.numeric12 = HG.time.numeric*(myclusters==my_cluster_names[12])#
HG.time.numeric13 = HG.time.numeric*(myclusters==my_cluster_names[13])#
HG.time.numeric14 = HG.time.numeric*(myclusters==my_cluster_names[14])#
HG.time.numeric15 = HG.time.numeric*(myclusters==my_cluster_names[15])#
HG.time.numeric16 = HG.time.numeric*(myclusters==my_cluster_names[16])#
HG.time.numeric17 = HG.time.numeric*(myclusters==my_cluster_names[17])#
HG.time.numeric18 = HG.time.numeric*(myclusters==my_cluster_names[18])#
  mysplineHH = lmer(myresponse3 ~ (1|myclusters) + mytrt + #
    poly(HG.time.numeric1,2,raw=TRUE) + #
    poly(HG.time.numeric2,2,raw=TRUE) + #
    poly(HG.time.numeric3,2,raw=TRUE) + #
    poly(HG.time.numeric4,2,raw=TRUE) + #
    poly(HG.time.numeric5,2,raw=TRUE) + #
    poly(HG.time.numeric6,2,raw=TRUE) + #
    poly(HG.time.numeric7,2,raw=TRUE) + #
    poly(HG.time.numeric8,2,raw=TRUE) + #
    poly(HG.time.numeric9,2,raw=TRUE) + #
    poly(HG.time.numeric10,2,raw=TRUE) +#
    poly(HG.time.numeric11,2,raw=TRUE) +#
    poly(HG.time.numeric12,2,raw=TRUE) +#
    poly(HG.time.numeric13,2,raw=TRUE) +#
    poly(HG.time.numeric14,2,raw=TRUE) +#
    poly(HG.time.numeric15,2,raw=TRUE) +#
    poly(HG.time.numeric16,2,raw=TRUE) +#
    poly(HG.time.numeric17,2,raw=TRUE) +#
    poly(HG.time.numeric18,2,raw=TRUE)  , #
    REML=1)#
  summary(mysplineHH)#
  anova(mysplineHH)#
summary(mysplineHH);#
  mySplineHH_maineff = lmer(myresponse3 ~ (1|myclusters) + mytrt + #
    poly(HG.time.numeric,2,raw=TRUE),#
    REML=1)#
  summary(mySplineHH_maineff)#
#
  anova(mysplineHH,mySplineHH_maineff)#
# from the smarthealth file#
#
  mysplineHHcubic = lmer(myresponse3 ~ (1|myclusters) + mytrt + #
    poly(HG.time.numeric,3) +#
    myclusters:poly(HG.time.numeric,3),    REML=1)#
  summary(mysplineHHcubic)#
  anova(mysplineHHcubic)#
summary(mysplineHHcubic);#
#
  mysplineHHquadratic = lmer(myresponse3 ~ (1|myclusters) + mytrt + #
    poly(HG.time.numeric,2) +#
    myclusters:poly(HG.time.numeric,2),    REML=1)#
  summary(mysplineHHquadratic)#
  anova(mysplineHHquadratic)#
summary(mysplineHHquadratic);#
  mysplineHHlinear = lmer(myresponse3 ~ (1|myclusters) + mytrt + #
    poly(HG.time.numeric,1) +#
    myclusters:poly(HG.time.numeric,1),    REML=1)#
  summary(mysplineHHlinear)#
  anova(mysplineHHlinear)#
summary(mysplineHHlinear);#
#
  mysplineHHquartic = lmer(myresponse3 ~ (1|myclusters) + mytrt + #
    poly(HG.time.numeric,4) +#
    myclusters:poly(HG.time.numeric,4),    REML=1)#
  summary(mysplineHHquartic)#
  anova(mysplineHHquartic)#
summary(mysplineHHquartic);#
anova(mysplineHHlinear,mysplineHHquadratic,mysplineHHcubic)
library(haven)#
# mydata = read_sav("/Users/kdobbin/Desktop/git/SteppedWedge/PAPER/DatasetAngerEtAl/dataverse_files/UBT introduction_SWCRT_PPHcases.sav")#
mydata = read_sav("/Users/kdobbin/Desktop/git/SteppedWedge/PAPER/DatasetAngerEtAl/dataverse_files/UBT introduction_SWCRT_PPHcases.sav")#
#
dim(mydata)#
# This file has 2394 rows#
# That is exactly equal to the number of women with PPH, as reported in abstract#
#    where there are 1357 with pph in control and 1037 with pph in intervention.#
#
names(mydata)#
#
# this looks challenging#
# Let's try the weekly data#
#
# First remove the more complicated data for now #
rm(mydata)#
# mydata2 = read_sav("/Users/kdobbin/Desktop/git/SteppedWedge/PAPER/Dataset_AngerEtAl/dataverse_files/UBT introduction_SWCRT_weekly data.sav")#
mydata2 = read_sav("/Users/kdobbin/Desktop/git/SteppedWedge/PAPER/DatasetAngerEtAl/dataverse_files/UBT introduction_SWCRT_weekly data.sav")#
dim(mydata2)#
# this file has 1174 rows#
# That is close to half the total number of women diagnosed with PPH
names(mydata2)#
#
table(mydata2$Site)#
dim(table(mydata2$Site))#
# There are 20 sites here, but 18 hospitals (six per country) in the methods section of paper#
# Although one site has one observation, one has 5, and the rest 65 approximately -- so maybe?#
#
table(mydata2$country)#
# There are 3 numbered countries, which matches the abstract#
#
table(mydata2$country,mydata2$Site)#
# It looks like 6 hospitals per country if we ignore the ones with small numbers#
#
table(mydata2$study_step)#
# There are three study steps, with around 400 in each#
#
# The treatment variable is study_phase according to the data dictionary#
table(mydata2$study_phase)#
#
table(mydata2$study_phase,mydata2$study_step)#
# The rows are study phase, the columns study step#
# This indicates that all are on control in step 1, then half on control in step 2, then all on trt in step 2#
#
table(mydata2$study_step,mydata2$Site)#
# Here it indicates that there are about 22 observations(?) at each time-by-site combination#
# Here is the outcome variable:#
sum(mydata2$p_outcome_pdata)#
# It looks like I could do this using either the primary outcome (after adjusting data to remove effect)#
#  OR the secondary outcome (meaternal death due to PPH) without adjustment#
#
# First, make a dataset that correct the typographical errors#
#
table(mydata2$Site)#
#
mydata2$Site[which(mydata2$Site=="Ismailiya")] <- "Ismailia"#
#
mydata2$Site[which(mydata2$Site=="Roi Baudouin")] <- "Roi Baudoin"#
#
table(mydata2$Site)#
table(mydata2$study_step,mydata2$Site)#
# Here it indicates that there are about 22 observations(?) at each time-by-site combination#
#
table(mydata2$study_step,mydata2$country)#
# using countries as clusters provides 3 clusgters and larger sample sizes#
myresponse1 = mydata2$p_outcome_pdata#
mytimes = factor(mydata2$study_step)#
myclusters = factor(mydata2$Site)#
#
myglm = glm(myresponse1 ~ mytimes*myclusters,family="poisson")#
#
myglm#
#
summary(myglm)#
#
pchisq(myglm$deviance,df=myglm$df.residual,lower.tail=FALSE)#
anova(myglm)#
#
myresponse2 = mydata2$mdeath_pdata#
#
myglm2 = glm(myresponse2 ~ mytimes*myclusters,family="poisson")#
#
myglm2#
#
summary(myglm2)#
#
anova(myglm2)#
#
myresponse3 = mydata2$aa_bt_pdata#
myresponse3 = as.numeric(myresponse3)#
myglm3 = glm(myresponse3 ~ mytimes*myclusters,family="poisson")#
#
myglm3#
#
summary(myglm3)#
#
anova(myglm3)#
#
mycoefs = coef(myglm3)#
#
library(lme4)#
mytrt = mydata2$study_phase#
myglme1 = glmer(myresponse3 ~ mytimes + mytrt + (1|myclusters) ,family="poisson")#
myglme2 = glmer(myresponse3 ~ mytimes + mytrt + (1|myclusters) + (1|mytimes:myclusters),family="poisson")#
#
anova(myglme1,myglme2)#
myfun = function(x) mean(log(x+0.02))#
#
interaction.plot(#
	x.factor = mytimes,#
	trace.factor = myclusters,#
	response = myresponse3,#
	fun = myfun,#
	xlab="Time",#
	ylab="Log (Mean+0.02) Blood Transfusions",#
	trace.label = "Cluster")#
mean_table = matrix(rep(NA,18*3),ncol=3)#
my_cluster_names = levels(myclusters)#
for (i in 1:18) {#
	for (j in 1:3) {#
		theseindices = intersect(which(myclusters==my_cluster_names[i]),#
			                     which(mytimes==(j-1)));#
		mean_table[i,j] = mean(myresponse3[theseindices])#
	}#
}#
#
mean_table#
plot(rep(1:3,18),c(mean_table),type="n",xlab="Time",ylab="Mean Response")#
lines(1:3,mean_table[1,],type="b",lty=1,pch=2)#
lines(1:3,mean_table[2,],type="b",lty=1,pch=2)#
lines(1:3,mean_table[3,],type="b",lty=1,pch=2)#
lines(1:3,mean_table[4,],type="b",lty=1,pch=2)#
lines(1:3,mean_table[5,],type="b",lty=1,pch=2)#
lines(1:3,mean_table[6,],type="b",lty=1,pch=2)#
lines(1:3,mean_table[7,],type="b",lty=1,pch=2)#
lines(1:3,mean_table[8,],type="b",lty=1,pch=2)#
lines(1:3,mean_table[9,],type="b",lty=1,pch=2)#
lines(1:3,mean_table[10,],type="b",lty=1,pch=2)#
lines(1:3,mean_table[11,],type="b",lty=1,pch=2)#
lines(1:3,mean_table[12,],type="b",lty=1,pch=2)#
lines(1:3,mean_table[13,],type="b",lty=1,pch=2)#
lines(1:3,mean_table[14,],type="b",lty=1,pch=2)#
lines(1:3,mean_table[15,],type="b",lty=1,pch=2)#
lines(1:3,mean_table[16,],type="b",lty=1,pch=2)#
lines(1:3,mean_table[17,],type="b",lty=1,pch=2)#
lines(1:3,mean_table[18,],type="b",lty=1,pch=2)#
#
mean_table2 = mean_table + 0.02#
log_mean_table2 = log(mean_table2)#
#
plot(rep(1:3,18),c(log_mean_table2),type="n",xlab="Time",ylab="Log Mean Response")#
lines(1:3,log_mean_table2[1,],type="b",lty=1,pch=2)#
lines(1:3,log_mean_table2[2,],type="b",lty=1,pch=2)#
lines(1:3,log_mean_table2[3,],type="b",lty=1,pch=2)#
lines(1:3,log_mean_table2[4,],type="b",lty=1,pch=2)#
lines(1:3,log_mean_table2[5,],type="b",lty=1,pch=2)#
lines(1:3,log_mean_table2[6,],type="b",lty=1,pch=2)#
lines(1:3,log_mean_table2[7,],type="b",lty=1,pch=2)#
lines(1:3,log_mean_table2[8,],type="b",lty=1,pch=2)#
lines(1:3,log_mean_table2[9,],type="b",lty=1,pch=2)#
lines(1:3,log_mean_table2[10,],type="b",lty=1,pch=2)#
lines(1:3,log_mean_table2[11,],type="b",lty=1,pch=2)#
lines(1:3,log_mean_table2[12,],type="b",lty=1,pch=2)#
lines(1:3,log_mean_table2[13,],type="b",lty=1,pch=2)#
lines(1:3,log_mean_table2[14,],type="b",lty=1,pch=2)#
lines(1:3,log_mean_table2[15,],type="b",lty=1,pch=2)#
lines(1:3,log_mean_table2[16,],type="b",lty=1,pch=2)#
lines(1:3,log_mean_table2[17,],type="b",lty=1,pch=2)#
lines(1:3,log_mean_table2[18,],type="b",lty=1,pch=2)#
# Try the spline regression method#
#
HG.time.numeric = as.numeric(mytimes);#
HG.time.numeric1 = HG.time.numeric*(myclusters==my_cluster_names[1])#
HG.time.numeric2 = HG.time.numeric*(myclusters==my_cluster_names[2])#
HG.time.numeric3 = HG.time.numeric*(myclusters==my_cluster_names[3])#
HG.time.numeric4 = HG.time.numeric*(myclusters==my_cluster_names[4])#
HG.time.numeric5 = HG.time.numeric*(myclusters==my_cluster_names[5])#
HG.time.numeric6 = HG.time.numeric*(myclusters==my_cluster_names[6])#
HG.time.numeric7 = HG.time.numeric*(myclusters==my_cluster_names[7])#
HG.time.numeric8 = HG.time.numeric*(myclusters==my_cluster_names[8])#
HG.time.numeric9 = HG.time.numeric*(myclusters==my_cluster_names[9])#
HG.time.numeric10 = HG.time.numeric*(myclusters==my_cluster_names[10])#
HG.time.numeric11 = HG.time.numeric*(myclusters==my_cluster_names[11])#
HG.time.numeric12 = HG.time.numeric*(myclusters==my_cluster_names[12])#
HG.time.numeric13 = HG.time.numeric*(myclusters==my_cluster_names[13])#
HG.time.numeric14 = HG.time.numeric*(myclusters==my_cluster_names[14])#
HG.time.numeric15 = HG.time.numeric*(myclusters==my_cluster_names[15])#
HG.time.numeric16 = HG.time.numeric*(myclusters==my_cluster_names[16])#
HG.time.numeric17 = HG.time.numeric*(myclusters==my_cluster_names[17])#
HG.time.numeric18 = HG.time.numeric*(myclusters==my_cluster_names[18])#
  mysplineHH = lmer(myresponse3 ~ (1|myclusters) + mytrt + #
    poly(HG.time.numeric1,2,raw=TRUE) + #
    poly(HG.time.numeric2,2,raw=TRUE) + #
    poly(HG.time.numeric3,2,raw=TRUE) + #
    poly(HG.time.numeric4,2,raw=TRUE) + #
    poly(HG.time.numeric5,2,raw=TRUE) + #
    poly(HG.time.numeric6,2,raw=TRUE) + #
    poly(HG.time.numeric7,2,raw=TRUE) + #
    poly(HG.time.numeric8,2,raw=TRUE) + #
    poly(HG.time.numeric9,2,raw=TRUE) + #
    poly(HG.time.numeric10,2,raw=TRUE) +#
    poly(HG.time.numeric11,2,raw=TRUE) +#
    poly(HG.time.numeric12,2,raw=TRUE) +#
    poly(HG.time.numeric13,2,raw=TRUE) +#
    poly(HG.time.numeric14,2,raw=TRUE) +#
    poly(HG.time.numeric15,2,raw=TRUE) +#
    poly(HG.time.numeric16,2,raw=TRUE) +#
    poly(HG.time.numeric17,2,raw=TRUE) +#
    poly(HG.time.numeric18,2,raw=TRUE)  , #
    REML=1)#
  summary(mysplineHH)#
  anova(mysplineHH)#
summary(mysplineHH);#
  mySplineHH_maineff = lmer(myresponse3 ~ (1|myclusters) + mytrt + #
    poly(HG.time.numeric,2,raw=TRUE),#
    REML=1)#
  summary(mySplineHH_maineff)#
#
  anova(mysplineHH,mySplineHH_maineff)#
# from the smarthealth file#
#
  mysplineHHcubic = lmer(myresponse3 ~ (1|myclusters) + mytrt + #
    poly(HG.time.numeric,3) +#
    myclusters:poly(HG.time.numeric,3),    REML=1)#
  summary(mysplineHHcubic)#
  anova(mysplineHHcubic)#
summary(mysplineHHcubic);#
#
  mysplineHHquadratic = lmer(myresponse3 ~ (1|myclusters) + mytrt + #
    poly(HG.time.numeric,2) +#
    myclusters:poly(HG.time.numeric,2),    REML=1)#
  summary(mysplineHHquadratic)#
  anova(mysplineHHquadratic)#
summary(mysplineHHquadratic);#
  mysplineHHlinear = lmer(myresponse3 ~ (1|myclusters) + mytrt + #
    poly(HG.time.numeric,1) +#
    myclusters:poly(HG.time.numeric,1),    REML=1)#
  summary(mysplineHHlinear)#
  anova(mysplineHHlinear)#
summary(mysplineHHlinear);#
#
  mysplineHHquartic = lmer(myresponse3 ~ (1|myclusters) + mytrt + #
    poly(HG.time.numeric,4) +#
    myclusters:poly(HG.time.numeric,4),    REML=1)#
  summary(mysplineHHquartic)#
  anova(mysplineHHquartic)#
summary(mysplineHHquartic);#
anova(mysplineHHlinear,mysplineHHquadratic,mysplineHHcubic)
mysplineHHquadratic = lmer(myresponse3 ~ (1|myclusters) + mytrt + #
    poly(HG.time.numeric,2) +#
    myclusters:poly(HG.time.numeric,2),    REML=1)#
  summary(mysplineHHquadratic)#
  anova(mysplineHHquadratic)#
summary(mysplineHHquadratic);#
  mysplineHHlinear = lmer(myresponse3 ~ (1|myclusters) + mytrt + #
    poly(HG.time.numeric,1) +#
    myclusters:poly(HG.time.numeric,1),    REML=1)#
  summary(mysplineHHlinear)#
  anova(mysplineHHlinear)#
summary(mysplineHHlinear);#
anova(mysplineHHlinear,mysplineHHquadratic)
anova(mysplineHHlinear)
summary(mysplineHHlinear)
library(haven)#
#
library(lmerTest)#
#
# mydata = read_sav("/Users/kdobbin/Desktop/git/SteppedWedge/PAPER/DatasetAngerEtAl/dataverse_files/UBT introduction_SWCRT_PPHcases.sav")#
mydata = read_sav("/Users/kdobbin/Desktop/git/SteppedWedge/PAPER/DatasetAngerEtAl/dataverse_files/UBT introduction_SWCRT_PPHcases.sav")#
#
dim(mydata)#
# This file has 2394 rows#
# That is exactly equal to the number of women with PPH, as reported in abstract#
#    where there are 1357 with pph in control and 1037 with pph in intervention.#
#
names(mydata)#
#
# this looks challenging#
# Let's try the weekly data#
#
# First remove the more complicated data for now #
rm(mydata)#
# mydata2 = read_sav("/Users/kdobbin/Desktop/git/SteppedWedge/PAPER/Dataset_AngerEtAl/dataverse_files/UBT introduction_SWCRT_weekly data.sav")#
mydata2 = read_sav("/Users/kdobbin/Desktop/git/SteppedWedge/PAPER/DatasetAngerEtAl/dataverse_files/UBT introduction_SWCRT_weekly data.sav")#
dim(mydata2)#
# this file has 1174 rows#
# That is close to half the total number of women diagnosed with PPH #
names(mydata2)#
#
table(mydata2$Site)#
dim(table(mydata2$Site))#
# There are 20 sites here, but 18 hospitals (six per country) in the methods section of paper#
# Although one site has one observation, one has 5, and the rest 65 approximately -- so maybe?#
#
table(mydata2$country)#
# There are 3 numbered countries, which matches the abstract#
#
table(mydata2$country,mydata2$Site)#
# It looks like 6 hospitals per country if we ignore the ones with small numbers#
#
table(mydata2$study_step)#
# There are three study steps, with around 400 in each#
#
# The treatment variable is study_phase according to the data dictionary#
table(mydata2$study_phase)#
#
table(mydata2$study_phase,mydata2$study_step)#
# The rows are study phase, the columns study step#
# This indicates that all are on control in step 1, then half on control in step 2, then all on trt in step 2#
#
table(mydata2$study_step,mydata2$Site)#
# Here it indicates that there are about 22 observations(?) at each time-by-site combination#
# Here is the outcome variable:#
sum(mydata2$p_outcome_pdata)#
# It looks like I could do this using either the primary outcome (after adjusting data to remove effect)#
#  OR the secondary outcome (meaternal death due to PPH) without adjustment#
#
# First, make a dataset that correct the typographical errors#
#
table(mydata2$Site)#
#
mydata2$Site[which(mydata2$Site=="Ismailiya")] <- "Ismailia"#
#
mydata2$Site[which(mydata2$Site=="Roi Baudouin")] <- "Roi Baudoin"#
#
table(mydata2$Site)#
table(mydata2$study_step,mydata2$Site)#
# Here it indicates that there are about 22 observations(?) at each time-by-site combination#
#
table(mydata2$study_step,mydata2$country)#
# using countries as clusters provides 3 clusgters and larger sample sizes#
myresponse1 = mydata2$p_outcome_pdata#
mytimes = factor(mydata2$study_step)#
myclusters = factor(mydata2$Site)#
#
myglm = glm(myresponse1 ~ mytimes*myclusters,family="poisson")#
#
myglm#
#
summary(myglm)#
#
pchisq(myglm$deviance,df=myglm$df.residual,lower.tail=FALSE)#
anova(myglm)#
#
myresponse2 = mydata2$mdeath_pdata#
#
myglm2 = glm(myresponse2 ~ mytimes*myclusters,family="poisson")#
#
myglm2#
#
summary(myglm2)#
#
anova(myglm2)#
#
myresponse3 = mydata2$aa_bt_pdata#
myresponse3 = as.numeric(myresponse3)#
myglm3 = glm(myresponse3 ~ mytimes*myclusters,family="poisson")#
#
myglm3#
#
summary(myglm3)#
#
anova(myglm3)#
#
mycoefs = coef(myglm3)#
#
library(lme4)#
mytrt = mydata2$study_phase#
myglme1 = glmer(myresponse3 ~ mytimes + mytrt + (1|myclusters) ,family="poisson")#
myglme2 = glmer(myresponse3 ~ mytimes + mytrt + (1|myclusters) + (1|mytimes:myclusters),family="poisson")#
#
anova(myglme1,myglme2)#
myfun = function(x) mean(log(x+0.02))#
#
interaction.plot(#
	x.factor = mytimes,#
	trace.factor = myclusters,#
	response = myresponse3,#
	fun = myfun,#
	xlab="Time",#
	ylab="Log (Mean+0.02) Blood Transfusions",#
	trace.label = "Cluster")#
mean_table = matrix(rep(NA,18*3),ncol=3)#
my_cluster_names = levels(myclusters)#
for (i in 1:18) {#
	for (j in 1:3) {#
		theseindices = intersect(which(myclusters==my_cluster_names[i]),#
			                     which(mytimes==(j-1)));#
		mean_table[i,j] = mean(myresponse3[theseindices])#
	}#
}#
#
mean_table#
plot(rep(1:3,18),c(mean_table),type="n",xlab="Time",ylab="Mean Response")#
lines(1:3,mean_table[1,],type="b",lty=1,pch=2)#
lines(1:3,mean_table[2,],type="b",lty=1,pch=2)#
lines(1:3,mean_table[3,],type="b",lty=1,pch=2)#
lines(1:3,mean_table[4,],type="b",lty=1,pch=2)#
lines(1:3,mean_table[5,],type="b",lty=1,pch=2)#
lines(1:3,mean_table[6,],type="b",lty=1,pch=2)#
lines(1:3,mean_table[7,],type="b",lty=1,pch=2)#
lines(1:3,mean_table[8,],type="b",lty=1,pch=2)#
lines(1:3,mean_table[9,],type="b",lty=1,pch=2)#
lines(1:3,mean_table[10,],type="b",lty=1,pch=2)#
lines(1:3,mean_table[11,],type="b",lty=1,pch=2)#
lines(1:3,mean_table[12,],type="b",lty=1,pch=2)#
lines(1:3,mean_table[13,],type="b",lty=1,pch=2)#
lines(1:3,mean_table[14,],type="b",lty=1,pch=2)#
lines(1:3,mean_table[15,],type="b",lty=1,pch=2)#
lines(1:3,mean_table[16,],type="b",lty=1,pch=2)#
lines(1:3,mean_table[17,],type="b",lty=1,pch=2)#
lines(1:3,mean_table[18,],type="b",lty=1,pch=2)#
#
mean_table2 = mean_table + 0.02#
log_mean_table2 = log(mean_table2)#
#
plot(rep(1:3,18),c(log_mean_table2),type="n",xlab="Time",ylab="Log Mean Response")#
lines(1:3,log_mean_table2[1,],type="b",lty=1,pch=2)#
lines(1:3,log_mean_table2[2,],type="b",lty=1,pch=2)#
lines(1:3,log_mean_table2[3,],type="b",lty=1,pch=2)#
lines(1:3,log_mean_table2[4,],type="b",lty=1,pch=2)#
lines(1:3,log_mean_table2[5,],type="b",lty=1,pch=2)#
lines(1:3,log_mean_table2[6,],type="b",lty=1,pch=2)#
lines(1:3,log_mean_table2[7,],type="b",lty=1,pch=2)#
lines(1:3,log_mean_table2[8,],type="b",lty=1,pch=2)#
lines(1:3,log_mean_table2[9,],type="b",lty=1,pch=2)#
lines(1:3,log_mean_table2[10,],type="b",lty=1,pch=2)#
lines(1:3,log_mean_table2[11,],type="b",lty=1,pch=2)#
lines(1:3,log_mean_table2[12,],type="b",lty=1,pch=2)#
lines(1:3,log_mean_table2[13,],type="b",lty=1,pch=2)#
lines(1:3,log_mean_table2[14,],type="b",lty=1,pch=2)#
lines(1:3,log_mean_table2[15,],type="b",lty=1,pch=2)#
lines(1:3,log_mean_table2[16,],type="b",lty=1,pch=2)#
lines(1:3,log_mean_table2[17,],type="b",lty=1,pch=2)#
lines(1:3,log_mean_table2[18,],type="b",lty=1,pch=2)#
# Try the spline regression method#
#
HG.time.numeric = as.numeric(mytimes);#
HG.time.numeric1 = HG.time.numeric*(myclusters==my_cluster_names[1])#
HG.time.numeric2 = HG.time.numeric*(myclusters==my_cluster_names[2])#
HG.time.numeric3 = HG.time.numeric*(myclusters==my_cluster_names[3])#
HG.time.numeric4 = HG.time.numeric*(myclusters==my_cluster_names[4])#
HG.time.numeric5 = HG.time.numeric*(myclusters==my_cluster_names[5])#
HG.time.numeric6 = HG.time.numeric*(myclusters==my_cluster_names[6])#
HG.time.numeric7 = HG.time.numeric*(myclusters==my_cluster_names[7])#
HG.time.numeric8 = HG.time.numeric*(myclusters==my_cluster_names[8])#
HG.time.numeric9 = HG.time.numeric*(myclusters==my_cluster_names[9])#
HG.time.numeric10 = HG.time.numeric*(myclusters==my_cluster_names[10])#
HG.time.numeric11 = HG.time.numeric*(myclusters==my_cluster_names[11])#
HG.time.numeric12 = HG.time.numeric*(myclusters==my_cluster_names[12])#
HG.time.numeric13 = HG.time.numeric*(myclusters==my_cluster_names[13])#
HG.time.numeric14 = HG.time.numeric*(myclusters==my_cluster_names[14])#
HG.time.numeric15 = HG.time.numeric*(myclusters==my_cluster_names[15])#
HG.time.numeric16 = HG.time.numeric*(myclusters==my_cluster_names[16])#
HG.time.numeric17 = HG.time.numeric*(myclusters==my_cluster_names[17])#
HG.time.numeric18 = HG.time.numeric*(myclusters==my_cluster_names[18])#
  mysplineHH = lmer(myresponse3 ~ (1|myclusters) + mytrt + #
    poly(HG.time.numeric1,2,raw=TRUE) + #
    poly(HG.time.numeric2,2,raw=TRUE) + #
    poly(HG.time.numeric3,2,raw=TRUE) + #
    poly(HG.time.numeric4,2,raw=TRUE) + #
    poly(HG.time.numeric5,2,raw=TRUE) + #
    poly(HG.time.numeric6,2,raw=TRUE) + #
    poly(HG.time.numeric7,2,raw=TRUE) + #
    poly(HG.time.numeric8,2,raw=TRUE) + #
    poly(HG.time.numeric9,2,raw=TRUE) + #
    poly(HG.time.numeric10,2,raw=TRUE) +#
    poly(HG.time.numeric11,2,raw=TRUE) +#
    poly(HG.time.numeric12,2,raw=TRUE) +#
    poly(HG.time.numeric13,2,raw=TRUE) +#
    poly(HG.time.numeric14,2,raw=TRUE) +#
    poly(HG.time.numeric15,2,raw=TRUE) +#
    poly(HG.time.numeric16,2,raw=TRUE) +#
    poly(HG.time.numeric17,2,raw=TRUE) +#
    poly(HG.time.numeric18,2,raw=TRUE)  , #
    REML=1)#
  summary(mysplineHH)#
  anova(mysplineHH)#
summary(mysplineHH);#
  mySplineHH_maineff = lmer(myresponse3 ~ (1|myclusters) + mytrt + #
    poly(HG.time.numeric,2,raw=TRUE),#
    REML=1)#
  summary(mySplineHH_maineff)#
#
  anova(mysplineHH,mySplineHH_maineff)#
# from the smarthealth file#
  mysplineHHquadratic = lmer(myresponse3 ~ (1|myclusters) + mytrt + #
    poly(HG.time.numeric,2) +#
    myclusters:poly(HG.time.numeric,2),    REML=1)#
  summary(mysplineHHquadratic)#
  anova(mysplineHHquadratic)#
summary(mysplineHHquadratic);#
  mysplineHHlinear = lmer(myresponse3 ~ (1|myclusters) + mytrt + #
    poly(HG.time.numeric,1) +#
    myclusters:poly(HG.time.numeric,1),    REML=1)#
  summary(mysplineHHlinear)#
  anova(mysplineHHlinear)#
summary(mysplineHHlinear);#
anova(mysplineHHlinear,mysplineHHquadratic)#
#
anova(mysplineHHlinear)
updateR()
UpdateR()
library(installr)
install.library(installr)
install.package(installr)
install.packages(installr)
install.packages('installr')
library(installr)
updateR()
exp(1.679+1.450+0.981)
log(1.679+1.450+0.981)
log(1.679)+log(1.450)+log(0.981)
log(2.228+1.897+0.878)
log(2.228*1.897*0.878)
log(2.228+1.897+0.878)
exp(log(2.228+1.897+0.878))
Log(2.228+1.897+0.878)
l
log(2.228+1.897+0.878)
exp(log(2.228+1.897+0.878))
exp(2.228+1.897+0.878)
exp(log(2.228)+log(1.897)+log(0.878))
exp(log(2.228*1.897*0.878))
exp(log(1.68*1.45*0.981))
exp(log(1.779*1.474*0.660))
exp(log(1.779*1.474*1.092))
exp(log(1.866*1.918*1.043))
exp(log(1.866*1.276*1.043))
exp(log(1.679*1.450*0.981))
exp(log(1.779*1.474*1.092))
exp(log(1.866*1.276*1.043))
Log(2.228+1.897+0.878)
log(2.228+1.897+0.878)
exp(log(2.228+1.897+0.878))
exp(log(1.679)+log(1.450)+log(0.981))
mylist1 = c(44,26,5,8)
mylist2 = c(50,94,2,1)
mylist1/sum(mylist1)
mylist2/sum(mylist2)
mylist1[1:3]/sum(mylist1[1:3])
mylist2[1:3]/sum(mylist2[1:3])
# setwd("Set this to the directory that contains the downloaded file")#
#
install.packages("doParallel")#
install.packages("TreatmentSelection")#
library(doParallel)#
library(TreatmentSelection)#
#
source(file="SS4TrtSelSurv.R")#
#
# Parameter settings#
normalmean = 0.5;#
normalsd = sqrt(1/12)#
#
#  Parameter for the number of MC runs for each estimation (fixed)#
# The k-values for input#
ExpPropOfDeaths = 1.00;#
NumberOfBootstraps = 200;#
mydesign = "stratified"#
k1 = 0.25; k2 = 0.75;#
k3 = 0.75; k4 = 0.25;#
t0=5;#
#
start1 = Sys.time()#
temp1 <- Calculate.sample.size(targetwidth=0.10,k1,k2,k3,k4,t0,#
                        mydesign=mydesign,ExpPropOfDeaths=ExpPropOfDeaths,#
                        NumberOfBootstraps=NumberOfBootstraps)#
end1 = Sys.time()#
#
print(temp1);#
#
plot(as.numeric(temp1[[3]]),as.numeric(temp1[[4]]),xlab="Sample Size", ylab="Inverse squared Width")
# setwd("Set this to the directory that contains the downloaded file")#
#
install.packages("doParallel")#
install.packages("TreatmentSelection")#
library(doParallel)#
library(TreatmentSelection)#
#
source(file="SS4TrtSelSurv.R")#
#
# Parameter settings#
normalmean = 0.5;#
normalsd = sqrt(1/12)#
#
#  Parameter for the number of MC runs for each estimation (fixed)#
# The k-values for input#
ExpPropOfDeaths = 1.00;#
NumberOfBootstraps = 200;#
mydesign = "stratified"#
k1 = 0.25; k2 = 0.75;#
k3 = 0.75; k4 = 0.25;#
t0=5;#
#
start1 = Sys.time()#
temp1 <- Calculate.sample.size(targetwidth=0.10,k1,k2,k3,k4,t0,#
                        mydesign=mydesign,ExpPropOfDeaths=ExpPropOfDeaths,#
                        NumberOfBootstraps=NumberOfBootstraps)#
end1 = Sys.time()#
#
print(temp1);#
#
plot(as.numeric(temp1[[3]]),as.numeric(temp1[[4]]),xlab="Sample Size", ylab="Inverse squared Width")
q()
