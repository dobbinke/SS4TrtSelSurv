NumberOfCM1
NumberOfTM1
NumberOfCM0
NumberOfTM0
length(mycMresp)
mytrt1ctrl0 = rbinom(myn,1,0.5);  # indicates randomization to trt/ctrl#
    myM1is1M0is0 = rbinom(myn,1,0.5); # the conditional probabilities of M1 and M0 are 0.5 for both trt and control#
#
    NumberOfCM1 = length(intersect(which(mytrt1ctrl0==0),which(myM1is1M0is0==1)))#
    NumberOfTM1 = length(intersect(which(mytrt1ctrl0==1),which(myM1is1M0is0==1)))#
    NumberOfCM0 = length(intersect(which(mytrt1ctrl0==0),which(myM1is1M0is0==0)))#
    NumberOfTM0 = length(intersect(which(mytrt1ctrl0==1),which(myM1is1M0is0==0)))#
#
    myxcM1s = generateCM1rnvs(NumberOfCM1)#
    myxtM1s = generateTM1rnvs(NumberOfTM1)#
    myxcM0s = generateCM0rnvs(NumberOfCM0)#
    myxtM0s = generateTM0rnvs(NumberOfTM0)#
#
	apply(myxcM1s,1,mean)#
	apply(myxtM1s,1,mean)#
	apply(myxcM0s,1,mean)#
	apply(myxtM0s,1,mean)#
	myxcs = cbind(myxcM0s,myxcM1s);#
	myxts = cbind(myxtM0s,myxtM1s);#
	myxmarginal = cbind(myxcs,myxts)#
#
	mycMresp = c(rep(0,NumberOfCM0),rep(1,NumberOfCM1)) #
	mytMresp = c(rep(0,NumberOfTM0),rep(1,NumberOfTM1))
length(mycMresp)
length(mytMresp)
install.packages("densratio")#
	library(densratio)#
	densratio_obj1 = densratio(t(cbind(myxcM1s,myxcM1s,myxcM1s,myxcM1s)),t(myxmarginal),method=thismethod)#
	densratio_obj3 = densratio(t(cbind(myxtM1s,myxtM1s,myxtM1s,myxtM1s)),t(myxmarginal),method=thismethod)#
#
	new_x = t(matrix(runif(2000),nrow=2));#
#
	w_hat1 = densratio_obj1$compute_density_ratio(new_x);#
	w_hat3 = densratio_obj3$compute_density_ratio(new_x);#
    # library(rgl)#
    # plot3d(new_x[,1],new_x[,2],w_hat1)#
	densratio_obj1#
#
	densratio_obj3#
	hat_pi_c = length(myxcM1s)/(length(myxcM1s)+length(myxcM0s))#
	hat_pi_t = length(myxtM1s)/(length(myxtM1s)+length(myxtM0s))#
#
	hat_pi_c#
	hat_pi_t#
	hat_gsubc = w_hat1 * hat_pi_c;#
	hat_gsubt = w_hat3 * hat_pi_t;#
	# ESTIMATE THETA0 AND THETA1 with DR approach#
#
	theta0vec = rep(NA,length(w_hat1));#
	theta1vec = rep(NA,length(w_hat1));#
#
	for (i in 1:length(w_hat1)) {#
		thismax = max(hat_gsubc[i],hat_gsubt[i]);#
		theta0vec[i] = thismax - hat_gsubc[i];#
		theta1vec[i] = thismax - hat_gsubt[i];#
	}#
#
	DRapproachTheta0 = mean(theta0vec)#
	seDRapproachTheta0 = sqrt(var(theta0vec)/length(theta0vec))#
#
	DRapproachTheta1 = mean(theta1vec)#
	seDRapproachTheta1 = sqrt(var(theta1vec)/length(theta1vec))#
#
	DRapproachTheta0#
	seDRapproachTheta0#
#
	DRapproachTheta1#
	seDRapproachTheta1
# ESTIMATE THETA0 AND THETA1 WITH LOGISTIC REGRESSION + JANES TREATMENTSELECTION PACKAGE#
#
	myx1cs = myxcs[1,];#
	myx2cs = myxcs[2,];#
	myx1ts = myxts[1,];#
	myx2ts = myxts[2,];#
	myx1All = c(myx1cs,myx1ts)#
	myx2All = c(myx2cs,myx2ts)#
	myresp = c(mycMresp,mytMresp)#
	mytrtAll = c(rep(0,length(mycMresp)),rep(1,length(mytMresp)));#
	mylogreg = glm(myresp ~ myx1All + myx2All + mytrtAll + #
		myx1All:mytrtAll + myx2All:mytrtAll)
mylogreg
mylogreg = glm(myresp ~ myx1All + myx2All + mytrtAll + #
		myx1All:mytrtAll + myx2All:mytrtAll, family=binomial(link='logit'))
mylogreg
# SIMULATE DATA FROM THE MODEL#
#
thismethod = "uLSIF"#
myn = 800;#
MCRUNS = 3;#
#
myregion = function(x1,x2) {#
	myreturn = -1;#
	if (x1+x2<1) { myreturn = 1; }#
	else { myreturn = 2; }#
}#
#
myalphasubcM1s = c(0.2,1.8)#
myalphasubcM0s = 2-myalphasubcM1s;#
#
myalphasubtM1s = c(1.8,0.2)#
myalphasubtM0s = 2-myalphasubtM1s;#
#
mybaseareas = c(0.5,0.5)#
#
mycM1probs = myalphasubcM1s*mybaseareas;#
mycM0probs = myalphasubcM0s*mybaseareas;#
mytM1probs = myalphasubtM1s*mybaseareas;#
mytM0probs = myalphasubtM0s*mybaseareas;#
#
sum(mycM1probs);#
sum(mycM0probs);#
sum(mytM1probs)#
sum(mytM0probs)#
#
mycM1probs;#
mycM0probs;#
mytM1probs#
mytM0probs#
#
mycM1grps = rmultinom(myn/4,1,mycM1probs)#
mycM0grps = rmultinom(myn/4,1,mycM0probs)#
mytM1grps = rmultinom(myn/4,1,mytM1probs)#
mytM0grps = rmultinom(myn/4,1,mytM0probs)#
#
sum(mycM1grps[1,])#
sum(mycM0grps[1,])#
sum(mytM1grps[1,])#
sum(mytM0grps[1,])#
#
myxcM1s = rep(NA,myn/4)#
myxtM1s = rep(NA,myn/4)#
myxcM0s = rep(NA,myn/4)#
myxtM0s = rep(NA,myn/4)#
#
DRtheta0s = rep(NA,MCRUNS)#
DRtheta1s = rep(NA,MCRUNS)#
HJtheta0s = rep(NA,MCRUNS)#
HJtheta1s = rep(NA,MCRUNS)#
mygeneratefromArea1 = function() {#
	xtry = c(runif(1),runif(1));#
	while (sum(xtry) > 1) { xtry = c(runif(1),runif(1))  }#
	return(xtry);#
}#
mygeneratefromArea2 = function() {#
	xtry = c(runif(1),runif(1));#
	while (sum(xtry) < 1) { xtry = c(runif(1),runif(1))  }#
	return(xtry);#
}#
# RETURN A 2 BY N MATRIX OF BIOMARKER VALUES#
generateCM1rnvs = function(numberneeded) {#
	myreturn = matrix(rep(NA, 2*numberneeded),nrow=2);#
#
	for (i in 1:numberneeded) {#
		myx = c(NA,NA);#
		thismultinom = rmultinom(1,1,mycM1probs);#
#
		if (as.vector(thismultinom)[1] == 1 ) { myx <- mygeneratefromArea1() }#
		if (as.vector(thismultinom)[2] == 1 ) { myx <- mygeneratefromArea2() }#
		myreturn[,i] = myx;#
	}#
	myreturn;#
}#
#
generateTM1rnvs = function(numberneeded) {#
	myreturn = matrix(rep(NA, 2*numberneeded),nrow=2);#
#
	for (i in 1:numberneeded) {#
		myx = c(NA,NA);#
		thismultinom = rmultinom(1,1,mytM1probs);#
#
		if (as.vector(thismultinom)[1] == 1 ) { myx <- mygeneratefromArea1() }#
		if (as.vector(thismultinom)[2] == 1 ) { myx <- mygeneratefromArea2() }#
		myreturn[,i] = myx;#
	}#
	myreturn;#
}#
#
generateCM0rnvs = function(numberneeded) {#
	myreturn = matrix(rep(NA, 2*numberneeded),nrow=2);#
#
	for (i in 1:numberneeded) {#
		myx = c(NA,NA);#
		thismultinom = rmultinom(1,1,mycM0probs);#
#
		if (as.vector(thismultinom)[1] == 1 ) { myx <- mygeneratefromArea1() }#
		if (as.vector(thismultinom)[2] == 1 ) { myx <- mygeneratefromArea2() }#
		myreturn[,i] = myx;#
	}#
	myreturn;#
}#
generateTM0rnvs = function(numberneeded) {#
	myreturn = matrix(rep(NA, 2*numberneeded),nrow=2);#
#
	for (i in 1:numberneeded) {#
		myx = c(NA,NA);#
		thismultinom = rmultinom(1,1,mytM0probs);#
#
		if (as.vector(thismultinom)[1] == 1 ) { myx <- mygeneratefromArea1() }#
		if (as.vector(thismultinom)[2] == 1 ) { myx <- mygeneratefromArea2() }#
		myreturn[,i] = myx;#
	}#
	myreturn;#
}
thismc=`1`
thismc=1
mytrt1ctrl0 = rbinom(myn,1,0.5);  # indicates randomization to trt/ctrl#
    myM1is1M0is0 = rbinom(myn,1,0.5); # the conditional probabilities of M1 and M0 are 0.5 for both trt and control#
#
    NumberOfCM1 = length(intersect(which(mytrt1ctrl0==0),which(myM1is1M0is0==1)))#
    NumberOfTM1 = length(intersect(which(mytrt1ctrl0==1),which(myM1is1M0is0==1)))#
    NumberOfCM0 = length(intersect(which(mytrt1ctrl0==0),which(myM1is1M0is0==0)))#
    NumberOfTM0 = length(intersect(which(mytrt1ctrl0==1),which(myM1is1M0is0==0)))#
#
    myxcM1s = generateCM1rnvs(NumberOfCM1)#
    myxtM1s = generateTM1rnvs(NumberOfTM1)#
    myxcM0s = generateCM0rnvs(NumberOfCM0)#
    myxtM0s = generateTM0rnvs(NumberOfTM0)#
#
	apply(myxcM1s,1,mean)#
	apply(myxtM1s,1,mean)#
	apply(myxcM0s,1,mean)#
	apply(myxtM0s,1,mean)#
	myxcs = cbind(myxcM0s,myxcM1s);#
	myxts = cbind(myxtM0s,myxtM1s);#
	myxmarginal = cbind(myxcs,myxts)#
#
	mycMresp = c(rep(0,NumberOfCM0),rep(1,NumberOfCM1)) #
	mytMresp = c(rep(0,NumberOfTM0),rep(1,NumberOfTM1)) #
	# DENSITY RATIO ESTIMATION#
#
	install.packages("densratio")#
	library(densratio)#
	densratio_obj1 = densratio(t(cbind(myxcM1s,myxcM1s,myxcM1s,myxcM1s)),t(myxmarginal),method=thismethod)#
	densratio_obj3 = densratio(t(cbind(myxtM1s,myxtM1s,myxtM1s,myxtM1s)),t(myxmarginal),method=thismethod)#
#
	new_x = t(matrix(runif(2000),nrow=2));#
#
	w_hat1 = densratio_obj1$compute_density_ratio(new_x);#
	w_hat3 = densratio_obj3$compute_density_ratio(new_x);#
    # library(rgl)#
    # plot3d(new_x[,1],new_x[,2],w_hat1)#
	densratio_obj1#
#
	densratio_obj3#
	hat_pi_c = length(myxcM1s)/(length(myxcM1s)+length(myxcM0s))#
	hat_pi_t = length(myxtM1s)/(length(myxtM1s)+length(myxtM0s))#
#
	hat_pi_c#
	hat_pi_t#
	hat_gsubc = w_hat1 * hat_pi_c;#
	hat_gsubt = w_hat3 * hat_pi_t;#
	# ESTIMATE THETA0 AND THETA1 with DR approach#
#
	theta0vec = rep(NA,length(w_hat1));#
	theta1vec = rep(NA,length(w_hat1));#
#
	for (i in 1:length(w_hat1)) {#
		thismax = max(hat_gsubc[i],hat_gsubt[i]);#
		theta0vec[i] = thismax - hat_gsubc[i];#
		theta1vec[i] = thismax - hat_gsubt[i];#
	}#
#
	DRapproachTheta0 = mean(theta0vec)#
	seDRapproachTheta0 = sqrt(var(theta0vec)/length(theta0vec))#
#
	DRapproachTheta1 = mean(theta1vec)#
	seDRapproachTheta1 = sqrt(var(theta1vec)/length(theta1vec))#
#
	DRapproachTheta0#
	seDRapproachTheta0#
#
	DRapproachTheta1#
	seDRapproachTheta1#
	# ESTIMATE THETA0 AND THETA1 WITH LOGISTIC REGRESSION + JANES TREATMENTSELECTION PACKAGE#
#
	myx1cs = myxcs[1,];#
	myx2cs = myxcs[2,];#
	myx1ts = myxts[1,];#
	myx2ts = myxts[2,];#
	myx1All = c(myx1cs,myx1ts)#
	myx2All = c(myx2cs,myx2ts)#
	myresp = c(mycMresp,mytMresp)#
	mytrtAll = c(rep(0,length(mycMresp)),rep(1,length(mytMresp)));#
	mylogreg = glm(myresp ~ myx1All + myx2All + mytrtAll + #
		myx1All:mytrtAll + myx2All:mytrtAll, family=binomial(link='logit'))#
#
    beta0c = coef(mylogreg)[1]#
    beta0t = coef(mylogreg)[2]#
	beta3 = coef(mylogreg)[5]#
	beta4 = coef(mylogreg)[6]#
	mydim1vec = beta3/sqrt(\beta3^2+\beta4^2);#
	mydim2vec = beta4/sqrt(\beta3^2+\beta4^2);#
    mynewxcM1s = c(mydim1vec,mydim2vec) %*% myxcM1s #
    mynewxtM1s = c(mydim1vec,mydim2vec) %*% myxtM1s#
    mynewxcM0s = c(mydim1vec,mydim2vec) %*% myxcM0s#
    mynewxtM0s = c(mydim1vec,mydim2vec) %*% myxtM0s
beta0c = coef(mylogreg)[1]#
    beta0t = coef(mylogreg)[2]#
	beta3 = coef(mylogreg)[5]#
	beta4 = coef(mylogreg)[6]#
	mydim1vec = beta3/sqrt(beta3^2+beta4^2);#
	mydim2vec = beta4/sqrt(beta3^2+beta4^2);#
    mynewxcM1s = c(mydim1vec,mydim2vec) %*% myxcM1s #
    mynewxtM1s = c(mydim1vec,mydim2vec) %*% myxtM1s#
    mynewxcM0s = c(mydim1vec,mydim2vec) %*% myxcM0s#
    mynewxtM0s = c(mydim1vec,mydim2vec) %*% myxtM0s
hist(myxcM1s)
boxplot(mynewxcM1s,mynewxtM1s,mynewxcM0s,mynewxtM0s)
mynewxcM1s
mynewxcM1s = as.vector(c(mydim1vec,mydim2vec) %*% myxcM1s) #
    mynewxtM1s = as.vector(c(mydim1vec,mydim2vec) %*% myxtM1s)#
    mynewxcM0s = as.vector(c(mydim1vec,mydim2vec) %*% myxcM0s)#
    mynewxtM0s = as.vector(c(mydim1vec,mydim2vec) %*% myxtM0s)#
    boxplot(mynewxcM1s,mynewxtM1s,mynewxcM0s,mynewxtM0s)
library(TreatmentSelection)#
#
	myoutcomes = c(rep(1,length(mynewxcM1s)),rep(0,length(mynewxcM0s)),rep(1,length(mynewxtM1s)),rep(0,length(mynewxtM0s)));#
	mymarker = c(mynewxcM1s,mynewxcM0s,mynewxtM1s,mynewxtM0s);#
	mytreatment = c(rep(0,myn/2),rep(1,myn/2))#
#
	datafraforjanes = data.frame(event=myoutcomes,trt=mytreatment,Y1=mymarker);#
	mytrtsel = trtsel(event ~ Y1*trt,treatment.name="trt",data=datafraforjanes,#
	                      study.design="RCT",family=binomial("logit"),default.trt="trt all")#
	tmp = evaluate(mytrtsel,bootstraps=1000);#
#
	mytrtsel
install.packages("TreatmentSelection")
library(TreatmentSelection)#
#
	myoutcomes = c(rep(1,length(mynewxcM1s)),rep(0,length(mynewxcM0s)),rep(1,length(mynewxtM1s)),rep(0,length(mynewxtM0s)));#
	mymarker = c(mynewxcM1s,mynewxcM0s,mynewxtM1s,mynewxtM0s);#
	mytreatment = c(rep(0,myn/2),rep(1,myn/2))#
#
	datafraforjanes = data.frame(event=myoutcomes,trt=mytreatment,Y1=mymarker);#
	mytrtsel = trtsel(event ~ Y1*trt,treatment.name="trt",data=datafraforjanes,#
	                      study.design="RCT",family=binomial("logit"),default.trt="trt all")#
	tmp = evaluate(mytrtsel,bootstraps=1000);#
#
	mytrtsel
# SIMULATE DATA FROM THE MODEL#
#
thismethod = "uLSIF"#
myn = 800;#
MCRUNS = 3;#
#
myregion = function(x1,x2) {#
	myreturn = -1;#
	if (x1+x2<1) { myreturn = 1; }#
	else { myreturn = 2; }#
}#
#
myalphasubcM1s = c(0.2,1.8)#
myalphasubcM0s = 2-myalphasubcM1s;#
#
myalphasubtM1s = c(1.8,0.2)#
myalphasubtM0s = 2-myalphasubtM1s;#
#
mybaseareas = c(0.5,0.5)#
#
mycM1probs = myalphasubcM1s*mybaseareas;#
mycM0probs = myalphasubcM0s*mybaseareas;#
mytM1probs = myalphasubtM1s*mybaseareas;#
mytM0probs = myalphasubtM0s*mybaseareas;#
#
sum(mycM1probs);#
sum(mycM0probs);#
sum(mytM1probs)#
sum(mytM0probs)#
#
mycM1probs;#
mycM0probs;#
mytM1probs#
mytM0probs#
#
mycM1grps = rmultinom(myn/4,1,mycM1probs)#
mycM0grps = rmultinom(myn/4,1,mycM0probs)#
mytM1grps = rmultinom(myn/4,1,mytM1probs)#
mytM0grps = rmultinom(myn/4,1,mytM0probs)#
#
sum(mycM1grps[1,])#
sum(mycM0grps[1,])#
sum(mytM1grps[1,])#
sum(mytM0grps[1,])#
#
myxcM1s = rep(NA,myn/4)#
myxtM1s = rep(NA,myn/4)#
myxcM0s = rep(NA,myn/4)#
myxtM0s = rep(NA,myn/4)#
#
DRtheta0s = rep(NA,MCRUNS)#
DRtheta1s = rep(NA,MCRUNS)#
HJtheta0s = rep(NA,MCRUNS)#
HJtheta1s = rep(NA,MCRUNS)#
mygeneratefromArea1 = function() {#
	xtry = c(runif(1),runif(1));#
	while (sum(xtry) > 1) { xtry = c(runif(1),runif(1))  }#
	return(xtry);#
}#
mygeneratefromArea2 = function() {#
	xtry = c(runif(1),runif(1));#
	while (sum(xtry) < 1) { xtry = c(runif(1),runif(1))  }#
	return(xtry);#
}#
# RETURN A 2 BY N MATRIX OF BIOMARKER VALUES#
generateCM1rnvs = function(numberneeded) {#
	myreturn = matrix(rep(NA, 2*numberneeded),nrow=2);#
#
	for (i in 1:numberneeded) {#
		myx = c(NA,NA);#
		thismultinom = rmultinom(1,1,mycM1probs);#
#
		if (as.vector(thismultinom)[1] == 1 ) { myx <- mygeneratefromArea1() }#
		if (as.vector(thismultinom)[2] == 1 ) { myx <- mygeneratefromArea2() }#
		myreturn[,i] = myx;#
	}#
	myreturn;#
}#
#
generateTM1rnvs = function(numberneeded) {#
	myreturn = matrix(rep(NA, 2*numberneeded),nrow=2);#
#
	for (i in 1:numberneeded) {#
		myx = c(NA,NA);#
		thismultinom = rmultinom(1,1,mytM1probs);#
#
		if (as.vector(thismultinom)[1] == 1 ) { myx <- mygeneratefromArea1() }#
		if (as.vector(thismultinom)[2] == 1 ) { myx <- mygeneratefromArea2() }#
		myreturn[,i] = myx;#
	}#
	myreturn;#
}#
#
generateCM0rnvs = function(numberneeded) {#
	myreturn = matrix(rep(NA, 2*numberneeded),nrow=2);#
#
	for (i in 1:numberneeded) {#
		myx = c(NA,NA);#
		thismultinom = rmultinom(1,1,mycM0probs);#
#
		if (as.vector(thismultinom)[1] == 1 ) { myx <- mygeneratefromArea1() }#
		if (as.vector(thismultinom)[2] == 1 ) { myx <- mygeneratefromArea2() }#
		myreturn[,i] = myx;#
	}#
	myreturn;#
}#
generateTM0rnvs = function(numberneeded) {#
	myreturn = matrix(rep(NA, 2*numberneeded),nrow=2);#
#
	for (i in 1:numberneeded) {#
		myx = c(NA,NA);#
		thismultinom = rmultinom(1,1,mytM0probs);#
#
		if (as.vector(thismultinom)[1] == 1 ) { myx <- mygeneratefromArea1() }#
		if (as.vector(thismultinom)[2] == 1 ) { myx <- mygeneratefromArea2() }#
		myreturn[,i] = myx;#
	}#
	myreturn;#
}#
for (thismc in 1:MCRUNS)  {#
    mytrt1ctrl0 = rbinom(myn,1,0.5);  # indicates randomization to trt/ctrl#
    myM1is1M0is0 = rbinom(myn,1,0.5); # the conditional probabilities of M1 and M0 are 0.5 for both trt and control#
#
    NumberOfCM1 = length(intersect(which(mytrt1ctrl0==0),which(myM1is1M0is0==1)))#
    NumberOfTM1 = length(intersect(which(mytrt1ctrl0==1),which(myM1is1M0is0==1)))#
    NumberOfCM0 = length(intersect(which(mytrt1ctrl0==0),which(myM1is1M0is0==0)))#
    NumberOfTM0 = length(intersect(which(mytrt1ctrl0==1),which(myM1is1M0is0==0)))#
#
    myxcM1s = generateCM1rnvs(NumberOfCM1)#
    myxtM1s = generateTM1rnvs(NumberOfTM1)#
    myxcM0s = generateCM0rnvs(NumberOfCM0)#
    myxtM0s = generateTM0rnvs(NumberOfTM0)#
#
	apply(myxcM1s,1,mean)#
	apply(myxtM1s,1,mean)#
	apply(myxcM0s,1,mean)#
	apply(myxtM0s,1,mean)#
	myxcs = cbind(myxcM0s,myxcM1s);#
	myxts = cbind(myxtM0s,myxtM1s);#
	myxmarginal = cbind(myxcs,myxts)#
#
	mycMresp = c(rep(0,NumberOfCM0),rep(1,NumberOfCM1)) #
	mytMresp = c(rep(0,NumberOfTM0),rep(1,NumberOfTM1)) #
	# DENSITY RATIO ESTIMATION#
#
	install.packages("densratio")#
	library(densratio)#
	densratio_obj1 = densratio(t(cbind(myxcM1s,myxcM1s,myxcM1s,myxcM1s)),t(myxmarginal),method=thismethod)#
	densratio_obj3 = densratio(t(cbind(myxtM1s,myxtM1s,myxtM1s,myxtM1s)),t(myxmarginal),method=thismethod)#
#
	new_x = t(matrix(runif(2000),nrow=2));#
#
	w_hat1 = densratio_obj1$compute_density_ratio(new_x);#
	w_hat3 = densratio_obj3$compute_density_ratio(new_x);#
    # library(rgl)#
    # plot3d(new_x[,1],new_x[,2],w_hat1)#
	densratio_obj1#
#
	densratio_obj3#
	hat_pi_c = length(myxcM1s)/(length(myxcM1s)+length(myxcM0s))#
	hat_pi_t = length(myxtM1s)/(length(myxtM1s)+length(myxtM0s))#
#
	hat_pi_c#
	hat_pi_t#
	hat_gsubc = w_hat1 * hat_pi_c;#
	hat_gsubt = w_hat3 * hat_pi_t;#
	# ESTIMATE THETA0 AND THETA1 with DR approach#
#
	theta0vec = rep(NA,length(w_hat1));#
	theta1vec = rep(NA,length(w_hat1));#
#
	for (i in 1:length(w_hat1)) {#
		thismax = max(hat_gsubc[i],hat_gsubt[i]);#
		theta0vec[i] = thismax - hat_gsubc[i];#
		theta1vec[i] = thismax - hat_gsubt[i];#
	}#
#
	DRapproachTheta0 = mean(theta0vec)#
	seDRapproachTheta0 = sqrt(var(theta0vec)/length(theta0vec))#
#
	DRapproachTheta1 = mean(theta1vec)#
	seDRapproachTheta1 = sqrt(var(theta1vec)/length(theta1vec))#
#
	DRapproachTheta0#
	seDRapproachTheta0#
#
	DRapproachTheta1#
	seDRapproachTheta1#
	# ESTIMATE THETA0 AND THETA1 WITH LOGISTIC REGRESSION + JANES TREATMENTSELECTION PACKAGE#
#
	myx1cs = myxcs[1,];#
	myx2cs = myxcs[2,];#
	myx1ts = myxts[1,];#
	myx2ts = myxts[2,];#
	myx1All = c(myx1cs,myx1ts)#
	myx2All = c(myx2cs,myx2ts)#
	myresp = c(mycMresp,mytMresp)#
	mytrtAll = c(rep(0,length(mycMresp)),rep(1,length(mytMresp)));#
	mylogreg = glm(myresp ~ myx1All + myx2All + mytrtAll + #
		myx1All:mytrtAll + myx2All:mytrtAll, family=binomial(link='logit'))#
#
    beta0c = coef(mylogreg)[1]#
    beta0t = coef(mylogreg)[2]#
	beta3 = coef(mylogreg)[5]#
	beta4 = coef(mylogreg)[6]#
	mydim1vec = beta3/sqrt(beta3^2+beta4^2);#
	mydim2vec = beta4/sqrt(beta3^2+beta4^2);#
    mynewxcM1s = as.vector(c(mydim1vec,mydim2vec) %*% myxcM1s) #
    mynewxtM1s = as.vector(c(mydim1vec,mydim2vec) %*% myxtM1s)#
    mynewxcM0s = as.vector(c(mydim1vec,mydim2vec) %*% myxcM0s)#
    mynewxtM0s = as.vector(c(mydim1vec,mydim2vec) %*% myxtM0s)#
    # boxplot(mynewxcM1s,mynewxtM1s,mynewxcM0s,mynewxtM0s)#
	library(TreatmentSelection)#
#
	myoutcomes = c(rep(1,length(mynewxcM1s)),rep(0,length(mynewxcM0s)),rep(1,length(mynewxtM1s)),rep(0,length(mynewxtM0s)));#
	mymarker = c(mynewxcM1s,mynewxcM0s,mynewxtM1s,mynewxtM0s);#
	mytreatment = c(rep(0,myn/2),rep(1,myn/2))#
#
	datafraforjanes = data.frame(event=myoutcomes,trt=mytreatment,Y1=mymarker);#
	mytrtsel = trtsel(event ~ Y1*trt,treatment.name="trt",data=datafraforjanes,#
	                      study.design="RCT",family=binomial("logit"),default.trt="trt all")#
	tmp = evaluate(mytrtsel,bootstraps=1000);#
#
	mytrtsel#
#
	tmp#
#
	JanesTheta1 = tmp$estimates$Theta.emp#
#
	JanesTheta1#
#
	datafraforjanes = data.frame(event=myoutcomes,trt=mytreatment,Y1=mymarker);#
	mytrtsel = trtsel(event ~ Y1*trt,treatment.name="trt",data=datafraforjanes,#
	                      study.design="RCT",family=binomial("logit"),default.trt="trt none")#
	tmp = evaluate(mytrtsel,bootstraps=1000);#
#
	JanesTheta0 = tmp$estimates$Theta.emp#
	JanesTheta0#
#
	DRtheta0s[thismc] = DRapproachTheta0;#
	DRtheta1s[thismc] = DRapproachTheta1;#
	HJtheta0s[thismc] = JanesTheta0; #
	HJtheta1s[thismc] = JanesTheta1;#
}#
#
write.table(cbind(DRtheta0s,DRtheta1s,HJtheta0s,HJtheta1s),file="simTriangleAreamyn3200MCRUNS100.txt")
summary(DRtheta0s)
summary(DRtheta1s)
summary(HJtheta0s)
summary(HJtheta1s)
# SIMULATE DATA FROM THE MODEL#
#
thismethod = "uLSIF"#
myn = 800;#
MCRUNS = 3;#
#
myregion = function(x1,x2) {#
	myreturn = -1;#
	if (x1 < (1/3)) { myreturn = 1; }#
	elseif (x1>(1/3)) & (x1<(2/3)) & (x2<(1/2))) { myreturn = 1; }#
	else { myreturn = 2; }#
}#
#
myalphasubcM1s = c(0.2,1.8)#
myalphasubcM0s = 2-myalphasubcM1s;#
#
myalphasubtM1s = c(1.8,0.2)#
myalphasubtM0s = 2-myalphasubtM1s;#
#
mybaseareas = c(0.5,0.5)#
#
mycM1probs = myalphasubcM1s*mybaseareas;#
mycM0probs = myalphasubcM0s*mybaseareas;#
mytM1probs = myalphasubtM1s*mybaseareas;#
mytM0probs = myalphasubtM0s*mybaseareas;#
#
sum(mycM1probs);#
sum(mycM0probs);#
sum(mytM1probs)#
sum(mytM0probs)#
#
mycM1probs;#
mycM0probs;#
mytM1probs#
mytM0probs#
#
mycM1grps = rmultinom(myn/4,1,mycM1probs)#
mycM0grps = rmultinom(myn/4,1,mycM0probs)#
mytM1grps = rmultinom(myn/4,1,mytM1probs)#
mytM0grps = rmultinom(myn/4,1,mytM0probs)#
#
sum(mycM1grps[1,])#
sum(mycM0grps[1,])#
sum(mytM1grps[1,])#
sum(mytM0grps[1,])#
#
myxcM1s = rep(NA,myn/4)#
myxtM1s = rep(NA,myn/4)#
myxcM0s = rep(NA,myn/4)#
myxtM0s = rep(NA,myn/4)#
#
DRtheta0s = rep(NA,MCRUNS)#
DRtheta1s = rep(NA,MCRUNS)#
HJtheta0s = rep(NA,MCRUNS)#
HJtheta1s = rep(NA,MCRUNS)#
mygeneratefromArea1 = function() {#
	xtry = c(runif(1),runif(1));#
	while (sum(xtry) > 1) { xtry = c(runif(1),runif(1))  }#
	return(xtry);#
}#
mygeneratefromArea2 = function() {#
	xtry = c(runif(1),runif(1));#
	while (sum(xtry) < 1) { xtry = c(runif(1),runif(1))  }#
	return(xtry);#
}#
# RETURN A 2 BY N MATRIX OF BIOMARKER VALUES#
generateCM1rnvs = function(numberneeded) {#
	myreturn = matrix(rep(NA, 2*numberneeded),nrow=2);#
#
	for (i in 1:numberneeded) {#
		myx = c(NA,NA);#
		thismultinom = rmultinom(1,1,mycM1probs);#
#
		if (as.vector(thismultinom)[1] == 1 ) { myx <- mygeneratefromArea1() }#
		if (as.vector(thismultinom)[2] == 1 ) { myx <- mygeneratefromArea2() }#
		myreturn[,i] = myx;#
	}#
	myreturn;#
}#
#
generateTM1rnvs = function(numberneeded) {#
	myreturn = matrix(rep(NA, 2*numberneeded),nrow=2);#
#
	for (i in 1:numberneeded) {#
		myx = c(NA,NA);#
		thismultinom = rmultinom(1,1,mytM1probs);#
#
		if (as.vector(thismultinom)[1] == 1 ) { myx <- mygeneratefromArea1() }#
		if (as.vector(thismultinom)[2] == 1 ) { myx <- mygeneratefromArea2() }#
		myreturn[,i] = myx;#
	}#
	myreturn;#
}#
#
generateCM0rnvs = function(numberneeded) {#
	myreturn = matrix(rep(NA, 2*numberneeded),nrow=2);#
#
	for (i in 1:numberneeded) {#
		myx = c(NA,NA);#
		thismultinom = rmultinom(1,1,mycM0probs);#
#
		if (as.vector(thismultinom)[1] == 1 ) { myx <- mygeneratefromArea1() }#
		if (as.vector(thismultinom)[2] == 1 ) { myx <- mygeneratefromArea2() }#
		myreturn[,i] = myx;#
	}#
	myreturn;#
}#
generateTM0rnvs = function(numberneeded) {#
	myreturn = matrix(rep(NA, 2*numberneeded),nrow=2);#
#
	for (i in 1:numberneeded) {#
		myx = c(NA,NA);#
		thismultinom = rmultinom(1,1,mytM0probs);#
#
		if (as.vector(thismultinom)[1] == 1 ) { myx <- mygeneratefromArea1() }#
		if (as.vector(thismultinom)[2] == 1 ) { myx <- mygeneratefromArea2() }#
		myreturn[,i] = myx;#
	}#
	myreturn;#
}#
for (thismc in 1:MCRUNS)  {#
    mytrt1ctrl0 = rbinom(myn,1,0.5);  # indicates randomization to trt/ctrl#
    myM1is1M0is0 = rbinom(myn,1,0.5); # the conditional probabilities of M1 and M0 are 0.5 for both trt and control#
#
    NumberOfCM1 = length(intersect(which(mytrt1ctrl0==0),which(myM1is1M0is0==1)))#
    NumberOfTM1 = length(intersect(which(mytrt1ctrl0==1),which(myM1is1M0is0==1)))#
    NumberOfCM0 = length(intersect(which(mytrt1ctrl0==0),which(myM1is1M0is0==0)))#
    NumberOfTM0 = length(intersect(which(mytrt1ctrl0==1),which(myM1is1M0is0==0)))#
#
    myxcM1s = generateCM1rnvs(NumberOfCM1)#
    myxtM1s = generateTM1rnvs(NumberOfTM1)#
    myxcM0s = generateCM0rnvs(NumberOfCM0)#
    myxtM0s = generateTM0rnvs(NumberOfTM0)#
#
	apply(myxcM1s,1,mean)#
	apply(myxtM1s,1,mean)#
	apply(myxcM0s,1,mean)#
	apply(myxtM0s,1,mean)#
	myxcs = cbind(myxcM0s,myxcM1s);#
	myxts = cbind(myxtM0s,myxtM1s);#
	myxmarginal = cbind(myxcs,myxts)#
#
	mycMresp = c(rep(0,NumberOfCM0),rep(1,NumberOfCM1)) #
	mytMresp = c(rep(0,NumberOfTM0),rep(1,NumberOfTM1)) #
	# DENSITY RATIO ESTIMATION#
#
	install.packages("densratio")#
	library(densratio)#
	densratio_obj1 = densratio(t(cbind(myxcM1s,myxcM1s,myxcM1s,myxcM1s)),t(myxmarginal),method=thismethod)#
	densratio_obj3 = densratio(t(cbind(myxtM1s,myxtM1s,myxtM1s,myxtM1s)),t(myxmarginal),method=thismethod)#
#
	new_x = t(matrix(runif(2000),nrow=2));#
#
	w_hat1 = densratio_obj1$compute_density_ratio(new_x);#
	w_hat3 = densratio_obj3$compute_density_ratio(new_x);#
    # library(rgl)#
    # plot3d(new_x[,1],new_x[,2],w_hat1)#
	densratio_obj1#
#
	densratio_obj3#
	hat_pi_c = length(myxcM1s)/(length(myxcM1s)+length(myxcM0s))#
	hat_pi_t = length(myxtM1s)/(length(myxtM1s)+length(myxtM0s))#
#
	hat_pi_c#
	hat_pi_t#
	hat_gsubc = w_hat1 * hat_pi_c;#
	hat_gsubt = w_hat3 * hat_pi_t;#
	# ESTIMATE THETA0 AND THETA1 with DR approach#
#
	theta0vec = rep(NA,length(w_hat1));#
	theta1vec = rep(NA,length(w_hat1));#
#
	for (i in 1:length(w_hat1)) {#
		thismax = max(hat_gsubc[i],hat_gsubt[i]);#
		theta0vec[i] = thismax - hat_gsubc[i];#
		theta1vec[i] = thismax - hat_gsubt[i];#
	}#
#
	DRapproachTheta0 = mean(theta0vec)#
	seDRapproachTheta0 = sqrt(var(theta0vec)/length(theta0vec))#
#
	DRapproachTheta1 = mean(theta1vec)#
	seDRapproachTheta1 = sqrt(var(theta1vec)/length(theta1vec))#
#
	DRapproachTheta0#
	seDRapproachTheta0#
#
	DRapproachTheta1#
	seDRapproachTheta1#
	# ESTIMATE THETA0 AND THETA1 WITH LOGISTIC REGRESSION + JANES TREATMENTSELECTION PACKAGE#
#
	myx1cs = myxcs[1,];#
	myx2cs = myxcs[2,];#
	myx1ts = myxts[1,];#
	myx2ts = myxts[2,];#
	myx1All = c(myx1cs,myx1ts)#
	myx2All = c(myx2cs,myx2ts)#
	myresp = c(mycMresp,mytMresp)#
	mytrtAll = c(rep(0,length(mycMresp)),rep(1,length(mytMresp)));#
	mylogreg = glm(myresp ~ myx1All + myx2All + mytrtAll + #
		myx1All:mytrtAll + myx2All:mytrtAll, family=binomial(link='logit'))#
#
    beta0c = coef(mylogreg)[1]#
    beta0t = coef(mylogreg)[2]#
	beta3 = coef(mylogreg)[5]#
	beta4 = coef(mylogreg)[6]#
	mydim1vec = beta3/sqrt(beta3^2+beta4^2);#
	mydim2vec = beta4/sqrt(beta3^2+beta4^2);#
    mynewxcM1s = as.vector(c(mydim1vec,mydim2vec) %*% myxcM1s) #
    mynewxtM1s = as.vector(c(mydim1vec,mydim2vec) %*% myxtM1s)#
    mynewxcM0s = as.vector(c(mydim1vec,mydim2vec) %*% myxcM0s)#
    mynewxtM0s = as.vector(c(mydim1vec,mydim2vec) %*% myxtM0s)#
    # boxplot(mynewxcM1s,mynewxtM1s,mynewxcM0s,mynewxtM0s)#
	library(TreatmentSelection)#
#
	myoutcomes = c(rep(1,length(mynewxcM1s)),rep(0,length(mynewxcM0s)),rep(1,length(mynewxtM1s)),rep(0,length(mynewxtM0s)));#
	mymarker = c(mynewxcM1s,mynewxcM0s,mynewxtM1s,mynewxtM0s);#
	mytreatment = c(rep(0,myn/2),rep(1,myn/2))#
#
	datafraforjanes = data.frame(event=myoutcomes,trt=mytreatment,Y1=mymarker);#
	mytrtsel = trtsel(event ~ Y1*trt,treatment.name="trt",data=datafraforjanes,#
	                      study.design="RCT",family=binomial("logit"),default.trt="trt all")#
	tmp = evaluate(mytrtsel,bootstraps=1000);#
#
	mytrtsel#
#
	tmp#
#
	JanesTheta1 = tmp$estimates$Theta.emp#
#
	JanesTheta1#
#
	datafraforjanes = data.frame(event=myoutcomes,trt=mytreatment,Y1=mymarker);#
	mytrtsel = trtsel(event ~ Y1*trt,treatment.name="trt",data=datafraforjanes,#
	                      study.design="RCT",family=binomial("logit"),default.trt="trt none")#
	tmp = evaluate(mytrtsel,bootstraps=1000);#
#
	JanesTheta0 = tmp$estimates$Theta.emp#
	JanesTheta0#
#
	DRtheta0s[thismc] = DRapproachTheta0;#
	DRtheta1s[thismc] = DRapproachTheta1;#
	HJtheta0s[thismc] = JanesTheta0; #
	HJtheta1s[thismc] = JanesTheta1;#
}#
#
write.table(cbind(DRtheta0s,DRtheta1s,HJtheta0s,HJtheta1s),file="simStepshapeAreamyn800MCRUNS100.txt")
cbind(DRtheta0s,DRtheta1s,HJtheta0s,HJtheta1s)
library(rgl)#
    plot3d(new_x[,1],new_x[,2],w_hat1)
# SIMULATE DATA FROM THE MODEL#
#
thismethod = "uLSIF"#
myn = 3200;#
MCRUNS = 3;#
#
myregion = function(x1,x2) {#
	myreturn = -1;#
	if (x1 < (1/3)) { myreturn = 1; }#
	elseif (x1>(1/3)) & (x1<(2/3)) & (x2<(1/2))) { myreturn = 1; }#
	else { myreturn = 2; }#
}#
#
myalphasubcM1s = c(0.2,1.8)#
myalphasubcM0s = 2-myalphasubcM1s;#
#
myalphasubtM1s = c(1.8,0.2)#
myalphasubtM0s = 2-myalphasubtM1s;#
#
mybaseareas = c(0.5,0.5)#
#
mycM1probs = myalphasubcM1s*mybaseareas;#
mycM0probs = myalphasubcM0s*mybaseareas;#
mytM1probs = myalphasubtM1s*mybaseareas;#
mytM0probs = myalphasubtM0s*mybaseareas;#
#
sum(mycM1probs);#
sum(mycM0probs);#
sum(mytM1probs)#
sum(mytM0probs)#
#
mycM1probs;#
mycM0probs;#
mytM1probs#
mytM0probs#
#
mycM1grps = rmultinom(myn/4,1,mycM1probs)#
mycM0grps = rmultinom(myn/4,1,mycM0probs)#
mytM1grps = rmultinom(myn/4,1,mytM1probs)#
mytM0grps = rmultinom(myn/4,1,mytM0probs)#
#
sum(mycM1grps[1,])#
sum(mycM0grps[1,])#
sum(mytM1grps[1,])#
sum(mytM0grps[1,])#
#
myxcM1s = rep(NA,myn/4)#
myxtM1s = rep(NA,myn/4)#
myxcM0s = rep(NA,myn/4)#
myxtM0s = rep(NA,myn/4)#
#
DRtheta0s = rep(NA,MCRUNS)#
DRtheta1s = rep(NA,MCRUNS)#
HJtheta0s = rep(NA,MCRUNS)#
HJtheta1s = rep(NA,MCRUNS)#
mygeneratefromArea1 = function() {#
	xtry = c(runif(1),runif(1));#
	while (sum(xtry) > 1) { xtry = c(runif(1),runif(1))  }#
	return(xtry);#
}#
mygeneratefromArea2 = function() {#
	xtry = c(runif(1),runif(1));#
	while (sum(xtry) < 1) { xtry = c(runif(1),runif(1))  }#
	return(xtry);#
}#
# RETURN A 2 BY N MATRIX OF BIOMARKER VALUES#
generateCM1rnvs = function(numberneeded) {#
	myreturn = matrix(rep(NA, 2*numberneeded),nrow=2);#
#
	for (i in 1:numberneeded) {#
		myx = c(NA,NA);#
		thismultinom = rmultinom(1,1,mycM1probs);#
#
		if (as.vector(thismultinom)[1] == 1 ) { myx <- mygeneratefromArea1() }#
		if (as.vector(thismultinom)[2] == 1 ) { myx <- mygeneratefromArea2() }#
		myreturn[,i] = myx;#
	}#
	myreturn;#
}#
#
generateTM1rnvs = function(numberneeded) {#
	myreturn = matrix(rep(NA, 2*numberneeded),nrow=2);#
#
	for (i in 1:numberneeded) {#
		myx = c(NA,NA);#
		thismultinom = rmultinom(1,1,mytM1probs);#
#
		if (as.vector(thismultinom)[1] == 1 ) { myx <- mygeneratefromArea1() }#
		if (as.vector(thismultinom)[2] == 1 ) { myx <- mygeneratefromArea2() }#
		myreturn[,i] = myx;#
	}#
	myreturn;#
}#
#
generateCM0rnvs = function(numberneeded) {#
	myreturn = matrix(rep(NA, 2*numberneeded),nrow=2);#
#
	for (i in 1:numberneeded) {#
		myx = c(NA,NA);#
		thismultinom = rmultinom(1,1,mycM0probs);#
#
		if (as.vector(thismultinom)[1] == 1 ) { myx <- mygeneratefromArea1() }#
		if (as.vector(thismultinom)[2] == 1 ) { myx <- mygeneratefromArea2() }#
		myreturn[,i] = myx;#
	}#
	myreturn;#
}#
generateTM0rnvs = function(numberneeded) {#
	myreturn = matrix(rep(NA, 2*numberneeded),nrow=2);#
#
	for (i in 1:numberneeded) {#
		myx = c(NA,NA);#
		thismultinom = rmultinom(1,1,mytM0probs);#
#
		if (as.vector(thismultinom)[1] == 1 ) { myx <- mygeneratefromArea1() }#
		if (as.vector(thismultinom)[2] == 1 ) { myx <- mygeneratefromArea2() }#
		myreturn[,i] = myx;#
	}#
	myreturn;#
}#
for (thismc in 1:MCRUNS)  {#
    mytrt1ctrl0 = rbinom(myn,1,0.5);  # indicates randomization to trt/ctrl#
    myM1is1M0is0 = rbinom(myn,1,0.5); # the conditional probabilities of M1 and M0 are 0.5 for both trt and control#
#
    NumberOfCM1 = length(intersect(which(mytrt1ctrl0==0),which(myM1is1M0is0==1)))#
    NumberOfTM1 = length(intersect(which(mytrt1ctrl0==1),which(myM1is1M0is0==1)))#
    NumberOfCM0 = length(intersect(which(mytrt1ctrl0==0),which(myM1is1M0is0==0)))#
    NumberOfTM0 = length(intersect(which(mytrt1ctrl0==1),which(myM1is1M0is0==0)))#
#
    myxcM1s = generateCM1rnvs(NumberOfCM1)#
    myxtM1s = generateTM1rnvs(NumberOfTM1)#
    myxcM0s = generateCM0rnvs(NumberOfCM0)#
    myxtM0s = generateTM0rnvs(NumberOfTM0)#
#
	apply(myxcM1s,1,mean)#
	apply(myxtM1s,1,mean)#
	apply(myxcM0s,1,mean)#
	apply(myxtM0s,1,mean)#
	myxcs = cbind(myxcM0s,myxcM1s);#
	myxts = cbind(myxtM0s,myxtM1s);#
	myxmarginal = cbind(myxcs,myxts)#
#
	mycMresp = c(rep(0,NumberOfCM0),rep(1,NumberOfCM1)) #
	mytMresp = c(rep(0,NumberOfTM0),rep(1,NumberOfTM1)) #
	# DENSITY RATIO ESTIMATION#
#
	install.packages("densratio")#
	library(densratio)#
	densratio_obj1 = densratio(t(cbind(myxcM1s,myxcM1s,myxcM1s,myxcM1s)),t(myxmarginal),method=thismethod)#
	densratio_obj3 = densratio(t(cbind(myxtM1s,myxtM1s,myxtM1s,myxtM1s)),t(myxmarginal),method=thismethod)#
#
	new_x = t(matrix(runif(2000),nrow=2));#
#
	w_hat1 = densratio_obj1$compute_density_ratio(new_x);#
	w_hat3 = densratio_obj3$compute_density_ratio(new_x);#
    library(rgl)#
    plot3d(new_x[,1],new_x[,2],w_hat1)#
	densratio_obj1#
#
	densratio_obj3#
	hat_pi_c = length(myxcM1s)/(length(myxcM1s)+length(myxcM0s))#
	hat_pi_t = length(myxtM1s)/(length(myxtM1s)+length(myxtM0s))#
#
	hat_pi_c#
	hat_pi_t#
	hat_gsubc = w_hat1 * hat_pi_c;#
	hat_gsubt = w_hat3 * hat_pi_t;#
	# ESTIMATE THETA0 AND THETA1 with DR approach#
#
	theta0vec = rep(NA,length(w_hat1));#
	theta1vec = rep(NA,length(w_hat1));#
#
	for (i in 1:length(w_hat1)) {#
		thismax = max(hat_gsubc[i],hat_gsubt[i]);#
		theta0vec[i] = thismax - hat_gsubc[i];#
		theta1vec[i] = thismax - hat_gsubt[i];#
	}#
#
	DRapproachTheta0 = mean(theta0vec)#
	seDRapproachTheta0 = sqrt(var(theta0vec)/length(theta0vec))#
#
	DRapproachTheta1 = mean(theta1vec)#
	seDRapproachTheta1 = sqrt(var(theta1vec)/length(theta1vec))#
#
	DRapproachTheta0#
	seDRapproachTheta0#
#
	DRapproachTheta1#
	seDRapproachTheta1#
	# ESTIMATE THETA0 AND THETA1 WITH LOGISTIC REGRESSION + JANES TREATMENTSELECTION PACKAGE#
#
	myx1cs = myxcs[1,];#
	myx2cs = myxcs[2,];#
	myx1ts = myxts[1,];#
	myx2ts = myxts[2,];#
	myx1All = c(myx1cs,myx1ts)#
	myx2All = c(myx2cs,myx2ts)#
	myresp = c(mycMresp,mytMresp)#
	mytrtAll = c(rep(0,length(mycMresp)),rep(1,length(mytMresp)));#
	mylogreg = glm(myresp ~ myx1All + myx2All + mytrtAll + #
		myx1All:mytrtAll + myx2All:mytrtAll, family=binomial(link='logit'))#
#
    beta0c = coef(mylogreg)[1]#
    beta0t = coef(mylogreg)[2]#
	beta3 = coef(mylogreg)[5]#
	beta4 = coef(mylogreg)[6]#
	mydim1vec = beta3/sqrt(beta3^2+beta4^2);#
	mydim2vec = beta4/sqrt(beta3^2+beta4^2);#
    mynewxcM1s = as.vector(c(mydim1vec,mydim2vec) %*% myxcM1s) #
    mynewxtM1s = as.vector(c(mydim1vec,mydim2vec) %*% myxtM1s)#
    mynewxcM0s = as.vector(c(mydim1vec,mydim2vec) %*% myxcM0s)#
    mynewxtM0s = as.vector(c(mydim1vec,mydim2vec) %*% myxtM0s)#
    # boxplot(mynewxcM1s,mynewxtM1s,mynewxcM0s,mynewxtM0s)#
	library(TreatmentSelection)#
#
	myoutcomes = c(rep(1,length(mynewxcM1s)),rep(0,length(mynewxcM0s)),rep(1,length(mynewxtM1s)),rep(0,length(mynewxtM0s)));#
	mymarker = c(mynewxcM1s,mynewxcM0s,mynewxtM1s,mynewxtM0s);#
	mytreatment = c(rep(0,myn/2),rep(1,myn/2))#
#
	datafraforjanes = data.frame(event=myoutcomes,trt=mytreatment,Y1=mymarker);#
	mytrtsel = trtsel(event ~ Y1*trt,treatment.name="trt",data=datafraforjanes,#
	                      study.design="RCT",family=binomial("logit"),default.trt="trt all")#
	tmp = evaluate(mytrtsel,bootstraps=1000);#
#
	mytrtsel#
#
	tmp#
#
	JanesTheta1 = tmp$estimates$Theta.emp#
#
	JanesTheta1#
#
	datafraforjanes = data.frame(event=myoutcomes,trt=mytreatment,Y1=mymarker);#
	mytrtsel = trtsel(event ~ Y1*trt,treatment.name="trt",data=datafraforjanes,#
	                      study.design="RCT",family=binomial("logit"),default.trt="trt none")#
	tmp = evaluate(mytrtsel,bootstraps=1000);#
#
	JanesTheta0 = tmp$estimates$Theta.emp#
	JanesTheta0#
#
	DRtheta0s[thismc] = DRapproachTheta0;#
	DRtheta1s[thismc] = DRapproachTheta1;#
	HJtheta0s[thismc] = JanesTheta0; #
	HJtheta1s[thismc] = JanesTheta1;#
}#
#
write.table(cbind(DRtheta0s,DRtheta1s,HJtheta0s,HJtheta1s),file="simStepshapeAreamyn800MCRUNS100.txt")#
#
cbind(DRtheta0s,DRtheta1s,HJtheta0s,HJtheta1s)
# SIMULATE DATA FROM THE MODEL#
#
thismethod = "uLSIF"#
myn = 800;#
MCRUNS = 3;#
#
myregion = function(x1,x2) {#
	myreturn = -1;#
	condA = (0.1464 < x1);#
	condB = (x1 < 0.8536);#
	condC = (0.1464 < x2);#
	condD = (x2 < 0.8536);#
	myreturn = 2 - (condA*condB*condC*condD)#
	myreturn;#
}#
#
myalphasubcM1s = c(0.2,1.8)#
myalphasubcM0s = 2-myalphasubcM1s;#
#
myalphasubtM1s = c(1.8,0.2)#
myalphasubtM0s = 2-myalphasubtM1s;#
#
mybaseareas = c(0.5,0.5)#
#
mycM1probs = myalphasubcM1s*mybaseareas;#
mycM0probs = myalphasubcM0s*mybaseareas;#
mytM1probs = myalphasubtM1s*mybaseareas;#
mytM0probs = myalphasubtM0s*mybaseareas;#
#
sum(mycM1probs);#
sum(mycM0probs);#
sum(mytM1probs)#
sum(mytM0probs)#
#
mycM1probs;#
mycM0probs;#
mytM1probs#
mytM0probs#
#
mycM1grps = rmultinom(myn/4,1,mycM1probs)#
mycM0grps = rmultinom(myn/4,1,mycM0probs)#
mytM1grps = rmultinom(myn/4,1,mytM1probs)#
mytM0grps = rmultinom(myn/4,1,mytM0probs)#
#
sum(mycM1grps[1,])#
sum(mycM0grps[1,])#
sum(mytM1grps[1,])#
sum(mytM0grps[1,])#
#
myxcM1s = rep(NA,myn/4)#
myxtM1s = rep(NA,myn/4)#
myxcM0s = rep(NA,myn/4)#
myxtM0s = rep(NA,myn/4)#
#
DRtheta0s = rep(NA,MCRUNS)#
DRtheta1s = rep(NA,MCRUNS)#
HJtheta0s = rep(NA,MCRUNS)#
HJtheta1s = rep(NA,MCRUNS)#
mygeneratefromArea1 = function() {#
	xtry = c(runif(1),runif(1));#
	while (myregion(xtry[1],xtry[2]) != 1) { xtry = c(runif(1),runif(1))  }#
	return(xtry);#
}#
mygeneratefromArea2 = function() {#
	xtry = c(runif(1),runif(1));#
	while (myregion(xtry[1],xtry[2]) != 2) { xtry = c(runif(1),runif(1))  }#
	return(xtry);#
}#
# RETURN A 2 BY N MATRIX OF BIOMARKER VALUES#
generateCM1rnvs = function(numberneeded) {#
	myreturn = matrix(rep(NA, 2*numberneeded),nrow=2);#
#
	for (i in 1:numberneeded) {#
		myx = c(NA,NA);#
		thismultinom = rmultinom(1,1,mycM1probs);#
#
		if (as.vector(thismultinom)[1] == 1 ) { myx <- mygeneratefromArea1() }#
		if (as.vector(thismultinom)[2] == 1 ) { myx <- mygeneratefromArea2() }#
		myreturn[,i] = myx;#
	}#
	myreturn;#
}#
#
generateTM1rnvs = function(numberneeded) {#
	myreturn = matrix(rep(NA, 2*numberneeded),nrow=2);#
#
	for (i in 1:numberneeded) {#
		myx = c(NA,NA);#
		thismultinom = rmultinom(1,1,mytM1probs);#
#
		if (as.vector(thismultinom)[1] == 1 ) { myx <- mygeneratefromArea1() }#
		if (as.vector(thismultinom)[2] == 1 ) { myx <- mygeneratefromArea2() }#
		myreturn[,i] = myx;#
	}#
	myreturn;#
}#
#
generateCM0rnvs = function(numberneeded) {#
	myreturn = matrix(rep(NA, 2*numberneeded),nrow=2);#
#
	for (i in 1:numberneeded) {#
		myx = c(NA,NA);#
		thismultinom = rmultinom(1,1,mycM0probs);#
#
		if (as.vector(thismultinom)[1] == 1 ) { myx <- mygeneratefromArea1() }#
		if (as.vector(thismultinom)[2] == 1 ) { myx <- mygeneratefromArea2() }#
		myreturn[,i] = myx;#
	}#
	myreturn;#
}#
generateTM0rnvs = function(numberneeded) {#
	myreturn = matrix(rep(NA, 2*numberneeded),nrow=2);#
#
	for (i in 1:numberneeded) {#
		myx = c(NA,NA);#
		thismultinom = rmultinom(1,1,mytM0probs);#
#
		if (as.vector(thismultinom)[1] == 1 ) { myx <- mygeneratefromArea1() }#
		if (as.vector(thismultinom)[2] == 1 ) { myx <- mygeneratefromArea2() }#
		myreturn[,i] = myx;#
	}#
	myreturn;#
}#
for (thismc in 1:MCRUNS)  {#
    mytrt1ctrl0 = rbinom(myn,1,0.5);  # indicates randomization to trt/ctrl#
    myM1is1M0is0 = rbinom(myn,1,0.5); # the conditional probabilities of M1 and M0 are 0.5 for both trt and control#
#
    NumberOfCM1 = length(intersect(which(mytrt1ctrl0==0),which(myM1is1M0is0==1)))#
    NumberOfTM1 = length(intersect(which(mytrt1ctrl0==1),which(myM1is1M0is0==1)))#
    NumberOfCM0 = length(intersect(which(mytrt1ctrl0==0),which(myM1is1M0is0==0)))#
    NumberOfTM0 = length(intersect(which(mytrt1ctrl0==1),which(myM1is1M0is0==0)))#
#
    myxcM1s = generateCM1rnvs(NumberOfCM1)#
    myxtM1s = generateTM1rnvs(NumberOfTM1)#
    myxcM0s = generateCM0rnvs(NumberOfCM0)#
    myxtM0s = generateTM0rnvs(NumberOfTM0)#
#
	apply(myxcM1s,1,mean)#
	apply(myxtM1s,1,mean)#
	apply(myxcM0s,1,mean)#
	apply(myxtM0s,1,mean)#
	myxcs = cbind(myxcM0s,myxcM1s);#
	myxts = cbind(myxtM0s,myxtM1s);#
	myxmarginal = cbind(myxcs,myxts)#
#
	mycMresp = c(rep(0,NumberOfCM0),rep(1,NumberOfCM1)) #
	mytMresp = c(rep(0,NumberOfTM0),rep(1,NumberOfTM1)) #
	# DENSITY RATIO ESTIMATION#
#
	install.packages("densratio")#
	library(densratio)#
	densratio_obj1 = densratio(t(cbind(myxcM1s,myxcM1s,myxcM1s,myxcM1s)),t(myxmarginal),method=thismethod)#
	densratio_obj3 = densratio(t(cbind(myxtM1s,myxtM1s,myxtM1s,myxtM1s)),t(myxmarginal),method=thismethod)#
#
	new_x = t(matrix(runif(2000),nrow=2));#
#
	w_hat1 = densratio_obj1$compute_density_ratio(new_x);#
	w_hat3 = densratio_obj3$compute_density_ratio(new_x);#
    # library(rgl)#
    # plot3d(new_x[,1],new_x[,2],w_hat1)#
	densratio_obj1#
#
	densratio_obj3#
	hat_pi_c = length(myxcM1s)/(length(myxcM1s)+length(myxcM0s))#
	hat_pi_t = length(myxtM1s)/(length(myxtM1s)+length(myxtM0s))#
#
	hat_pi_c#
	hat_pi_t#
	hat_gsubc = w_hat1 * hat_pi_c;#
	hat_gsubt = w_hat3 * hat_pi_t;#
	# ESTIMATE THETA0 AND THETA1 with DR approach#
#
	theta0vec = rep(NA,length(w_hat1));#
	theta1vec = rep(NA,length(w_hat1));#
#
	for (i in 1:length(w_hat1)) {#
		thismax = max(hat_gsubc[i],hat_gsubt[i]);#
		theta0vec[i] = thismax - hat_gsubc[i];#
		theta1vec[i] = thismax - hat_gsubt[i];#
	}#
#
	DRapproachTheta0 = mean(theta0vec)#
	seDRapproachTheta0 = sqrt(var(theta0vec)/length(theta0vec))#
#
	DRapproachTheta1 = mean(theta1vec)#
	seDRapproachTheta1 = sqrt(var(theta1vec)/length(theta1vec))#
#
	DRapproachTheta0#
	seDRapproachTheta0#
#
	DRapproachTheta1#
	seDRapproachTheta1#
	# ESTIMATE THETA0 AND THETA1 WITH LOGISTIC REGRESSION + JANES TREATMENTSELECTION PACKAGE#
#
	myx1cs = myxcs[1,];#
	myx2cs = myxcs[2,];#
	myx1ts = myxts[1,];#
	myx2ts = myxts[2,];#
	myx1All = c(myx1cs,myx1ts)#
	myx2All = c(myx2cs,myx2ts)#
	myresp = c(mycMresp,mytMresp)#
	mytrtAll = c(rep(0,length(mycMresp)),rep(1,length(mytMresp)));#
	mylogreg = glm(myresp ~ myx1All + myx2All + mytrtAll + #
		myx1All:mytrtAll + myx2All:mytrtAll, family=binomial(link='logit'))#
#
    beta0c = coef(mylogreg)[1]#
    beta0t = coef(mylogreg)[2]#
	beta3 = coef(mylogreg)[5]#
	beta4 = coef(mylogreg)[6]#
	mydim1vec = beta3/sqrt(beta3^2+beta4^2);#
	mydim2vec = beta4/sqrt(beta3^2+beta4^2);#
    mynewxcM1s = as.vector(c(mydim1vec,mydim2vec) %*% myxcM1s) #
    mynewxtM1s = as.vector(c(mydim1vec,mydim2vec) %*% myxtM1s)#
    mynewxcM0s = as.vector(c(mydim1vec,mydim2vec) %*% myxcM0s)#
    mynewxtM0s = as.vector(c(mydim1vec,mydim2vec) %*% myxtM0s)#
    # boxplot(mynewxcM1s,mynewxtM1s,mynewxcM0s,mynewxtM0s)#
	library(TreatmentSelection)#
#
	myoutcomes = c(rep(1,length(mynewxcM1s)),rep(0,length(mynewxcM0s)),rep(1,length(mynewxtM1s)),rep(0,length(mynewxtM0s)));#
	mymarker = c(mynewxcM1s,mynewxcM0s,mynewxtM1s,mynewxtM0s);#
	mytreatment = c(rep(0,myn/2),rep(1,myn/2))#
#
	datafraforjanes = data.frame(event=myoutcomes,trt=mytreatment,Y1=mymarker);#
	mytrtsel = trtsel(event ~ Y1*trt,treatment.name="trt",data=datafraforjanes,#
	                      study.design="RCT",family=binomial("logit"),default.trt="trt all")#
	tmp = evaluate(mytrtsel,bootstraps=1000);#
#
	mytrtsel#
#
	tmp#
#
	JanesTheta1 = tmp$estimates$Theta.emp#
#
	JanesTheta1#
#
	datafraforjanes = data.frame(event=myoutcomes,trt=mytreatment,Y1=mymarker);#
	mytrtsel = trtsel(event ~ Y1*trt,treatment.name="trt",data=datafraforjanes,#
	                      study.design="RCT",family=binomial("logit"),default.trt="trt none")#
	tmp = evaluate(mytrtsel,bootstraps=1000);#
#
	JanesTheta0 = tmp$estimates$Theta.emp#
	JanesTheta0#
#
	DRtheta0s[thismc] = DRapproachTheta0;#
	DRtheta1s[thismc] = DRapproachTheta1;#
	HJtheta0s[thismc] = JanesTheta0; #
	HJtheta1s[thismc] = JanesTheta1;#
}#
#
write.table(cbind(DRtheta0s,DRtheta1s,HJtheta0s,HJtheta1s),file="simStepshapeAreamyn3200MCRUNS100.txt")#
#
cbind(DRtheta0s,DRtheta1s,HJtheta0s,HJtheta1s)
# SIMULATE DATA FROM THE MODEL#
#
thismethod = "uLSIF"#
myn = 3200;#
MCRUNS = 3;#
#
myregion = function(x1,x2) {#
	myreturn = -1;#
	condA = (0.1464 < x1);#
	condB = (x1 < 0.8536);#
	condC = (0.1464 < x2);#
	condD = (x2 < 0.8536);#
	myreturn = 2 - (condA*condB*condC*condD)#
	myreturn;#
}#
#
myalphasubcM1s = c(0.2,1.8)#
myalphasubcM0s = 2-myalphasubcM1s;#
#
myalphasubtM1s = c(1.8,0.2)#
myalphasubtM0s = 2-myalphasubtM1s;#
#
mybaseareas = c(0.5,0.5)#
#
mycM1probs = myalphasubcM1s*mybaseareas;#
mycM0probs = myalphasubcM0s*mybaseareas;#
mytM1probs = myalphasubtM1s*mybaseareas;#
mytM0probs = myalphasubtM0s*mybaseareas;#
#
sum(mycM1probs);#
sum(mycM0probs);#
sum(mytM1probs)#
sum(mytM0probs)#
#
mycM1probs;#
mycM0probs;#
mytM1probs#
mytM0probs#
#
mycM1grps = rmultinom(myn/4,1,mycM1probs)#
mycM0grps = rmultinom(myn/4,1,mycM0probs)#
mytM1grps = rmultinom(myn/4,1,mytM1probs)#
mytM0grps = rmultinom(myn/4,1,mytM0probs)#
#
sum(mycM1grps[1,])#
sum(mycM0grps[1,])#
sum(mytM1grps[1,])#
sum(mytM0grps[1,])#
#
myxcM1s = rep(NA,myn/4)#
myxtM1s = rep(NA,myn/4)#
myxcM0s = rep(NA,myn/4)#
myxtM0s = rep(NA,myn/4)#
#
DRtheta0s = rep(NA,MCRUNS)#
DRtheta1s = rep(NA,MCRUNS)#
HJtheta0s = rep(NA,MCRUNS)#
HJtheta1s = rep(NA,MCRUNS)#
mygeneratefromArea1 = function() {#
	xtry = c(runif(1),runif(1));#
	while (myregion(xtry[1],xtry[2]) != 1) { xtry = c(runif(1),runif(1))  }#
	return(xtry);#
}#
mygeneratefromArea2 = function() {#
	xtry = c(runif(1),runif(1));#
	while (myregion(xtry[1],xtry[2]) != 2) { xtry = c(runif(1),runif(1))  }#
	return(xtry);#
}#
# RETURN A 2 BY N MATRIX OF BIOMARKER VALUES#
generateCM1rnvs = function(numberneeded) {#
	myreturn = matrix(rep(NA, 2*numberneeded),nrow=2);#
#
	for (i in 1:numberneeded) {#
		myx = c(NA,NA);#
		thismultinom = rmultinom(1,1,mycM1probs);#
#
		if (as.vector(thismultinom)[1] == 1 ) { myx <- mygeneratefromArea1() }#
		if (as.vector(thismultinom)[2] == 1 ) { myx <- mygeneratefromArea2() }#
		myreturn[,i] = myx;#
	}#
	myreturn;#
}#
#
generateTM1rnvs = function(numberneeded) {#
	myreturn = matrix(rep(NA, 2*numberneeded),nrow=2);#
#
	for (i in 1:numberneeded) {#
		myx = c(NA,NA);#
		thismultinom = rmultinom(1,1,mytM1probs);#
#
		if (as.vector(thismultinom)[1] == 1 ) { myx <- mygeneratefromArea1() }#
		if (as.vector(thismultinom)[2] == 1 ) { myx <- mygeneratefromArea2() }#
		myreturn[,i] = myx;#
	}#
	myreturn;#
}#
#
generateCM0rnvs = function(numberneeded) {#
	myreturn = matrix(rep(NA, 2*numberneeded),nrow=2);#
#
	for (i in 1:numberneeded) {#
		myx = c(NA,NA);#
		thismultinom = rmultinom(1,1,mycM0probs);#
#
		if (as.vector(thismultinom)[1] == 1 ) { myx <- mygeneratefromArea1() }#
		if (as.vector(thismultinom)[2] == 1 ) { myx <- mygeneratefromArea2() }#
		myreturn[,i] = myx;#
	}#
	myreturn;#
}#
generateTM0rnvs = function(numberneeded) {#
	myreturn = matrix(rep(NA, 2*numberneeded),nrow=2);#
#
	for (i in 1:numberneeded) {#
		myx = c(NA,NA);#
		thismultinom = rmultinom(1,1,mytM0probs);#
#
		if (as.vector(thismultinom)[1] == 1 ) { myx <- mygeneratefromArea1() }#
		if (as.vector(thismultinom)[2] == 1 ) { myx <- mygeneratefromArea2() }#
		myreturn[,i] = myx;#
	}#
	myreturn;#
}#
for (thismc in 1:MCRUNS)  {#
    mytrt1ctrl0 = rbinom(myn,1,0.5);  # indicates randomization to trt/ctrl#
    myM1is1M0is0 = rbinom(myn,1,0.5); # the conditional probabilities of M1 and M0 are 0.5 for both trt and control#
#
    NumberOfCM1 = length(intersect(which(mytrt1ctrl0==0),which(myM1is1M0is0==1)))#
    NumberOfTM1 = length(intersect(which(mytrt1ctrl0==1),which(myM1is1M0is0==1)))#
    NumberOfCM0 = length(intersect(which(mytrt1ctrl0==0),which(myM1is1M0is0==0)))#
    NumberOfTM0 = length(intersect(which(mytrt1ctrl0==1),which(myM1is1M0is0==0)))#
#
    myxcM1s = generateCM1rnvs(NumberOfCM1)#
    myxtM1s = generateTM1rnvs(NumberOfTM1)#
    myxcM0s = generateCM0rnvs(NumberOfCM0)#
    myxtM0s = generateTM0rnvs(NumberOfTM0)#
#
	apply(myxcM1s,1,mean)#
	apply(myxtM1s,1,mean)#
	apply(myxcM0s,1,mean)#
	apply(myxtM0s,1,mean)#
	myxcs = cbind(myxcM0s,myxcM1s);#
	myxts = cbind(myxtM0s,myxtM1s);#
	myxmarginal = cbind(myxcs,myxts)#
#
	mycMresp = c(rep(0,NumberOfCM0),rep(1,NumberOfCM1)) #
	mytMresp = c(rep(0,NumberOfTM0),rep(1,NumberOfTM1)) #
	# DENSITY RATIO ESTIMATION#
#
	install.packages("densratio")#
	library(densratio)#
	densratio_obj1 = densratio(t(cbind(myxcM1s,myxcM1s,myxcM1s,myxcM1s)),t(myxmarginal),method=thismethod)#
	densratio_obj3 = densratio(t(cbind(myxtM1s,myxtM1s,myxtM1s,myxtM1s)),t(myxmarginal),method=thismethod)#
#
	new_x = t(matrix(runif(2000),nrow=2));#
#
	w_hat1 = densratio_obj1$compute_density_ratio(new_x);#
	w_hat3 = densratio_obj3$compute_density_ratio(new_x);#
    # library(rgl)#
    # plot3d(new_x[,1],new_x[,2],w_hat1)#
	densratio_obj1#
#
	densratio_obj3#
	hat_pi_c = length(myxcM1s)/(length(myxcM1s)+length(myxcM0s))#
	hat_pi_t = length(myxtM1s)/(length(myxtM1s)+length(myxtM0s))#
#
	hat_pi_c#
	hat_pi_t#
	hat_gsubc = w_hat1 * hat_pi_c;#
	hat_gsubt = w_hat3 * hat_pi_t;#
	# ESTIMATE THETA0 AND THETA1 with DR approach#
#
	theta0vec = rep(NA,length(w_hat1));#
	theta1vec = rep(NA,length(w_hat1));#
#
	for (i in 1:length(w_hat1)) {#
		thismax = max(hat_gsubc[i],hat_gsubt[i]);#
		theta0vec[i] = thismax - hat_gsubc[i];#
		theta1vec[i] = thismax - hat_gsubt[i];#
	}#
#
	DRapproachTheta0 = mean(theta0vec)#
	seDRapproachTheta0 = sqrt(var(theta0vec)/length(theta0vec))#
#
	DRapproachTheta1 = mean(theta1vec)#
	seDRapproachTheta1 = sqrt(var(theta1vec)/length(theta1vec))#
#
	DRapproachTheta0#
	seDRapproachTheta0#
#
	DRapproachTheta1#
	seDRapproachTheta1#
	# ESTIMATE THETA0 AND THETA1 WITH LOGISTIC REGRESSION + JANES TREATMENTSELECTION PACKAGE#
#
	myx1cs = myxcs[1,];#
	myx2cs = myxcs[2,];#
	myx1ts = myxts[1,];#
	myx2ts = myxts[2,];#
	myx1All = c(myx1cs,myx1ts)#
	myx2All = c(myx2cs,myx2ts)#
	myresp = c(mycMresp,mytMresp)#
	mytrtAll = c(rep(0,length(mycMresp)),rep(1,length(mytMresp)));#
	mylogreg = glm(myresp ~ myx1All + myx2All + mytrtAll + #
		myx1All:mytrtAll + myx2All:mytrtAll, family=binomial(link='logit'))#
#
    beta0c = coef(mylogreg)[1]#
    beta0t = coef(mylogreg)[2]#
	beta3 = coef(mylogreg)[5]#
	beta4 = coef(mylogreg)[6]#
	mydim1vec = beta3/sqrt(beta3^2+beta4^2);#
	mydim2vec = beta4/sqrt(beta3^2+beta4^2);#
    mynewxcM1s = as.vector(c(mydim1vec,mydim2vec) %*% myxcM1s) #
    mynewxtM1s = as.vector(c(mydim1vec,mydim2vec) %*% myxtM1s)#
    mynewxcM0s = as.vector(c(mydim1vec,mydim2vec) %*% myxcM0s)#
    mynewxtM0s = as.vector(c(mydim1vec,mydim2vec) %*% myxtM0s)#
    # boxplot(mynewxcM1s,mynewxtM1s,mynewxcM0s,mynewxtM0s)#
	library(TreatmentSelection)#
#
	myoutcomes = c(rep(1,length(mynewxcM1s)),rep(0,length(mynewxcM0s)),rep(1,length(mynewxtM1s)),rep(0,length(mynewxtM0s)));#
	mymarker = c(mynewxcM1s,mynewxcM0s,mynewxtM1s,mynewxtM0s);#
	mytreatment = c(rep(0,myn/2),rep(1,myn/2))#
#
	datafraforjanes = data.frame(event=myoutcomes,trt=mytreatment,Y1=mymarker);#
	mytrtsel = trtsel(event ~ Y1*trt,treatment.name="trt",data=datafraforjanes,#
	                      study.design="RCT",family=binomial("logit"),default.trt="trt all")#
	tmp = evaluate(mytrtsel,bootstraps=1000);#
#
	mytrtsel#
#
	tmp#
#
	JanesTheta1 = tmp$estimates$Theta.emp#
#
	JanesTheta1#
#
	datafraforjanes = data.frame(event=myoutcomes,trt=mytreatment,Y1=mymarker);#
	mytrtsel = trtsel(event ~ Y1*trt,treatment.name="trt",data=datafraforjanes,#
	                      study.design="RCT",family=binomial("logit"),default.trt="trt none")#
	tmp = evaluate(mytrtsel,bootstraps=1000);#
#
	JanesTheta0 = tmp$estimates$Theta.emp#
	JanesTheta0#
#
	DRtheta0s[thismc] = DRapproachTheta0;#
	DRtheta1s[thismc] = DRapproachTheta1;#
	HJtheta0s[thismc] = JanesTheta0; #
	HJtheta1s[thismc] = JanesTheta1;#
}#
#
write.table(cbind(DRtheta0s,DRtheta1s,HJtheta0s,HJtheta1s),file="simStepshapeAreamyn3200MCRUNS100.txt")#
#
cbind(DRtheta0s,DRtheta1s,HJtheta0s,HJtheta1s)
library(densratio)
densratio
# SIMULATE DATA FROM THE MODEL#
#
thismethod = "uLSIF"#
myn = 800;#
MCRUNS = 3;#
mydim = 10;#
#
myregion = function(x) {#
	myreturn = -1;#
	xsum = sum(x);#
	if (xsum < (mydim/2)) { myreturn = 1; }#
	else { myreturn = 2; }#
}#
#
myalphasubcM1s = c(0.2,1.8)#
myalphasubcM0s = 2-myalphasubcM1s;#
#
myalphasubtM1s = c(1.8,0.2)#
myalphasubtM0s = 2-myalphasubtM1s;#
#
mybaseareas = c(0.5,0.5)#
#
mycM1probs = myalphasubcM1s*mybaseareas;#
mycM0probs = myalphasubcM0s*mybaseareas;#
mytM1probs = myalphasubtM1s*mybaseareas;#
mytM0probs = myalphasubtM0s*mybaseareas;#
#
sum(mycM1probs);#
sum(mycM0probs);#
sum(mytM1probs)#
sum(mytM0probs)#
#
mycM1probs;#
mycM0probs;#
mytM1probs#
mytM0probs
mycM1probs
runif(10)
# SIMULATE DATA FROM THE MODEL#
#
thismethod = "uLSIF"#
myn = 800;#
MCRUNS = 3;#
mydim = 10;#
#
myregion = function(x) {#
	myreturn = -1;#
	xsum = sum(x);#
	if (xsum < (mydim/2)) { myreturn = 1; }#
	else { myreturn = 2; }#
}#
#
myalphasubcM1s = c(0.2,1.8)#
myalphasubcM0s = 2-myalphasubcM1s;#
#
myalphasubtM1s = c(1.8,0.2)#
myalphasubtM0s = 2-myalphasubtM1s;#
#
mybaseareas = c(0.5,0.5)#
#
mycM1probs = myalphasubcM1s*mybaseareas;#
mycM0probs = myalphasubcM0s*mybaseareas;#
mytM1probs = myalphasubtM1s*mybaseareas;#
mytM0probs = myalphasubtM0s*mybaseareas;#
#
sum(mycM1probs);#
sum(mycM0probs);#
sum(mytM1probs)#
sum(mytM0probs)#
#
mycM1probs;#
mycM0probs;#
mytM1probs#
mytM0probs#
#
myxcM1s = rep(NA,myn/4)#
myxtM1s = rep(NA,myn/4)#
myxcM0s = rep(NA,myn/4)#
myxtM0s = rep(NA,myn/4)#
#
DRtheta0s = rep(NA,MCRUNS)#
DRtheta1s = rep(NA,MCRUNS)#
HJtheta0s = rep(NA,MCRUNS)#
HJtheta1s = rep(NA,MCRUNS)#
mygeneratefromArea1 = function() {#
	xtry = runif(mydim);#
	while (sum(xtry) > (mydim/2)) { xtry = runif(mydim)  }#
	return(xtry);#
}#
mygeneratefromArea2 = function() {#
	xtry = runif(mydim);#
	while (sum(xtry) < (mydim/2)) { xtry = runif(mydim)  }#
	return(xtry);#
}#
# RETURN A mydim BY N MATRIX OF BIOMARKER VALUES#
generateCM1rnvs = function(numberneeded) {#
	myreturn = matrix(rep(NA, mydim*numberneeded),nrow=mydim);#
#
	for (i in 1:numberneeded) {#
		myx = c(NA,NA);#
		thismultinom = rmultinom(1,1,mycM1probs);#
#
		if (as.vector(thismultinom)[1] == 1 ) { myx <- mygeneratefromArea1() }#
		if (as.vector(thismultinom)[2] == 1 ) { myx <- mygeneratefromArea2() }#
		myreturn[,i] = myx;#
	}#
	myreturn;#
}#
#
generateTM1rnvs = function(numberneeded) {#
	myreturn = matrix(rep(NA, mydim*numberneeded),nrow=mydim);#
#
	for (i in 1:numberneeded) {#
		myx = c(NA,NA);#
		thismultinom = rmultinom(1,1,mytM1probs);#
#
		if (as.vector(thismultinom)[1] == 1 ) { myx <- mygeneratefromArea1() }#
		if (as.vector(thismultinom)[2] == 1 ) { myx <- mygeneratefromArea2() }#
		myreturn[,i] = myx;#
	}#
	myreturn;#
}#
#
generateCM0rnvs = function(numberneeded) {#
	myreturn = matrix(rep(NA, mydim*numberneeded),nrow=mydim);#
#
	for (i in 1:numberneeded) {#
		myx = c(NA,NA);#
		thismultinom = rmultinom(1,1,mycM0probs);#
#
		if (as.vector(thismultinom)[1] == 1 ) { myx <- mygeneratefromArea1() }#
		if (as.vector(thismultinom)[2] == 1 ) { myx <- mygeneratefromArea2() }#
		myreturn[,i] = myx;#
	}#
	myreturn;#
}#
generateTM0rnvs = function(numberneeded) {#
	myreturn = matrix(rep(NA, mydim*numberneeded),nrow=mydim);#
#
	for (i in 1:numberneeded) {#
		myx = c(NA,NA);#
		thismultinom = rmultinom(1,1,mytM0probs);#
#
		if (as.vector(thismultinom)[1] == 1 ) { myx <- mygeneratefromArea1() }#
		if (as.vector(thismultinom)[2] == 1 ) { myx <- mygeneratefromArea2() }#
		myreturn[,i] = myx;#
	}#
	myreturn;#
}#
for (thismc in 1:MCRUNS)  {#
    mytrt1ctrl0 = rbinom(myn,1,0.5);  # indicates randomization to trt/ctrl#
    myM1is1M0is0 = rbinom(myn,1,0.5); # the conditional probabilities of M1 and M0 are 0.5 for both trt and control#
#
    NumberOfCM1 = length(intersect(which(mytrt1ctrl0==0),which(myM1is1M0is0==1)))#
    NumberOfTM1 = length(intersect(which(mytrt1ctrl0==1),which(myM1is1M0is0==1)))#
    NumberOfCM0 = length(intersect(which(mytrt1ctrl0==0),which(myM1is1M0is0==0)))#
    NumberOfTM0 = length(intersect(which(mytrt1ctrl0==1),which(myM1is1M0is0==0)))#
#
    myxcM1s = generateCM1rnvs(NumberOfCM1)#
    myxtM1s = generateTM1rnvs(NumberOfTM1)#
    myxcM0s = generateCM0rnvs(NumberOfCM0)#
    myxtM0s = generateTM0rnvs(NumberOfTM0)#
#
	apply(myxcM1s,1,mean)#
	apply(myxtM1s,1,mean)#
	apply(myxcM0s,1,mean)#
	apply(myxtM0s,1,mean)#
	myxcs = cbind(myxcM0s,myxcM1s);#
	myxts = cbind(myxtM0s,myxtM1s);#
	myxmarginal = cbind(myxcs,myxts)#
#
	mycMresp = c(rep(0,NumberOfCM0),rep(1,NumberOfCM1)) #
	mytMresp = c(rep(0,NumberOfTM0),rep(1,NumberOfTM1)) #
	# DENSITY RATIO ESTIMATION#
#
	install.packages("densratio")#
	library(densratio)#
	densratio_obj1 = densratio(t(cbind(myxcM1s,myxcM1s,myxcM1s,myxcM1s)),t(myxmarginal),method=thismethod)#
	densratio_obj3 = densratio(t(cbind(myxtM1s,myxtM1s,myxtM1s,myxtM1s)),t(myxmarginal),method=thismethod)#
#
	new_x = t(matrix(runif(2000),nrow=2));#
#
	w_hat1 = densratio_obj1$compute_density_ratio(new_x);#
	w_hat3 = densratio_obj3$compute_density_ratio(new_x);#
    # library(rgl)#
    # plot3d(new_x[,1],new_x[,2],w_hat1)#
	densratio_obj1#
#
	densratio_obj3#
	hat_pi_c = length(myxcM1s)/(length(myxcM1s)+length(myxcM0s))#
	hat_pi_t = length(myxtM1s)/(length(myxtM1s)+length(myxtM0s))#
#
	hat_pi_c#
	hat_pi_t#
	hat_gsubc = w_hat1 * hat_pi_c;#
	hat_gsubt = w_hat3 * hat_pi_t;#
	# ESTIMATE THETA0 AND THETA1 with DR approach#
#
	theta0vec = rep(NA,length(w_hat1));#
	theta1vec = rep(NA,length(w_hat1));#
#
	for (i in 1:length(w_hat1)) {#
		thismax = max(hat_gsubc[i],hat_gsubt[i]);#
		theta0vec[i] = thismax - hat_gsubc[i];#
		theta1vec[i] = thismax - hat_gsubt[i];#
	}#
#
	DRapproachTheta0 = mean(theta0vec)#
	seDRapproachTheta0 = sqrt(var(theta0vec)/length(theta0vec))#
#
	DRapproachTheta1 = mean(theta1vec)#
	seDRapproachTheta1 = sqrt(var(theta1vec)/length(theta1vec))#
#
	DRapproachTheta0#
	seDRapproachTheta0#
#
	DRapproachTheta1#
	seDRapproachTheta1#
	# ESTIMATE THETA0 AND THETA1 WITH LOGISTIC REGRESSION + JANES TREATMENTSELECTION PACKAGE#
#
	# myx1cs = myxcs[1,];#
	# myx2cs = myxcs[2,];#
	# myx1ts = myxts[1,];#
	# myx2ts = myxts[2,];#
	# myx1All = c(myx1cs,myx1ts)#
	# myx2All = c(myx2cs,myx2ts)#
	# myresp = c(mycMresp,mytMresp)#
	# mytrtAll = c(rep(0,length(mycMresp)),rep(1,length(mytMresp)));#
	# mylogreg = glm(myresp ~ myx1All + myx2All + mytrtAll + #
	# 	myx1All:mytrtAll + myx2All:mytrtAll, family=binomial(link='logit'))#
#
 #    beta0c = coef(mylogreg)[1]#
 #    beta0t = coef(mylogreg)[2]#
	# beta3 = coef(mylogreg)[5]#
	# beta4 = coef(mylogreg)[6]#
	# mydim1vec = beta3/sqrt(beta3^2+beta4^2);#
	# mydim2vec = beta4/sqrt(beta3^2+beta4^2);#
 #    mynewxcM1s = as.vector(c(mydim1vec,mydim2vec) %*% myxcM1s) #
 #    mynewxtM1s = as.vector(c(mydim1vec,mydim2vec) %*% myxtM1s)#
 #    mynewxcM0s = as.vector(c(mydim1vec,mydim2vec) %*% myxcM0s)#
 #    mynewxtM0s = as.vector(c(mydim1vec,mydim2vec) %*% myxtM0s)#
 #    # boxplot(mynewxcM1s,mynewxtM1s,mynewxcM0s,mynewxtM0s)#
	# library(TreatmentSelection)#
#
	# myoutcomes = c(rep(1,length(mynewxcM1s)),rep(0,length(mynewxcM0s)),rep(1,length(mynewxtM1s)),rep(0,length(mynewxtM0s)));#
	# mymarker = c(mynewxcM1s,mynewxcM0s,mynewxtM1s,mynewxtM0s);#
	# mytreatment = c(rep(0,myn/2),rep(1,myn/2))#
#
	# datafraforjanes = data.frame(event=myoutcomes,trt=mytreatment,Y1=mymarker);#
	# mytrtsel = trtsel(event ~ Y1*trt,treatment.name="trt",data=datafraforjanes,#
	#                       study.design="RCT",family=binomial("logit"),default.trt="trt all")#
	# tmp = evaluate(mytrtsel,bootstraps=1000);#
#
	# mytrtsel#
#
	# tmp#
#
	# JanesTheta1 = tmp$estimates$Theta.emp#
#
	# JanesTheta1#
#
	# datafraforjanes = data.frame(event=myoutcomes,trt=mytreatment,Y1=mymarker);#
	# mytrtsel = trtsel(event ~ Y1*trt,treatment.name="trt",data=datafraforjanes,#
	#                       study.design="RCT",family=binomial("logit"),default.trt="trt none")#
	# tmp = evaluate(mytrtsel,bootstraps=1000);#
#
	# JanesTheta0 = tmp$estimates$Theta.emp#
	# JanesTheta0#
#
	DRtheta0s[thismc] = DRapproachTheta0;#
	DRtheta1s[thismc] = DRapproachTheta1;#
	# HJtheta0s[thismc] = JanesTheta0; #
	# HJtheta1s[thismc] = JanesTheta1;#
}#
#
write.table(cbind(DRtheta0s,DRtheta1s,HJtheta0s,HJtheta1s),file="simTriangleAreamyn3200MCRUNS100.txt")
DRtheta0s
DRtheta1s
# SIMULATE DATA FROM THE MODEL#
#
thismethod = "uLSIF"#
myn = 3200;#
MCRUNS = 3;#
mydim = 10;#
#
myregion = function(x) {#
	myreturn = -1;#
	xsum = sum(x);#
	if (xsum < (mydim/2)) { myreturn = 1; }#
	else { myreturn = 2; }#
}#
#
myalphasubcM1s = c(0.2,1.8)#
myalphasubcM0s = 2-myalphasubcM1s;#
#
myalphasubtM1s = c(1.8,0.2)#
myalphasubtM0s = 2-myalphasubtM1s;#
#
mybaseareas = c(0.5,0.5)#
#
mycM1probs = myalphasubcM1s*mybaseareas;#
mycM0probs = myalphasubcM0s*mybaseareas;#
mytM1probs = myalphasubtM1s*mybaseareas;#
mytM0probs = myalphasubtM0s*mybaseareas;#
#
sum(mycM1probs);#
sum(mycM0probs);#
sum(mytM1probs)#
sum(mytM0probs)#
#
mycM1probs;#
mycM0probs;#
mytM1probs#
mytM0probs#
#
myxcM1s = rep(NA,myn/4)#
myxtM1s = rep(NA,myn/4)#
myxcM0s = rep(NA,myn/4)#
myxtM0s = rep(NA,myn/4)#
#
DRtheta0s = rep(NA,MCRUNS)#
DRtheta1s = rep(NA,MCRUNS)#
HJtheta0s = rep(NA,MCRUNS)#
HJtheta1s = rep(NA,MCRUNS)#
mygeneratefromArea1 = function() {#
	xtry = runif(mydim);#
	while (sum(xtry) > (mydim/2)) { xtry = runif(mydim)  }#
	return(xtry);#
}#
mygeneratefromArea2 = function() {#
	xtry = runif(mydim);#
	while (sum(xtry) < (mydim/2)) { xtry = runif(mydim)  }#
	return(xtry);#
}#
# RETURN A mydim BY N MATRIX OF BIOMARKER VALUES#
generateCM1rnvs = function(numberneeded) {#
	myreturn = matrix(rep(NA, mydim*numberneeded),nrow=mydim);#
#
	for (i in 1:numberneeded) {#
		myx = c(NA,NA);#
		thismultinom = rmultinom(1,1,mycM1probs);#
#
		if (as.vector(thismultinom)[1] == 1 ) { myx <- mygeneratefromArea1() }#
		if (as.vector(thismultinom)[2] == 1 ) { myx <- mygeneratefromArea2() }#
		myreturn[,i] = myx;#
	}#
	myreturn;#
}#
#
generateTM1rnvs = function(numberneeded) {#
	myreturn = matrix(rep(NA, mydim*numberneeded),nrow=mydim);#
#
	for (i in 1:numberneeded) {#
		myx = c(NA,NA);#
		thismultinom = rmultinom(1,1,mytM1probs);#
#
		if (as.vector(thismultinom)[1] == 1 ) { myx <- mygeneratefromArea1() }#
		if (as.vector(thismultinom)[2] == 1 ) { myx <- mygeneratefromArea2() }#
		myreturn[,i] = myx;#
	}#
	myreturn;#
}#
#
generateCM0rnvs = function(numberneeded) {#
	myreturn = matrix(rep(NA, mydim*numberneeded),nrow=mydim);#
#
	for (i in 1:numberneeded) {#
		myx = c(NA,NA);#
		thismultinom = rmultinom(1,1,mycM0probs);#
#
		if (as.vector(thismultinom)[1] == 1 ) { myx <- mygeneratefromArea1() }#
		if (as.vector(thismultinom)[2] == 1 ) { myx <- mygeneratefromArea2() }#
		myreturn[,i] = myx;#
	}#
	myreturn;#
}#
generateTM0rnvs = function(numberneeded) {#
	myreturn = matrix(rep(NA, mydim*numberneeded),nrow=mydim);#
#
	for (i in 1:numberneeded) {#
		myx = c(NA,NA);#
		thismultinom = rmultinom(1,1,mytM0probs);#
#
		if (as.vector(thismultinom)[1] == 1 ) { myx <- mygeneratefromArea1() }#
		if (as.vector(thismultinom)[2] == 1 ) { myx <- mygeneratefromArea2() }#
		myreturn[,i] = myx;#
	}#
	myreturn;#
}#
for (thismc in 1:MCRUNS)  {#
    mytrt1ctrl0 = rbinom(myn,1,0.5);  # indicates randomization to trt/ctrl#
    myM1is1M0is0 = rbinom(myn,1,0.5); # the conditional probabilities of M1 and M0 are 0.5 for both trt and control#
#
    NumberOfCM1 = length(intersect(which(mytrt1ctrl0==0),which(myM1is1M0is0==1)))#
    NumberOfTM1 = length(intersect(which(mytrt1ctrl0==1),which(myM1is1M0is0==1)))#
    NumberOfCM0 = length(intersect(which(mytrt1ctrl0==0),which(myM1is1M0is0==0)))#
    NumberOfTM0 = length(intersect(which(mytrt1ctrl0==1),which(myM1is1M0is0==0)))#
#
    myxcM1s = generateCM1rnvs(NumberOfCM1)#
    myxtM1s = generateTM1rnvs(NumberOfTM1)#
    myxcM0s = generateCM0rnvs(NumberOfCM0)#
    myxtM0s = generateTM0rnvs(NumberOfTM0)#
#
	apply(myxcM1s,1,mean)#
	apply(myxtM1s,1,mean)#
	apply(myxcM0s,1,mean)#
	apply(myxtM0s,1,mean)#
	myxcs = cbind(myxcM0s,myxcM1s);#
	myxts = cbind(myxtM0s,myxtM1s);#
	myxmarginal = cbind(myxcs,myxts)#
#
	mycMresp = c(rep(0,NumberOfCM0),rep(1,NumberOfCM1)) #
	mytMresp = c(rep(0,NumberOfTM0),rep(1,NumberOfTM1)) #
	# DENSITY RATIO ESTIMATION#
#
	install.packages("densratio")#
	library(densratio)#
	densratio_obj1 = densratio(t(cbind(myxcM1s,myxcM1s,myxcM1s,myxcM1s)),t(myxmarginal),method=thismethod)#
	densratio_obj3 = densratio(t(cbind(myxtM1s,myxtM1s,myxtM1s,myxtM1s)),t(myxmarginal),method=thismethod)#
#
	new_x = t(matrix(runif(2000),nrow=2));#
#
	w_hat1 = densratio_obj1$compute_density_ratio(new_x);#
	w_hat3 = densratio_obj3$compute_density_ratio(new_x);#
    # library(rgl)#
    # plot3d(new_x[,1],new_x[,2],w_hat1)#
	densratio_obj1#
#
	densratio_obj3#
	hat_pi_c = length(myxcM1s)/(length(myxcM1s)+length(myxcM0s))#
	hat_pi_t = length(myxtM1s)/(length(myxtM1s)+length(myxtM0s))#
#
	hat_pi_c#
	hat_pi_t#
	hat_gsubc = w_hat1 * hat_pi_c;#
	hat_gsubt = w_hat3 * hat_pi_t;#
	# ESTIMATE THETA0 AND THETA1 with DR approach#
#
	theta0vec = rep(NA,length(w_hat1));#
	theta1vec = rep(NA,length(w_hat1));#
#
	for (i in 1:length(w_hat1)) {#
		thismax = max(hat_gsubc[i],hat_gsubt[i]);#
		theta0vec[i] = thismax - hat_gsubc[i];#
		theta1vec[i] = thismax - hat_gsubt[i];#
	}#
#
	DRapproachTheta0 = mean(theta0vec)#
	seDRapproachTheta0 = sqrt(var(theta0vec)/length(theta0vec))#
#
	DRapproachTheta1 = mean(theta1vec)#
	seDRapproachTheta1 = sqrt(var(theta1vec)/length(theta1vec))#
#
	DRapproachTheta0#
	seDRapproachTheta0#
#
	DRapproachTheta1#
	seDRapproachTheta1#
	# ESTIMATE THETA0 AND THETA1 WITH LOGISTIC REGRESSION + JANES TREATMENTSELECTION PACKAGE#
#
	# myx1cs = myxcs[1,];#
	# myx2cs = myxcs[2,];#
	# myx1ts = myxts[1,];#
	# myx2ts = myxts[2,];#
	# myx1All = c(myx1cs,myx1ts)#
	# myx2All = c(myx2cs,myx2ts)#
	# myresp = c(mycMresp,mytMresp)#
	# mytrtAll = c(rep(0,length(mycMresp)),rep(1,length(mytMresp)));#
	# mylogreg = glm(myresp ~ myx1All + myx2All + mytrtAll + #
	# 	myx1All:mytrtAll + myx2All:mytrtAll, family=binomial(link='logit'))#
#
 #    beta0c = coef(mylogreg)[1]#
 #    beta0t = coef(mylogreg)[2]#
	# beta3 = coef(mylogreg)[5]#
	# beta4 = coef(mylogreg)[6]#
	# mydim1vec = beta3/sqrt(beta3^2+beta4^2);#
	# mydim2vec = beta4/sqrt(beta3^2+beta4^2);#
 #    mynewxcM1s = as.vector(c(mydim1vec,mydim2vec) %*% myxcM1s) #
 #    mynewxtM1s = as.vector(c(mydim1vec,mydim2vec) %*% myxtM1s)#
 #    mynewxcM0s = as.vector(c(mydim1vec,mydim2vec) %*% myxcM0s)#
 #    mynewxtM0s = as.vector(c(mydim1vec,mydim2vec) %*% myxtM0s)#
 #    # boxplot(mynewxcM1s,mynewxtM1s,mynewxcM0s,mynewxtM0s)#
	# library(TreatmentSelection)#
#
	# myoutcomes = c(rep(1,length(mynewxcM1s)),rep(0,length(mynewxcM0s)),rep(1,length(mynewxtM1s)),rep(0,length(mynewxtM0s)));#
	# mymarker = c(mynewxcM1s,mynewxcM0s,mynewxtM1s,mynewxtM0s);#
	# mytreatment = c(rep(0,myn/2),rep(1,myn/2))#
#
	# datafraforjanes = data.frame(event=myoutcomes,trt=mytreatment,Y1=mymarker);#
	# mytrtsel = trtsel(event ~ Y1*trt,treatment.name="trt",data=datafraforjanes,#
	#                       study.design="RCT",family=binomial("logit"),default.trt="trt all")#
	# tmp = evaluate(mytrtsel,bootstraps=1000);#
#
	# mytrtsel#
#
	# tmp#
#
	# JanesTheta1 = tmp$estimates$Theta.emp#
#
	# JanesTheta1#
#
	# datafraforjanes = data.frame(event=myoutcomes,trt=mytreatment,Y1=mymarker);#
	# mytrtsel = trtsel(event ~ Y1*trt,treatment.name="trt",data=datafraforjanes,#
	#                       study.design="RCT",family=binomial("logit"),default.trt="trt none")#
	# tmp = evaluate(mytrtsel,bootstraps=1000);#
#
	# JanesTheta0 = tmp$estimates$Theta.emp#
	# JanesTheta0#
#
	DRtheta0s[thismc] = DRapproachTheta0;#
	DRtheta1s[thismc] = DRapproachTheta1;#
	# HJtheta0s[thismc] = JanesTheta0; #
	# HJtheta1s[thismc] = JanesTheta1;#
}#
#
write.table(cbind(DRtheta0s,DRtheta1s,HJtheta0s,HJtheta1s),file="simTriangleAreamyn3200MCRUNS100.txt")
DRtheta0s
DRtheta1s
help(glm)
mytrt1ctrl0 = rbinom(myn,1,0.5);  # indicates randomization to trt/ctrl#
    myM1is1M0is0 = rbinom(myn,1,0.5); # the conditional probabilities of M1 and M0 are 0.5 for both trt and control#
#
    NumberOfCM1 = length(intersect(which(mytrt1ctrl0==0),which(myM1is1M0is0==1)))#
    NumberOfTM1 = length(intersect(which(mytrt1ctrl0==1),which(myM1is1M0is0==1)))#
    NumberOfCM0 = length(intersect(which(mytrt1ctrl0==0),which(myM1is1M0is0==0)))#
    NumberOfTM0 = length(intersect(which(mytrt1ctrl0==1),which(myM1is1M0is0==0)))#
#
    myxcM1s = generateCM1rnvs(NumberOfCM1)#
    myxtM1s = generateTM1rnvs(NumberOfTM1)#
    myxcM0s = generateCM0rnvs(NumberOfCM0)#
    myxtM0s = generateTM0rnvs(NumberOfTM0)#
#
	apply(myxcM1s,1,mean)#
	apply(myxtM1s,1,mean)#
	apply(myxcM0s,1,mean)#
	apply(myxtM0s,1,mean)#
	myxcs = cbind(myxcM0s,myxcM1s);#
	myxts = cbind(myxtM0s,myxtM1s);#
	myxmarginal = cbind(myxcs,myxts)#
#
	mycMresp = c(rep(0,NumberOfCM0),rep(1,NumberOfCM1)) #
	mytMresp = c(rep(0,NumberOfTM0),rep(1,NumberOfTM1)) #
	# DENSITY RATIO ESTIMATION#
#
	install.packages("densratio")#
	library(densratio)#
	densratio_obj1 = densratio(t(cbind(myxcM1s,myxcM1s,myxcM1s,myxcM1s)),t(myxmarginal),method=thismethod)#
	densratio_obj3 = densratio(t(cbind(myxtM1s,myxtM1s,myxtM1s,myxtM1s)),t(myxmarginal),method=thismethod)#
#
	new_x = t(matrix(runif(2000),nrow=2));#
#
	w_hat1 = densratio_obj1$compute_density_ratio(new_x);#
	w_hat3 = densratio_obj3$compute_density_ratio(new_x);#
    # library(rgl)#
    # plot3d(new_x[,1],new_x[,2],w_hat1)#
	densratio_obj1#
#
	densratio_obj3#
	hat_pi_c = length(myxcM1s)/(length(myxcM1s)+length(myxcM0s))#
	hat_pi_t = length(myxtM1s)/(length(myxtM1s)+length(myxtM0s))#
#
	hat_pi_c#
	hat_pi_t#
	hat_gsubc = w_hat1 * hat_pi_c;#
	hat_gsubt = w_hat3 * hat_pi_t;#
	# ESTIMATE THETA0 AND THETA1 with DR approach#
#
	theta0vec = rep(NA,length(w_hat1));#
	theta1vec = rep(NA,length(w_hat1));#
#
	for (i in 1:length(w_hat1)) {#
		thismax = max(hat_gsubc[i],hat_gsubt[i]);#
		theta0vec[i] = thismax - hat_gsubc[i];#
		theta1vec[i] = thismax - hat_gsubt[i];#
	}#
#
	DRapproachTheta0 = mean(theta0vec)#
	seDRapproachTheta0 = sqrt(var(theta0vec)/length(theta0vec))#
#
	DRapproachTheta1 = mean(theta1vec)#
	seDRapproachTheta1 = sqrt(var(theta1vec)/length(theta1vec))#
#
	DRapproachTheta0#
	seDRapproachTheta0#
#
	DRapproachTheta1#
	seDRapproachTheta1#
	# ESTIMATE THETA0 AND THETA1 WITH LOGISTIC REGRESSION + JANES TREATMENTSELECTION PACKAGE#
#
	myxAll = c(myxcs,myxts)#
	myresp = c(mycMresp,mytMresp)#
	mytrtAll = c(rep(0,length(mycMresp)),rep(1,length(mytMresp)));#
	mylogreg = glm(myresp ~ myxAll + mytrtAll + myxAll:mytrtAll, family=binomial(link='logit'))
mytrt1ctrl0 = rbinom(myn,1,0.5);  # indicates randomization to trt/ctrl#
    myM1is1M0is0 = rbinom(myn,1,0.5); # the conditional probabilities of M1 and M0 are 0.5 for both trt and control#
#
    NumberOfCM1 = length(intersect(which(mytrt1ctrl0==0),which(myM1is1M0is0==1)))#
    NumberOfTM1 = length(intersect(which(mytrt1ctrl0==1),which(myM1is1M0is0==1)))#
    NumberOfCM0 = length(intersect(which(mytrt1ctrl0==0),which(myM1is1M0is0==0)))#
    NumberOfTM0 = length(intersect(which(mytrt1ctrl0==1),which(myM1is1M0is0==0)))#
#
    myxcM1s = generateCM1rnvs(NumberOfCM1)#
    myxtM1s = generateTM1rnvs(NumberOfTM1)#
    myxcM0s = generateCM0rnvs(NumberOfCM0)#
    myxtM0s = generateTM0rnvs(NumberOfTM0)#
#
	apply(myxcM1s,1,mean)#
	apply(myxtM1s,1,mean)#
	apply(myxcM0s,1,mean)#
	apply(myxtM0s,1,mean)#
	myxcs = cbind(myxcM0s,myxcM1s);#
	myxts = cbind(myxtM0s,myxtM1s);#
	myxmarginal = cbind(myxcs,myxts)#
#
	mycMresp = c(rep(0,NumberOfCM0),rep(1,NumberOfCM1)) #
	mytMresp = c(rep(0,NumberOfTM0),rep(1,NumberOfTM1)) #
	# DENSITY RATIO ESTIMATION#
#
	# install.packages("densratio")#
	# library(densratio)#
	# densratio_obj1 = densratio(t(cbind(myxcM1s,myxcM1s,myxcM1s,myxcM1s)),t(myxmarginal),method=thismethod)#
	# densratio_obj3 = densratio(t(cbind(myxtM1s,myxtM1s,myxtM1s,myxtM1s)),t(myxmarginal),method=thismethod)#
#
	# new_x = t(matrix(runif(2000),nrow=2));#
#
	# w_hat1 = densratio_obj1$compute_density_ratio(new_x);#
	# w_hat3 = densratio_obj3$compute_density_ratio(new_x);#
 #    # library(rgl)#
 #    # plot3d(new_x[,1],new_x[,2],w_hat1)#
	# densratio_obj1#
#
	# densratio_obj3#
	# hat_pi_c = length(myxcM1s)/(length(myxcM1s)+length(myxcM0s))#
	# hat_pi_t = length(myxtM1s)/(length(myxtM1s)+length(myxtM0s))#
#
	# hat_pi_c#
	# hat_pi_t#
	# hat_gsubc = w_hat1 * hat_pi_c;#
	# hat_gsubt = w_hat3 * hat_pi_t;#
	# # ESTIMATE THETA0 AND THETA1 with DR approach#
#
	# theta0vec = rep(NA,length(w_hat1));#
	# theta1vec = rep(NA,length(w_hat1));#
#
	# for (i in 1:length(w_hat1)) {#
	# 	thismax = max(hat_gsubc[i],hat_gsubt[i]);#
	# 	theta0vec[i] = thismax - hat_gsubc[i];#
	# 	theta1vec[i] = thismax - hat_gsubt[i];#
	# }#
#
	# DRapproachTheta0 = mean(theta0vec)#
	# seDRapproachTheta0 = sqrt(var(theta0vec)/length(theta0vec))#
#
	# DRapproachTheta1 = mean(theta1vec)#
	# seDRapproachTheta1 = sqrt(var(theta1vec)/length(theta1vec))#
#
	# DRapproachTheta0#
	# seDRapproachTheta0#
#
	# DRapproachTheta1#
	# seDRapproachTheta1#
	# ESTIMATE THETA0 AND THETA1 WITH LOGISTIC REGRESSION + JANES TREATMENTSELECTION PACKAGE#
#
	myxAll = c(myxcs,myxts)#
	myresp = c(mycMresp,mytMresp)#
	mytrtAll = c(rep(0,length(mycMresp)),rep(1,length(mytMresp)));#
	mylogreg = glm(myresp ~ myxAll + mytrtAll + myxAll:mytrtAll, family=binomial(link='logit'))#
#
    beta0c = coef(mylogreg)[1]#
    beta0t = coef(mylogreg)[2]#
	beta3 = coef(mylogreg)[5]#
	beta4 = coef(mylogreg)[6]#
	mydim1vec = beta3/sqrt(beta3^2+beta4^2);#
	mydim2vec = beta4/sqrt(beta3^2+beta4^2);#
    mynewxcM1s = as.vector(c(mydim1vec,mydim2vec) %*% myxcM1s) #
    mynewxtM1s = as.vector(c(mydim1vec,mydim2vec) %*% myxtM1s)#
    mynewxcM0s = as.vector(c(mydim1vec,mydim2vec) %*% myxcM0s)#
    mynewxtM0s = as.vector(c(mydim1vec,mydim2vec) %*% myxtM0s)#
    boxplot(mynewxcM1s,mynewxtM1s,mynewxcM0s,mynewxtM0s)
dim(myxAll)
myxAll
dim(myxcs)
myxAll = cbind(myxcs,myxts)#
	myresp = c(mycMresp,mytMresp)#
	mytrtAll = c(rep(0,length(mycMresp)),rep(1,length(mytMresp)));#
	mylogreg = glm(myresp ~ myxAll + mytrtAll + myxAll:mytrtAll, family=binomial(link='logit'))
dim(myxAll)
dim(myresp)
length(myresp)
myxAll = cbind(myxcs,myxts)#
	myresp = c(mycMresp,mytMresp)#
	mytrtAll = c(rep(0,length(mycMresp)),rep(1,length(mytMresp)));#
	mylogreg = glm(myresp ~ t(myxAll) + mytrtAll + t(myxAll):mytrtAll, family=binomial(link='logit'))
mylogreg
# SIMULATE DATA FROM THE MODEL#
#
thismethod = "uLSIF"#
myn = 3200;#
MCRUNS = 100;#
#
myregion = function(x1,x2) {#
	myreturn = -1;#
	if (x1+x2<1) { myreturn = 1; }#
	else { myreturn = 2; }#
}#
#
myalphasubcM1s = c(0.2,1.8)#
myalphasubcM0s = 2-myalphasubcM1s;#
#
myalphasubtM1s = c(1.8,0.2)#
myalphasubtM0s = 2-myalphasubtM1s;#
#
mybaseareas = c(0.5,0.5)#
#
mycM1probs = myalphasubcM1s*mybaseareas;#
mycM0probs = myalphasubcM0s*mybaseareas;#
mytM1probs = myalphasubtM1s*mybaseareas;#
mytM0probs = myalphasubtM0s*mybaseareas;#
#
sum(mycM1probs);#
sum(mycM0probs);#
sum(mytM1probs)#
sum(mytM0probs)#
#
mycM1probs;#
mycM0probs;#
mytM1probs#
mytM0probs#
#
mycM1grps = rmultinom(myn/4,1,mycM1probs)#
mycM0grps = rmultinom(myn/4,1,mycM0probs)#
mytM1grps = rmultinom(myn/4,1,mytM1probs)#
mytM0grps = rmultinom(myn/4,1,mytM0probs)#
#
sum(mycM1grps[1,])#
sum(mycM0grps[1,])#
sum(mytM1grps[1,])#
sum(mytM0grps[1,])#
#
myxcM1s = rep(NA,myn/4)#
myxtM1s = rep(NA,myn/4)#
myxcM0s = rep(NA,myn/4)#
myxtM0s = rep(NA,myn/4)#
#
DRtheta0s = rep(NA,MCRUNS)#
DRtheta1s = rep(NA,MCRUNS)#
HJtheta0s = rep(NA,MCRUNS)#
HJtheta1s = rep(NA,MCRUNS)#
mygeneratefromArea1 = function() {#
	xtry = c(runif(1),runif(1));#
	while (sum(xtry) > 1) { xtry = c(runif(1),runif(1))  }#
	return(xtry);#
}#
mygeneratefromArea2 = function() {#
	xtry = c(runif(1),runif(1));#
	while (sum(xtry) < 1) { xtry = c(runif(1),runif(1))  }#
	return(xtry);#
}#
# RETURN A 2 BY N MATRIX OF BIOMARKER VALUES#
generateCM1rnvs = function(numberneeded) {#
	myreturn = matrix(rep(NA, 2*numberneeded),nrow=2);#
#
	for (i in 1:numberneeded) {#
		myx = c(NA,NA);#
		thismultinom = rmultinom(1,1,mycM1probs);#
#
		if (as.vector(thismultinom)[1] == 1 ) { myx <- mygeneratefromArea1() }#
		if (as.vector(thismultinom)[2] == 1 ) { myx <- mygeneratefromArea2() }#
		myreturn[,i] = myx;#
	}#
	myreturn;#
}#
#
generateTM1rnvs = function(numberneeded) {#
	myreturn = matrix(rep(NA, 2*numberneeded),nrow=2);#
#
	for (i in 1:numberneeded) {#
		myx = c(NA,NA);#
		thismultinom = rmultinom(1,1,mytM1probs);#
#
		if (as.vector(thismultinom)[1] == 1 ) { myx <- mygeneratefromArea1() }#
		if (as.vector(thismultinom)[2] == 1 ) { myx <- mygeneratefromArea2() }#
		myreturn[,i] = myx;#
	}#
	myreturn;#
}#
#
generateCM0rnvs = function(numberneeded) {#
	myreturn = matrix(rep(NA, 2*numberneeded),nrow=2);#
#
	for (i in 1:numberneeded) {#
		myx = c(NA,NA);#
		thismultinom = rmultinom(1,1,mycM0probs);#
#
		if (as.vector(thismultinom)[1] == 1 ) { myx <- mygeneratefromArea1() }#
		if (as.vector(thismultinom)[2] == 1 ) { myx <- mygeneratefromArea2() }#
		myreturn[,i] = myx;#
	}#
	myreturn;#
}#
generateTM0rnvs = function(numberneeded) {#
	myreturn = matrix(rep(NA, 2*numberneeded),nrow=2);#
#
	for (i in 1:numberneeded) {#
		myx = c(NA,NA);#
		thismultinom = rmultinom(1,1,mytM0probs);#
#
		if (as.vector(thismultinom)[1] == 1 ) { myx <- mygeneratefromArea1() }#
		if (as.vector(thismultinom)[2] == 1 ) { myx <- mygeneratefromArea2() }#
		myreturn[,i] = myx;#
	}#
	myreturn;#
}
mytrt1ctrl0 = rbinom(myn,1,0.5);  # indicates randomization to trt/ctrl#
    myM1is1M0is0 = rbinom(myn,1,0.5); # the conditional probabilities of M1 and M0 are 0.5 for both trt and control#
#
    NumberOfCM1 = length(intersect(which(mytrt1ctrl0==0),which(myM1is1M0is0==1)))#
    NumberOfTM1 = length(intersect(which(mytrt1ctrl0==1),which(myM1is1M0is0==1)))#
    NumberOfCM0 = length(intersect(which(mytrt1ctrl0==0),which(myM1is1M0is0==0)))#
    NumberOfTM0 = length(intersect(which(mytrt1ctrl0==1),which(myM1is1M0is0==0)))#
#
    myxcM1s = generateCM1rnvs(NumberOfCM1)#
    myxtM1s = generateTM1rnvs(NumberOfTM1)#
    myxcM0s = generateCM0rnvs(NumberOfCM0)#
    myxtM0s = generateTM0rnvs(NumberOfTM0)#
#
	apply(myxcM1s,1,mean)#
	apply(myxtM1s,1,mean)#
	apply(myxcM0s,1,mean)#
	apply(myxtM0s,1,mean)#
	myxcs = cbind(myxcM0s,myxcM1s);#
	myxts = cbind(myxtM0s,myxtM1s);#
	myxmarginal = cbind(myxcs,myxts)#
#
	mycMresp = c(rep(0,NumberOfCM0),rep(1,NumberOfCM1)) #
	mytMresp = c(rep(0,NumberOfTM0),rep(1,NumberOfTM1)) #
	# DENSITY RATIO ESTIMATION#
#
	install.packages("densratio")#
	library(densratio)#
	densratio_obj1 = densratio(t(cbind(myxcM1s,myxcM1s,myxcM1s,myxcM1s)),t(myxmarginal),method=thismethod)#
	densratio_obj3 = densratio(t(cbind(myxtM1s,myxtM1s,myxtM1s,myxtM1s)),t(myxmarginal),method=thismethod)#
#
	new_x = t(matrix(runif(2000),nrow=2));#
#
	w_hat1 = densratio_obj1$compute_density_ratio(new_x);#
	w_hat3 = densratio_obj3$compute_density_ratio(new_x);#
    # library(rgl)#
    # plot3d(new_x[,1],new_x[,2],w_hat1)#
	densratio_obj1#
#
	densratio_obj3#
	hat_pi_c = length(myxcM1s)/(length(myxcM1s)+length(myxcM0s))#
	hat_pi_t = length(myxtM1s)/(length(myxtM1s)+length(myxtM0s))#
#
	hat_pi_c#
	hat_pi_t#
	hat_gsubc = w_hat1 * hat_pi_c;#
	hat_gsubt = w_hat3 * hat_pi_t;#
	# ESTIMATE THETA0 AND THETA1 with DR approach#
#
	theta0vec = rep(NA,length(w_hat1));#
	theta1vec = rep(NA,length(w_hat1));#
#
	for (i in 1:length(w_hat1)) {#
		thismax = max(hat_gsubc[i],hat_gsubt[i]);#
		theta0vec[i] = thismax - hat_gsubc[i];#
		theta1vec[i] = thismax - hat_gsubt[i];#
	}#
#
	DRapproachTheta0 = mean(theta0vec)#
	seDRapproachTheta0 = sqrt(var(theta0vec)/length(theta0vec))#
#
	DRapproachTheta1 = mean(theta1vec)#
	seDRapproachTheta1 = sqrt(var(theta1vec)/length(theta1vec))#
#
	DRapproachTheta0#
	seDRapproachTheta0#
#
	DRapproachTheta1#
	seDRapproachTheta1#
	# ESTIMATE THETA0 AND THETA1 WITH LOGISTIC REGRESSION + JANES TREATMENTSELECTION PACKAGE#
#
	myx1cs = myxcs[1,];#
	myx2cs = myxcs[2,];#
	myx1ts = myxts[1,];#
	myx2ts = myxts[2,];#
	myx1All = c(myx1cs,myx1ts)#
	myx2All = c(myx2cs,myx2ts)#
	myresp = c(mycMresp,mytMresp)#
	mytrtAll = c(rep(0,length(mycMresp)),rep(1,length(mytMresp)));#
	mylogreg = glm(myresp ~ myx1All + myx2All + mytrtAll + #
		myx1All:mytrtAll + myx2All:mytrtAll, family=binomial(link='logit'))
mylogreg
# SIMULATE DATA FROM THE MODEL#
#
thismethod = "uLSIF"#
myn = 3200;#
MCRUNS = 3;#
mydim = 10;#
#
myregion = function(x) {#
	myreturn = -1;#
	xsum = sum(x);#
	if (xsum < (mydim/2)) { myreturn = 1; }#
	else { myreturn = 2; }#
}#
#
myalphasubcM1s = c(0.2,1.8)#
myalphasubcM0s = 2-myalphasubcM1s;#
#
myalphasubtM1s = c(1.8,0.2)#
myalphasubtM0s = 2-myalphasubtM1s;#
#
mybaseareas = c(0.5,0.5)#
#
mycM1probs = myalphasubcM1s*mybaseareas;#
mycM0probs = myalphasubcM0s*mybaseareas;#
mytM1probs = myalphasubtM1s*mybaseareas;#
mytM0probs = myalphasubtM0s*mybaseareas;#
#
sum(mycM1probs);#
sum(mycM0probs);#
sum(mytM1probs)#
sum(mytM0probs)#
#
mycM1probs;#
mycM0probs;#
mytM1probs#
mytM0probs#
#
myxcM1s = rep(NA,myn/4)#
myxtM1s = rep(NA,myn/4)#
myxcM0s = rep(NA,myn/4)#
myxtM0s = rep(NA,myn/4)#
#
DRtheta0s = rep(NA,MCRUNS)#
DRtheta1s = rep(NA,MCRUNS)#
HJtheta0s = rep(NA,MCRUNS)#
HJtheta1s = rep(NA,MCRUNS)#
mygeneratefromArea1 = function() {#
	xtry = runif(mydim);#
	while (sum(xtry) > (mydim/2)) { xtry = runif(mydim)  }#
	return(xtry);#
}#
mygeneratefromArea2 = function() {#
	xtry = runif(mydim);#
	while (sum(xtry) < (mydim/2)) { xtry = runif(mydim)  }#
	return(xtry);#
}#
# RETURN A mydim BY N MATRIX OF BIOMARKER VALUES#
generateCM1rnvs = function(numberneeded) {#
	myreturn = matrix(rep(NA, mydim*numberneeded),nrow=mydim);#
#
	for (i in 1:numberneeded) {#
		myx = c(NA,NA);#
		thismultinom = rmultinom(1,1,mycM1probs);#
#
		if (as.vector(thismultinom)[1] == 1 ) { myx <- mygeneratefromArea1() }#
		if (as.vector(thismultinom)[2] == 1 ) { myx <- mygeneratefromArea2() }#
		myreturn[,i] = myx;#
	}#
	myreturn;#
}#
#
generateTM1rnvs = function(numberneeded) {#
	myreturn = matrix(rep(NA, mydim*numberneeded),nrow=mydim);#
#
	for (i in 1:numberneeded) {#
		myx = c(NA,NA);#
		thismultinom = rmultinom(1,1,mytM1probs);#
#
		if (as.vector(thismultinom)[1] == 1 ) { myx <- mygeneratefromArea1() }#
		if (as.vector(thismultinom)[2] == 1 ) { myx <- mygeneratefromArea2() }#
		myreturn[,i] = myx;#
	}#
	myreturn;#
}#
#
generateCM0rnvs = function(numberneeded) {#
	myreturn = matrix(rep(NA, mydim*numberneeded),nrow=mydim);#
#
	for (i in 1:numberneeded) {#
		myx = c(NA,NA);#
		thismultinom = rmultinom(1,1,mycM0probs);#
#
		if (as.vector(thismultinom)[1] == 1 ) { myx <- mygeneratefromArea1() }#
		if (as.vector(thismultinom)[2] == 1 ) { myx <- mygeneratefromArea2() }#
		myreturn[,i] = myx;#
	}#
	myreturn;#
}#
generateTM0rnvs = function(numberneeded) {#
	myreturn = matrix(rep(NA, mydim*numberneeded),nrow=mydim);#
#
	for (i in 1:numberneeded) {#
		myx = c(NA,NA);#
		thismultinom = rmultinom(1,1,mytM0probs);#
#
		if (as.vector(thismultinom)[1] == 1 ) { myx <- mygeneratefromArea1() }#
		if (as.vector(thismultinom)[2] == 1 ) { myx <- mygeneratefromArea2() }#
		myreturn[,i] = myx;#
	}#
	myreturn;#
}
mytrt1ctrl0 = rbinom(myn,1,0.5);  # indicates randomization to trt/ctrl#
    myM1is1M0is0 = rbinom(myn,1,0.5); # the conditional probabilities of M1 and M0 are 0.5 for both trt and control#
#
    NumberOfCM1 = length(intersect(which(mytrt1ctrl0==0),which(myM1is1M0is0==1)))#
    NumberOfTM1 = length(intersect(which(mytrt1ctrl0==1),which(myM1is1M0is0==1)))#
    NumberOfCM0 = length(intersect(which(mytrt1ctrl0==0),which(myM1is1M0is0==0)))#
    NumberOfTM0 = length(intersect(which(mytrt1ctrl0==1),which(myM1is1M0is0==0)))#
#
    myxcM1s = generateCM1rnvs(NumberOfCM1)#
    myxtM1s = generateTM1rnvs(NumberOfTM1)#
    myxcM0s = generateCM0rnvs(NumberOfCM0)#
    myxtM0s = generateTM0rnvs(NumberOfTM0)#
#
	apply(myxcM1s,1,mean)#
	apply(myxtM1s,1,mean)#
	apply(myxcM0s,1,mean)#
	apply(myxtM0s,1,mean)#
	myxcs = cbind(myxcM0s,myxcM1s);#
	myxts = cbind(myxtM0s,myxtM1s);#
	myxmarginal = cbind(myxcs,myxts)#
#
	mycMresp = c(rep(0,NumberOfCM0),rep(1,NumberOfCM1)) #
	mytMresp = c(rep(0,NumberOfTM0),rep(1,NumberOfTM1)) #
	# DENSITY RATIO ESTIMATION#
#
	# install.packages("densratio")#
	# library(densratio)#
	# densratio_obj1 = densratio(t(cbind(myxcM1s,myxcM1s,myxcM1s,myxcM1s)),t(myxmarginal),method=thismethod)#
	# densratio_obj3 = densratio(t(cbind(myxtM1s,myxtM1s,myxtM1s,myxtM1s)),t(myxmarginal),method=thismethod)#
#
	# new_x = t(matrix(runif(2000),nrow=2));#
#
	# w_hat1 = densratio_obj1$compute_density_ratio(new_x);#
	# w_hat3 = densratio_obj3$compute_density_ratio(new_x);#
 #    # library(rgl)#
 #    # plot3d(new_x[,1],new_x[,2],w_hat1)#
	# densratio_obj1#
#
	# densratio_obj3#
	# hat_pi_c = length(myxcM1s)/(length(myxcM1s)+length(myxcM0s))#
	# hat_pi_t = length(myxtM1s)/(length(myxtM1s)+length(myxtM0s))#
#
	# hat_pi_c#
	# hat_pi_t#
	# hat_gsubc = w_hat1 * hat_pi_c;#
	# hat_gsubt = w_hat3 * hat_pi_t;#
	# # ESTIMATE THETA0 AND THETA1 with DR approach#
#
	# theta0vec = rep(NA,length(w_hat1));#
	# theta1vec = rep(NA,length(w_hat1));#
#
	# for (i in 1:length(w_hat1)) {#
	# 	thismax = max(hat_gsubc[i],hat_gsubt[i]);#
	# 	theta0vec[i] = thismax - hat_gsubc[i];#
	# 	theta1vec[i] = thismax - hat_gsubt[i];#
	# }#
#
	# DRapproachTheta0 = mean(theta0vec)#
	# seDRapproachTheta0 = sqrt(var(theta0vec)/length(theta0vec))#
#
	# DRapproachTheta1 = mean(theta1vec)#
	# seDRapproachTheta1 = sqrt(var(theta1vec)/length(theta1vec))#
#
	# DRapproachTheta0#
	# seDRapproachTheta0#
#
	# DRapproachTheta1#
	# seDRapproachTheta1#
	# ESTIMATE THETA0 AND THETA1 WITH LOGISTIC REGRESSION + JANES TREATMENTSELECTION PACKAGE#
#
	myxAll = cbind(myxcs,myxts)#
	myresp = c(mycMresp,mytMresp)#
	mytrtAll = c(rep(0,length(mycMresp)),rep(1,length(mytMresp)));#
	mylogreg = glm(myresp ~ t(myxAll) + mytrtAll + t(myxAll):mytrtAll, family=binomial(link='logit'))#
#
	beta3 = coef(mylogreg)[5]#
	beta4 = coef(mylogreg)[6]#
	mydim1vec = beta3/sqrt(beta3^2+beta4^2);#
	mydim2vec = beta4/sqrt(beta3^2+beta4^2);
mydim1vec
coeffs(mylogreg)
coef(mylogreg)
betas = as.numeric(mylogreg)[13:22];#
    betalength = sqrt(sum(betas^2));#
    mydim = betas/betalength;
betas = as.numeric(coef(mylogreg)[13:22]);#
    betalength = sqrt(sum(betas^2));#
    mydim = betas/betalength;
betas
betalength
mydir
mydimn
mydim
mytrt1ctrl0 = rbinom(myn,1,0.5);  # indicates randomization to trt/ctrl#
    myM1is1M0is0 = rbinom(myn,1,0.5); # the conditional probabilities of M1 and M0 are 0.5 for both trt and control#
#
    NumberOfCM1 = length(intersect(which(mytrt1ctrl0==0),which(myM1is1M0is0==1)))#
    NumberOfTM1 = length(intersect(which(mytrt1ctrl0==1),which(myM1is1M0is0==1)))#
    NumberOfCM0 = length(intersect(which(mytrt1ctrl0==0),which(myM1is1M0is0==0)))#
    NumberOfTM0 = length(intersect(which(mytrt1ctrl0==1),which(myM1is1M0is0==0)))#
#
    myxcM1s = generateCM1rnvs(NumberOfCM1)#
    myxtM1s = generateTM1rnvs(NumberOfTM1)#
    myxcM0s = generateCM0rnvs(NumberOfCM0)#
    myxtM0s = generateTM0rnvs(NumberOfTM0)#
#
	apply(myxcM1s,1,mean)#
	apply(myxtM1s,1,mean)#
	apply(myxcM0s,1,mean)#
	apply(myxtM0s,1,mean)#
	myxcs = cbind(myxcM0s,myxcM1s);#
	myxts = cbind(myxtM0s,myxtM1s);#
	myxmarginal = cbind(myxcs,myxts)#
#
	mycMresp = c(rep(0,NumberOfCM0),rep(1,NumberOfCM1)) #
	mytMresp = c(rep(0,NumberOfTM0),rep(1,NumberOfTM1)) #
	# DENSITY RATIO ESTIMATION#
#
	# install.packages("densratio")#
	# library(densratio)#
	# densratio_obj1 = densratio(t(cbind(myxcM1s,myxcM1s,myxcM1s,myxcM1s)),t(myxmarginal),method=thismethod)#
	# densratio_obj3 = densratio(t(cbind(myxtM1s,myxtM1s,myxtM1s,myxtM1s)),t(myxmarginal),method=thismethod)#
#
	# new_x = t(matrix(runif(2000),nrow=2));#
#
	# w_hat1 = densratio_obj1$compute_density_ratio(new_x);#
	# w_hat3 = densratio_obj3$compute_density_ratio(new_x);#
 #    # library(rgl)#
 #    # plot3d(new_x[,1],new_x[,2],w_hat1)#
	# densratio_obj1#
#
	# densratio_obj3#
	# hat_pi_c = length(myxcM1s)/(length(myxcM1s)+length(myxcM0s))#
	# hat_pi_t = length(myxtM1s)/(length(myxtM1s)+length(myxtM0s))#
#
	# hat_pi_c#
	# hat_pi_t#
	# hat_gsubc = w_hat1 * hat_pi_c;#
	# hat_gsubt = w_hat3 * hat_pi_t;#
	# # ESTIMATE THETA0 AND THETA1 with DR approach#
#
	# theta0vec = rep(NA,length(w_hat1));#
	# theta1vec = rep(NA,length(w_hat1));#
#
	# for (i in 1:length(w_hat1)) {#
	# 	thismax = max(hat_gsubc[i],hat_gsubt[i]);#
	# 	theta0vec[i] = thismax - hat_gsubc[i];#
	# 	theta1vec[i] = thismax - hat_gsubt[i];#
	# }#
#
	# DRapproachTheta0 = mean(theta0vec)#
	# seDRapproachTheta0 = sqrt(var(theta0vec)/length(theta0vec))#
#
	# DRapproachTheta1 = mean(theta1vec)#
	# seDRapproachTheta1 = sqrt(var(theta1vec)/length(theta1vec))#
#
	# DRapproachTheta0#
	# seDRapproachTheta0#
#
	# DRapproachTheta1#
	# seDRapproachTheta1#
	# ESTIMATE THETA0 AND THETA1 WITH LOGISTIC REGRESSION + JANES TREATMENTSELECTION PACKAGE#
#
	myxAll = cbind(myxcs,myxts)#
	myresp = c(mycMresp,mytMresp)#
	mytrtAll = c(rep(0,length(mycMresp)),rep(1,length(mytMresp)));#
	mylogreg = glm(myresp ~ t(myxAll) + mytrtAll + t(myxAll):mytrtAll, family=binomial(link='logit'))#
    betas = as.numeric(coef(mylogreg)[13:22]);#
    betalength = sqrt(sum(betas^2));#
    mydir = betas/betalength;#
    mynewxcM1s = as.vector(mydir %*% myxcM1s) #
    mynewxtM1s = as.vector(mydir %*% myxtM1s)#
    mynewxcM0s = as.vector(mydir %*% myxcM0s)#
    mynewxtM0s = as.vector(mydir %*% myxtM0s)#
    boxplot(mynewxcM1s,mynewxtM1s,mynewxcM0s,mynewxtM0s)
# SIMULATE DATA FROM THE MODEL#
#
thismethod = "uLSIF"#
myn = 3200;#
MCRUNS = 3;#
mydim = 10;#
#
myregion = function(x) {#
	myreturn = -1;#
	xsum = sum(x);#
	if (xsum < (mydim/2)) { myreturn = 1; }#
	else { myreturn = 2; }#
}#
#
myalphasubcM1s = c(0.2,1.8)#
myalphasubcM0s = 2-myalphasubcM1s;#
#
myalphasubtM1s = c(1.8,0.2)#
myalphasubtM0s = 2-myalphasubtM1s;#
#
mybaseareas = c(0.5,0.5)#
#
mycM1probs = myalphasubcM1s*mybaseareas;#
mycM0probs = myalphasubcM0s*mybaseareas;#
mytM1probs = myalphasubtM1s*mybaseareas;#
mytM0probs = myalphasubtM0s*mybaseareas;#
#
sum(mycM1probs);#
sum(mycM0probs);#
sum(mytM1probs)#
sum(mytM0probs)#
#
mycM1probs;#
mycM0probs;#
mytM1probs#
mytM0probs#
#
myxcM1s = rep(NA,myn/4)#
myxtM1s = rep(NA,myn/4)#
myxcM0s = rep(NA,myn/4)#
myxtM0s = rep(NA,myn/4)#
#
DRtheta0s = rep(NA,MCRUNS)#
DRtheta1s = rep(NA,MCRUNS)#
HJtheta0s = rep(NA,MCRUNS)#
HJtheta1s = rep(NA,MCRUNS)#
mygeneratefromArea1 = function() {#
	xtry = runif(mydim);#
	while (sum(xtry) > (mydim/2)) { xtry = runif(mydim)  }#
	return(xtry);#
}#
mygeneratefromArea2 = function() {#
	xtry = runif(mydim);#
	while (sum(xtry) < (mydim/2)) { xtry = runif(mydim)  }#
	return(xtry);#
}#
# RETURN A mydim BY N MATRIX OF BIOMARKER VALUES#
generateCM1rnvs = function(numberneeded) {#
	myreturn = matrix(rep(NA, mydim*numberneeded),nrow=mydim);#
#
	for (i in 1:numberneeded) {#
		myx = c(NA,NA);#
		thismultinom = rmultinom(1,1,mycM1probs);#
#
		if (as.vector(thismultinom)[1] == 1 ) { myx <- mygeneratefromArea1() }#
		if (as.vector(thismultinom)[2] == 1 ) { myx <- mygeneratefromArea2() }#
		myreturn[,i] = myx;#
	}#
	myreturn;#
}#
#
generateTM1rnvs = function(numberneeded) {#
	myreturn = matrix(rep(NA, mydim*numberneeded),nrow=mydim);#
#
	for (i in 1:numberneeded) {#
		myx = c(NA,NA);#
		thismultinom = rmultinom(1,1,mytM1probs);#
#
		if (as.vector(thismultinom)[1] == 1 ) { myx <- mygeneratefromArea1() }#
		if (as.vector(thismultinom)[2] == 1 ) { myx <- mygeneratefromArea2() }#
		myreturn[,i] = myx;#
	}#
	myreturn;#
}#
#
generateCM0rnvs = function(numberneeded) {#
	myreturn = matrix(rep(NA, mydim*numberneeded),nrow=mydim);#
#
	for (i in 1:numberneeded) {#
		myx = c(NA,NA);#
		thismultinom = rmultinom(1,1,mycM0probs);#
#
		if (as.vector(thismultinom)[1] == 1 ) { myx <- mygeneratefromArea1() }#
		if (as.vector(thismultinom)[2] == 1 ) { myx <- mygeneratefromArea2() }#
		myreturn[,i] = myx;#
	}#
	myreturn;#
}#
generateTM0rnvs = function(numberneeded) {#
	myreturn = matrix(rep(NA, mydim*numberneeded),nrow=mydim);#
#
	for (i in 1:numberneeded) {#
		myx = c(NA,NA);#
		thismultinom = rmultinom(1,1,mytM0probs);#
#
		if (as.vector(thismultinom)[1] == 1 ) { myx <- mygeneratefromArea1() }#
		if (as.vector(thismultinom)[2] == 1 ) { myx <- mygeneratefromArea2() }#
		myreturn[,i] = myx;#
	}#
	myreturn;#
}#
for (thismc in 1:MCRUNS)  {#
    mytrt1ctrl0 = rbinom(myn,1,0.5);  # indicates randomization to trt/ctrl#
    myM1is1M0is0 = rbinom(myn,1,0.5); # the conditional probabilities of M1 and M0 are 0.5 for both trt and control#
#
    NumberOfCM1 = length(intersect(which(mytrt1ctrl0==0),which(myM1is1M0is0==1)))#
    NumberOfTM1 = length(intersect(which(mytrt1ctrl0==1),which(myM1is1M0is0==1)))#
    NumberOfCM0 = length(intersect(which(mytrt1ctrl0==0),which(myM1is1M0is0==0)))#
    NumberOfTM0 = length(intersect(which(mytrt1ctrl0==1),which(myM1is1M0is0==0)))#
#
    myxcM1s = generateCM1rnvs(NumberOfCM1)#
    myxtM1s = generateTM1rnvs(NumberOfTM1)#
    myxcM0s = generateCM0rnvs(NumberOfCM0)#
    myxtM0s = generateTM0rnvs(NumberOfTM0)#
#
	apply(myxcM1s,1,mean)#
	apply(myxtM1s,1,mean)#
	apply(myxcM0s,1,mean)#
	apply(myxtM0s,1,mean)#
	myxcs = cbind(myxcM0s,myxcM1s);#
	myxts = cbind(myxtM0s,myxtM1s);#
	myxmarginal = cbind(myxcs,myxts)#
#
	mycMresp = c(rep(0,NumberOfCM0),rep(1,NumberOfCM1)) #
	mytMresp = c(rep(0,NumberOfTM0),rep(1,NumberOfTM1)) #
	# DENSITY RATIO ESTIMATION#
#
	# install.packages("densratio")#
	# library(densratio)#
	# densratio_obj1 = densratio(t(cbind(myxcM1s,myxcM1s,myxcM1s,myxcM1s)),t(myxmarginal),method=thismethod)#
	# densratio_obj3 = densratio(t(cbind(myxtM1s,myxtM1s,myxtM1s,myxtM1s)),t(myxmarginal),method=thismethod)#
#
	# new_x = t(matrix(runif(2000),nrow=2));#
#
	# w_hat1 = densratio_obj1$compute_density_ratio(new_x);#
	# w_hat3 = densratio_obj3$compute_density_ratio(new_x);#
 #    # library(rgl)#
 #    # plot3d(new_x[,1],new_x[,2],w_hat1)#
	# densratio_obj1#
#
	# densratio_obj3#
	# hat_pi_c = length(myxcM1s)/(length(myxcM1s)+length(myxcM0s))#
	# hat_pi_t = length(myxtM1s)/(length(myxtM1s)+length(myxtM0s))#
#
	# hat_pi_c#
	# hat_pi_t#
	# hat_gsubc = w_hat1 * hat_pi_c;#
	# hat_gsubt = w_hat3 * hat_pi_t;#
	# # ESTIMATE THETA0 AND THETA1 with DR approach#
#
	# theta0vec = rep(NA,length(w_hat1));#
	# theta1vec = rep(NA,length(w_hat1));#
#
	# for (i in 1:length(w_hat1)) {#
	# 	thismax = max(hat_gsubc[i],hat_gsubt[i]);#
	# 	theta0vec[i] = thismax - hat_gsubc[i];#
	# 	theta1vec[i] = thismax - hat_gsubt[i];#
	# }#
#
	# DRapproachTheta0 = mean(theta0vec)#
	# seDRapproachTheta0 = sqrt(var(theta0vec)/length(theta0vec))#
#
	# DRapproachTheta1 = mean(theta1vec)#
	# seDRapproachTheta1 = sqrt(var(theta1vec)/length(theta1vec))#
#
	# DRapproachTheta0#
	# seDRapproachTheta0#
#
	# DRapproachTheta1#
	# seDRapproachTheta1#
	# ESTIMATE THETA0 AND THETA1 WITH LOGISTIC REGRESSION + JANES TREATMENTSELECTION PACKAGE#
#
	myxAll = cbind(myxcs,myxts)#
	myresp = c(mycMresp,mytMresp)#
	mytrtAll = c(rep(0,length(mycMresp)),rep(1,length(mytMresp)));#
	mylogreg = glm(myresp ~ t(myxAll) + mytrtAll + t(myxAll):mytrtAll, family=binomial(link='logit'))#
    betas = as.numeric(coef(mylogreg)[13:22]);#
    betalength = sqrt(sum(betas^2));#
    mydir = betas/betalength;#
    mynewxcM1s = as.vector(mydir %*% myxcM1s) #
    mynewxtM1s = as.vector(mydir %*% myxtM1s)#
    mynewxcM0s = as.vector(mydir %*% myxcM0s)#
    mynewxtM0s = as.vector(mydir %*% myxtM0s)#
    boxplot(mynewxcM1s,mynewxtM1s,mynewxcM0s,mynewxtM0s)#
	library(TreatmentSelection)#
#
	myoutcomes = c(rep(1,length(mynewxcM1s)),rep(0,length(mynewxcM0s)),rep(1,length(mynewxtM1s)),rep(0,length(mynewxtM0s)));#
	mymarker = c(mynewxcM1s,mynewxcM0s,mynewxtM1s,mynewxtM0s);#
	mytreatment = c(rep(0,myn/2),rep(1,myn/2))#
#
	datafraforjanes = data.frame(event=myoutcomes,trt=mytreatment,Y1=mymarker);#
	mytrtsel = trtsel(event ~ Y1*trt,treatment.name="trt",data=datafraforjanes,#
	                      study.design="RCT",family=binomial("logit"),default.trt="trt all")#
	tmp = evaluate(mytrtsel,bootstraps=1000);#
#
	mytrtsel#
#
	tmp#
#
	JanesTheta1 = tmp$estimates$Theta.emp#
#
	JanesTheta1#
#
	datafraforjanes = data.frame(event=myoutcomes,trt=mytreatment,Y1=mymarker);#
	mytrtsel = trtsel(event ~ Y1*trt,treatment.name="trt",data=datafraforjanes,#
	                      study.design="RCT",family=binomial("logit"),default.trt="trt none")#
	tmp = evaluate(mytrtsel,bootstraps=1000);#
#
	JanesTheta0 = tmp$estimates$Theta.emp#
	JanesTheta0#
#
	DRtheta0s[thismc] = DRapproachTheta0;#
	DRtheta1s[thismc] = DRapproachTheta1;#
	HJtheta0s[thismc] = JanesTheta0; #
	HJtheta1s[thismc] = JanesTheta1;#
}#
#
write.table(cbind(DRtheta0s,DRtheta1s,HJtheta0s,HJtheta1s),file="simTriangleArea10Dimmyn3200MCRUNS100.txt")
HJtheta0s
HJtheta1s
# SIMULATE DATA FROM THE MODEL#
#
thismethod = "uLSIF"#
myn = 3200;#
MCRUNS = 3;#
mydim = 10;#
#
myregion = function(x) {#
	myreturn = -1;#
	xsum = sum(x);#
	if (xsum < (mydim/2)) { myreturn = 1; }#
	else { myreturn = 2; }#
}#
#
myalphasubcM1s = c(0.2,1.8)#
myalphasubcM0s = 2-myalphasubcM1s;#
#
myalphasubtM1s = c(1.8,0.2)#
myalphasubtM0s = 2-myalphasubtM1s;#
#
mybaseareas = c(0.5,0.5)#
#
mycM1probs = myalphasubcM1s*mybaseareas;#
mycM0probs = myalphasubcM0s*mybaseareas;#
mytM1probs = myalphasubtM1s*mybaseareas;#
mytM0probs = myalphasubtM0s*mybaseareas;#
#
sum(mycM1probs);#
sum(mycM0probs);#
sum(mytM1probs)#
sum(mytM0probs)#
#
mycM1probs;#
mycM0probs;#
mytM1probs#
mytM0probs#
#
myxcM1s = rep(NA,myn/4)#
myxtM1s = rep(NA,myn/4)#
myxcM0s = rep(NA,myn/4)#
myxtM0s = rep(NA,myn/4)#
#
DRtheta0s = rep(NA,MCRUNS)#
DRtheta1s = rep(NA,MCRUNS)#
HJtheta0s = rep(NA,MCRUNS)#
HJtheta1s = rep(NA,MCRUNS)#
mygeneratefromArea1 = function() {#
	xtry = runif(mydim);#
	while (sum(xtry) > (mydim/2)) { xtry = runif(mydim)  }#
	return(xtry);#
}#
mygeneratefromArea2 = function() {#
	xtry = runif(mydim);#
	while (sum(xtry) < (mydim/2)) { xtry = runif(mydim)  }#
	return(xtry);#
}#
# RETURN A mydim BY N MATRIX OF BIOMARKER VALUES#
generateCM1rnvs = function(numberneeded) {#
	myreturn = matrix(rep(NA, mydim*numberneeded),nrow=mydim);#
#
	for (i in 1:numberneeded) {#
		myx = c(NA,NA);#
		thismultinom = rmultinom(1,1,mycM1probs);#
#
		if (as.vector(thismultinom)[1] == 1 ) { myx <- mygeneratefromArea1() }#
		if (as.vector(thismultinom)[2] == 1 ) { myx <- mygeneratefromArea2() }#
		myreturn[,i] = myx;#
	}#
	myreturn;#
}#
#
generateTM1rnvs = function(numberneeded) {#
	myreturn = matrix(rep(NA, mydim*numberneeded),nrow=mydim);#
#
	for (i in 1:numberneeded) {#
		myx = c(NA,NA);#
		thismultinom = rmultinom(1,1,mytM1probs);#
#
		if (as.vector(thismultinom)[1] == 1 ) { myx <- mygeneratefromArea1() }#
		if (as.vector(thismultinom)[2] == 1 ) { myx <- mygeneratefromArea2() }#
		myreturn[,i] = myx;#
	}#
	myreturn;#
}#
#
generateCM0rnvs = function(numberneeded) {#
	myreturn = matrix(rep(NA, mydim*numberneeded),nrow=mydim);#
#
	for (i in 1:numberneeded) {#
		myx = c(NA,NA);#
		thismultinom = rmultinom(1,1,mycM0probs);#
#
		if (as.vector(thismultinom)[1] == 1 ) { myx <- mygeneratefromArea1() }#
		if (as.vector(thismultinom)[2] == 1 ) { myx <- mygeneratefromArea2() }#
		myreturn[,i] = myx;#
	}#
	myreturn;#
}#
generateTM0rnvs = function(numberneeded) {#
	myreturn = matrix(rep(NA, mydim*numberneeded),nrow=mydim);#
#
	for (i in 1:numberneeded) {#
		myx = c(NA,NA);#
		thismultinom = rmultinom(1,1,mytM0probs);#
#
		if (as.vector(thismultinom)[1] == 1 ) { myx <- mygeneratefromArea1() }#
		if (as.vector(thismultinom)[2] == 1 ) { myx <- mygeneratefromArea2() }#
		myreturn[,i] = myx;#
	}#
	myreturn;#
}#
for (thismc in 1:MCRUNS)  {#
    mytrt1ctrl0 = rbinom(myn,1,0.5);  # indicates randomization to trt/ctrl#
    myM1is1M0is0 = rbinom(myn,1,0.5); # the conditional probabilities of M1 and M0 are 0.5 for both trt and control#
#
    NumberOfCM1 = length(intersect(which(mytrt1ctrl0==0),which(myM1is1M0is0==1)))#
    NumberOfTM1 = length(intersect(which(mytrt1ctrl0==1),which(myM1is1M0is0==1)))#
    NumberOfCM0 = length(intersect(which(mytrt1ctrl0==0),which(myM1is1M0is0==0)))#
    NumberOfTM0 = length(intersect(which(mytrt1ctrl0==1),which(myM1is1M0is0==0)))#
#
    myxcM1s = generateCM1rnvs(NumberOfCM1)#
    myxtM1s = generateTM1rnvs(NumberOfTM1)#
    myxcM0s = generateCM0rnvs(NumberOfCM0)#
    myxtM0s = generateTM0rnvs(NumberOfTM0)#
#
	apply(myxcM1s,1,mean)#
	apply(myxtM1s,1,mean)#
	apply(myxcM0s,1,mean)#
	apply(myxtM0s,1,mean)#
	myxcs = cbind(myxcM0s,myxcM1s);#
	myxts = cbind(myxtM0s,myxtM1s);#
	myxmarginal = cbind(myxcs,myxts)#
#
	mycMresp = c(rep(0,NumberOfCM0),rep(1,NumberOfCM1)) #
	mytMresp = c(rep(0,NumberOfTM0),rep(1,NumberOfTM1)) #
	# DENSITY RATIO ESTIMATION#
#
	install.packages("densratio")#
	library(densratio)#
	densratio_obj1 = densratio(t(cbind(myxcM1s,myxcM1s,myxcM1s,myxcM1s)),t(myxmarginal),method=thismethod)#
	densratio_obj3 = densratio(t(cbind(myxtM1s,myxtM1s,myxtM1s,myxtM1s)),t(myxmarginal),method=thismethod)#
#
	new_x = t(matrix(runif(2000),nrow=2));#
#
	w_hat1 = densratio_obj1$compute_density_ratio(new_x);#
	w_hat3 = densratio_obj3$compute_density_ratio(new_x);#
    # library(rgl)#
    # plot3d(new_x[,1],new_x[,2],w_hat1)#
	densratio_obj1#
#
	densratio_obj3#
	hat_pi_c = length(myxcM1s)/(length(myxcM1s)+length(myxcM0s))#
	hat_pi_t = length(myxtM1s)/(length(myxtM1s)+length(myxtM0s))#
#
	hat_pi_c#
	hat_pi_t#
	hat_gsubc = w_hat1 * hat_pi_c;#
	hat_gsubt = w_hat3 * hat_pi_t;#
	# ESTIMATE THETA0 AND THETA1 with DR approach#
#
	theta0vec = rep(NA,length(w_hat1));#
	theta1vec = rep(NA,length(w_hat1));#
#
	for (i in 1:length(w_hat1)) {#
		thismax = max(hat_gsubc[i],hat_gsubt[i]);#
		theta0vec[i] = thismax - hat_gsubc[i];#
		theta1vec[i] = thismax - hat_gsubt[i];#
	}#
#
	DRapproachTheta0 = mean(theta0vec)#
	seDRapproachTheta0 = sqrt(var(theta0vec)/length(theta0vec))#
#
	DRapproachTheta1 = mean(theta1vec)#
	seDRapproachTheta1 = sqrt(var(theta1vec)/length(theta1vec))#
#
	DRapproachTheta0#
	seDRapproachTheta0#
#
	DRapproachTheta1#
	seDRapproachTheta1#
	# ESTIMATE THETA0 AND THETA1 WITH LOGISTIC REGRESSION + JANES TREATMENTSELECTION PACKAGE#
#
	myxAll = cbind(myxcs,myxts)#
	myresp = c(mycMresp,mytMresp)#
	mytrtAll = c(rep(0,length(mycMresp)),rep(1,length(mytMresp)));#
	mylogreg = glm(myresp ~ t(myxAll) + mytrtAll + t(myxAll):mytrtAll, family=binomial(link='logit'))#
    betas = as.numeric(coef(mylogreg)[13:22]);#
    betalength = sqrt(sum(betas^2));#
    mydir = betas/betalength;#
    mynewxcM1s = as.vector(mydir %*% myxcM1s) #
    mynewxtM1s = as.vector(mydir %*% myxtM1s)#
    mynewxcM0s = as.vector(mydir %*% myxcM0s)#
    mynewxtM0s = as.vector(mydir %*% myxtM0s)#
    boxplot(mynewxcM1s,mynewxtM1s,mynewxcM0s,mynewxtM0s)#
	library(TreatmentSelection)#
#
	myoutcomes = c(rep(1,length(mynewxcM1s)),rep(0,length(mynewxcM0s)),rep(1,length(mynewxtM1s)),rep(0,length(mynewxtM0s)));#
	mymarker = c(mynewxcM1s,mynewxcM0s,mynewxtM1s,mynewxtM0s);#
	mytreatment = c(rep(0,myn/2),rep(1,myn/2))#
#
	datafraforjanes = data.frame(event=myoutcomes,trt=mytreatment,Y1=mymarker);#
	mytrtsel = trtsel(event ~ Y1*trt,treatment.name="trt",data=datafraforjanes,#
	                      study.design="RCT",family=binomial("logit"),default.trt="trt all")#
	tmp = evaluate(mytrtsel,bootstraps=1000);#
#
	mytrtsel#
#
	tmp#
#
	JanesTheta1 = tmp$estimates$Theta.emp#
#
	JanesTheta1#
#
	datafraforjanes = data.frame(event=myoutcomes,trt=mytreatment,Y1=mymarker);#
	mytrtsel = trtsel(event ~ Y1*trt,treatment.name="trt",data=datafraforjanes,#
	                      study.design="RCT",family=binomial("logit"),default.trt="trt none")#
	tmp = evaluate(mytrtsel,bootstraps=1000);#
#
	JanesTheta0 = tmp$estimates$Theta.emp#
	JanesTheta0#
#
	DRtheta0s[thismc] = DRapproachTheta0;#
	DRtheta1s[thismc] = DRapproachTheta1;#
	HJtheta0s[thismc] = JanesTheta0; #
	HJtheta1s[thismc] = JanesTheta1;#
}#
#
write.table(cbind(DRtheta0s,DRtheta1s,HJtheta0s,HJtheta1s),file="simTriangleArea10Dimmyn3200MCRUNS100.txt")#
#
cbind(DRtheta0s,DRtheta1s,HJtheta0s,HJtheta1s)
version()
version
ls
q()
16*11/(11*6)
5 + 12 + 21 + 32
q()
5822/8833
1-1133/1688
q()
thismethod = "uLSIF"#
myn = 1000;#
MCRUNS = 3;#
dimlist = 2:5;
mydim=5
myregion = function(x) {#
	myreturn = -1;#
	xsum = sum(x);#
	if (xsum < (mydim/2)) { myreturn = 1; }#
	else { myreturn = 2; }#
}#
#
myalphasubcM1s = c(0.2,1.8)#
myalphasubcM0s = 2-myalphasubcM1s;#
#
myalphasubtM1s = c(1.8,0.2)#
myalphasubtM0s = 2-myalphasubtM1s;#
#
mybaseareas = c(0.5,0.5)#
#
mycM1probs = myalphasubcM1s*mybaseareas;#
mycM0probs = myalphasubcM0s*mybaseareas;#
mytM1probs = myalphasubtM1s*mybaseareas;#
mytM0probs = myalphasubtM0s*mybaseareas;#
#
sum(mycM1probs);#
sum(mycM0probs);#
sum(mytM1probs)#
sum(mytM0probs)#
#
mycM1probs;#
mycM0probs;#
mytM1probs#
mytM0probs#
#
myxcM1s = rep(NA,myn/4)#
myxtM1s = rep(NA,myn/4)#
myxcM0s = rep(NA,myn/4)#
myxtM0s = rep(NA,myn/4)#
#
DRtheta0s = rep(NA,MCRUNS)#
DRtheta1s = rep(NA,MCRUNS)#
HJtheta0s = rep(NA,MCRUNS)#
HJtheta1s = rep(NA,MCRUNS)#
logitDRtheta0s = rep(NA,MCRUNS)#
logitDRtheta1s = rep(NA,MCRUNS)#
mygeneratefromArea1 = function() {#
	xtry = runif(mydim);#
	while (sum(xtry) > (mydim/2)) { xtry = runif(mydim)  }#
	return(xtry);#
}#
mygeneratefromArea2 = function() {#
	xtry = runif(mydim);#
	while (sum(xtry) < (mydim/2)) { xtry = runif(mydim)  }#
	return(xtry);#
}#
# RETURN A mydim BY N MATRIX OF BIOMARKER VALUES#
generateCM1rnvs = function(numberneeded) {#
	myreturn = matrix(rep(NA, mydim*numberneeded),nrow=mydim);#
#
	for (i in 1:numberneeded) {#
		myx = c(NA,NA);#
		thismultinom = rmultinom(1,1,mycM1probs);#
#
		if (as.vector(thismultinom)[1] == 1 ) { myx <- mygeneratefromArea1() }#
		if (as.vector(thismultinom)[2] == 1 ) { myx <- mygeneratefromArea2() }#
		myreturn[,i] = myx;#
	}#
	myreturn;#
}#
#
generateTM1rnvs = function(numberneeded) {#
	myreturn = matrix(rep(NA, mydim*numberneeded),nrow=mydim);#
#
	for (i in 1:numberneeded) {#
		myx = c(NA,NA);#
		thismultinom = rmultinom(1,1,mytM1probs);#
#
		if (as.vector(thismultinom)[1] == 1 ) { myx <- mygeneratefromArea1() }#
		if (as.vector(thismultinom)[2] == 1 ) { myx <- mygeneratefromArea2() }#
		myreturn[,i] = myx;#
	}#
	myreturn;#
}#
#
generateCM0rnvs = function(numberneeded) {#
	myreturn = matrix(rep(NA, mydim*numberneeded),nrow=mydim);#
#
	for (i in 1:numberneeded) {#
		myx = c(NA,NA);#
		thismultinom = rmultinom(1,1,mycM0probs);#
#
		if (as.vector(thismultinom)[1] == 1 ) { myx <- mygeneratefromArea1() }#
		if (as.vector(thismultinom)[2] == 1 ) { myx <- mygeneratefromArea2() }#
		myreturn[,i] = myx;#
	}#
	myreturn;#
}#
generateTM0rnvs = function(numberneeded) {#
	myreturn = matrix(rep(NA, mydim*numberneeded),nrow=mydim);#
#
	for (i in 1:numberneeded) {#
		myx = c(NA,NA);#
		thismultinom = rmultinom(1,1,mytM0probs);#
#
		if (as.vector(thismultinom)[1] == 1 ) { myx <- mygeneratefromArea1() }#
		if (as.vector(thismultinom)[2] == 1 ) { myx <- mygeneratefromArea2() }#
		myreturn[,i] = myx;#
	}#
	myreturn;#
}
mytrt1ctrl0 = rbinom(myn,1,0.5);  # indicates randomization to trt/ctrl#
    myM1is1M0is0 = rbinom(myn,1,0.5); # the conditional probabilities of M1 and M0 are 0.5 for both trt and control#
#
    NumberOfCM1 = length(intersect(which(mytrt1ctrl0==0),which(myM1is1M0is0==1)))#
    NumberOfTM1 = length(intersect(which(mytrt1ctrl0==1),which(myM1is1M0is0==1)))#
    NumberOfCM0 = length(intersect(which(mytrt1ctrl0==0),which(myM1is1M0is0==0)))#
    NumberOfTM0 = length(intersect(which(mytrt1ctrl0==1),which(myM1is1M0is0==0)))#
#
    myxcM1s = generateCM1rnvs(NumberOfCM1)#
    myxtM1s = generateTM1rnvs(NumberOfTM1)#
    myxcM0s = generateCM0rnvs(NumberOfCM0)#
    myxtM0s = generateTM0rnvs(NumberOfTM0)#
#
	apply(myxcM1s,1,mean)#
	apply(myxtM1s,1,mean)#
	apply(myxcM0s,1,mean)#
	apply(myxtM0s,1,mean)#
	myxcs = cbind(myxcM0s,myxcM1s);#
	myxts = cbind(myxtM0s,myxtM1s);#
	myxmarginal = cbind(myxcs,myxts)#
#
	mycMresp = c(rep(0,NumberOfCM0),rep(1,NumberOfCM1)) #
	mytMresp = c(rep(0,NumberOfTM0),rep(1,NumberOfTM1)) #
	# DENSITY RATIO ESTIMATION#
#
	# install.packages("densratio")#
	library(densratio)#
	densratio_obj1 = densratio(t(cbind(myxcM1s,myxcM1s,myxcM1s,myxcM1s)),t(myxmarginal),method=thismethod)#
	densratio_obj3 = densratio(t(cbind(myxtM1s,myxtM1s,myxtM1s,myxtM1s)),t(myxmarginal),method=thismethod)#
#
	new_x = t(matrix(runif(1000*mydim),nrow=mydim));#
#
	w_hat1 = densratio_obj1$compute_density_ratio(new_x);#
	w_hat3 = densratio_obj3$compute_density_ratio(new_x);#
    # library(rgl)#
    # plot3d(new_x[,1],new_x[,2],w_hat1)#
    plot(new_x[,1],w_hat1)#
#
	densratio_obj1#
#
	densratio_obj3#
	hat_pi_c = length(myxcM1s)/(length(myxcM1s)+length(myxcM0s))#
	hat_pi_t = length(myxtM1s)/(length(myxtM1s)+length(myxtM0s))#
#
	hat_pi_c#
	hat_pi_t#
	hat_gsubc = w_hat1 * hat_pi_c;#
	hat_gsubt = w_hat3 * hat_pi_t;#
	# ESTIMATE THETA0 AND THETA1 with DR approach#
#
	theta0vec = rep(NA,length(w_hat1));#
	theta1vec = rep(NA,length(w_hat1));#
#
	for (i in 1:length(w_hat1)) {#
		thismax = max(hat_gsubc[i],hat_gsubt[i]);#
		theta0vec[i] = thismax - hat_gsubc[i];#
		theta1vec[i] = thismax - hat_gsubt[i];#
	}#
#
	DRapproachTheta0 = mean(theta0vec)#
	seDRapproachTheta0 = sqrt(var(theta0vec)/length(theta0vec))#
#
	DRapproachTheta1 = mean(theta1vec)#
	seDRapproachTheta1 = sqrt(var(theta1vec)/length(theta1vec))#
#
	DRapproachTheta0#
	seDRapproachTheta0#
#
	DRapproachTheta1#
	seDRapproachTheta1#
	# ESTIMATE THETA0 AND THETA1 WITH LOGISTIC REGRESSION + JANES TREATMENTSELECTION PACKAGE#
#
	myxAll = cbind(myxcs,myxts)#
	myresp = c(mycMresp,mytMresp)#
	mytrtAll = c(rep(0,length(mycMresp)),rep(1,length(mytMresp)));#
	mylogreg = glm(myresp ~ t(myxAll) + mytrtAll + t(myxAll):mytrtAll, family=binomial(link='logit'))#
    firstindex = 1 + mydim + 1 + 1;#
    lastindex = firstindex + (mydim - 1);#
    betas = as.numeric(coef(mylogreg)[firstindex:lastindex]);#
    betalength = sqrt(sum(betas^2));#
    mydir = betas/betalength;#
    mynewxcM1s = as.vector(mydir %*% myxcM1s) #
    mynewxtM1s = as.vector(mydir %*% myxtM1s)#
    mynewxcM0s = as.vector(mydir %*% myxcM0s)#
    mynewxtM0s = as.vector(mydir %*% myxtM0s)#
    boxplot(mynewxcM1s,mynewxtM1s,mynewxcM0s,mynewxtM0s)#
	library(TreatmentSelection)#
#
	myoutcomes = c(rep(1,length(mynewxcM1s)),rep(0,length(mynewxcM0s)),rep(1,length(mynewxtM1s)),rep(0,length(mynewxtM0s)));#
	mymarker = c(mynewxcM1s,mynewxcM0s,mynewxtM1s,mynewxtM0s);#
	mytreatment = c(rep(0,myn/2),rep(1,myn/2))#
#
	datafraforjanes = data.frame(event=myoutcomes,trt=mytreatment,Y1=mymarker);#
	mytrtsel = trtsel(event ~ Y1*trt,treatment.name="trt",data=datafraforjanes,#
	                      study.design="RCT",family=binomial("logit"),default.trt="trt all")#
	tmp = evaluate(mytrtsel,bootstraps=1000);#
#
	mytrtsel#
#
	tmp#
#
	JanesTheta1 = tmp$estimates$Theta.emp#
#
	JanesTheta1#
#
	datafraforjanes = data.frame(event=myoutcomes,trt=mytreatment,Y1=mymarker);#
	mytrtsel = trtsel(event ~ Y1*trt,treatment.name="trt",data=datafraforjanes,#
	                      study.design="RCT",family=binomial("logit"),default.trt="trt none")#
	tmp = evaluate(mytrtsel,bootstraps=1000);#
#
	JanesTheta0 = tmp$estimates$Theta.emp#
#
	JanesTheta0
# SIMULATE DATA FROM THE MODEL#
#
thismethod = "uLSIF"#
myn = 1000;#
MCRUNS = 3;#
dimlist = 2:5;#
#
for (mydim in dimlist) {#
#
myregion = function(x) {#
	myreturn = -1;#
	xsum = sum(x);#
	if (xsum < (mydim/2)) { myreturn = 1; }#
	else { myreturn = 2; }#
}#
#
myalphasubcM1s = c(0.2,1.8)#
myalphasubcM0s = 2-myalphasubcM1s;#
#
myalphasubtM1s = c(1.8,0.2)#
myalphasubtM0s = 2-myalphasubtM1s;#
#
mybaseareas = c(0.5,0.5)#
#
mycM1probs = myalphasubcM1s*mybaseareas;#
mycM0probs = myalphasubcM0s*mybaseareas;#
mytM1probs = myalphasubtM1s*mybaseareas;#
mytM0probs = myalphasubtM0s*mybaseareas;#
#
sum(mycM1probs);#
sum(mycM0probs);#
sum(mytM1probs)#
sum(mytM0probs)#
#
mycM1probs;#
mycM0probs;#
mytM1probs#
mytM0probs#
#
myxcM1s = rep(NA,myn/4)#
myxtM1s = rep(NA,myn/4)#
myxcM0s = rep(NA,myn/4)#
myxtM0s = rep(NA,myn/4)#
#
DRtheta0s = rep(NA,MCRUNS)#
DRtheta1s = rep(NA,MCRUNS)#
HJtheta0s = rep(NA,MCRUNS)#
HJtheta1s = rep(NA,MCRUNS)#
logitDRtheta0s = rep(NA,MCRUNS)#
logitDRtheta1s = rep(NA,MCRUNS)#
mygeneratefromArea1 = function() {#
	xtry = runif(mydim);#
	while (sum(xtry) > (mydim/2)) { xtry = runif(mydim)  }#
	return(xtry);#
}#
mygeneratefromArea2 = function() {#
	xtry = runif(mydim);#
	while (sum(xtry) < (mydim/2)) { xtry = runif(mydim)  }#
	return(xtry);#
}#
# RETURN A mydim BY N MATRIX OF BIOMARKER VALUES#
generateCM1rnvs = function(numberneeded) {#
	myreturn = matrix(rep(NA, mydim*numberneeded),nrow=mydim);#
#
	for (i in 1:numberneeded) {#
		myx = c(NA,NA);#
		thismultinom = rmultinom(1,1,mycM1probs);#
#
		if (as.vector(thismultinom)[1] == 1 ) { myx <- mygeneratefromArea1() }#
		if (as.vector(thismultinom)[2] == 1 ) { myx <- mygeneratefromArea2() }#
		myreturn[,i] = myx;#
	}#
	myreturn;#
}#
#
generateTM1rnvs = function(numberneeded) {#
	myreturn = matrix(rep(NA, mydim*numberneeded),nrow=mydim);#
#
	for (i in 1:numberneeded) {#
		myx = c(NA,NA);#
		thismultinom = rmultinom(1,1,mytM1probs);#
#
		if (as.vector(thismultinom)[1] == 1 ) { myx <- mygeneratefromArea1() }#
		if (as.vector(thismultinom)[2] == 1 ) { myx <- mygeneratefromArea2() }#
		myreturn[,i] = myx;#
	}#
	myreturn;#
}#
#
generateCM0rnvs = function(numberneeded) {#
	myreturn = matrix(rep(NA, mydim*numberneeded),nrow=mydim);#
#
	for (i in 1:numberneeded) {#
		myx = c(NA,NA);#
		thismultinom = rmultinom(1,1,mycM0probs);#
#
		if (as.vector(thismultinom)[1] == 1 ) { myx <- mygeneratefromArea1() }#
		if (as.vector(thismultinom)[2] == 1 ) { myx <- mygeneratefromArea2() }#
		myreturn[,i] = myx;#
	}#
	myreturn;#
}#
generateTM0rnvs = function(numberneeded) {#
	myreturn = matrix(rep(NA, mydim*numberneeded),nrow=mydim);#
#
	for (i in 1:numberneeded) {#
		myx = c(NA,NA);#
		thismultinom = rmultinom(1,1,mytM0probs);#
#
		if (as.vector(thismultinom)[1] == 1 ) { myx <- mygeneratefromArea1() }#
		if (as.vector(thismultinom)[2] == 1 ) { myx <- mygeneratefromArea2() }#
		myreturn[,i] = myx;#
	}#
	myreturn;#
}#
for (thismc in 1:MCRUNS)  {#
    mytrt1ctrl0 = rbinom(myn,1,0.5);  # indicates randomization to trt/ctrl#
    myM1is1M0is0 = rbinom(myn,1,0.5); # the conditional probabilities of M1 and M0 are 0.5 for both trt and control#
#
    NumberOfCM1 = length(intersect(which(mytrt1ctrl0==0),which(myM1is1M0is0==1)))#
    NumberOfTM1 = length(intersect(which(mytrt1ctrl0==1),which(myM1is1M0is0==1)))#
    NumberOfCM0 = length(intersect(which(mytrt1ctrl0==0),which(myM1is1M0is0==0)))#
    NumberOfTM0 = length(intersect(which(mytrt1ctrl0==1),which(myM1is1M0is0==0)))#
#
    myxcM1s = generateCM1rnvs(NumberOfCM1)#
    myxtM1s = generateTM1rnvs(NumberOfTM1)#
    myxcM0s = generateCM0rnvs(NumberOfCM0)#
    myxtM0s = generateTM0rnvs(NumberOfTM0)#
#
	apply(myxcM1s,1,mean)#
	apply(myxtM1s,1,mean)#
	apply(myxcM0s,1,mean)#
	apply(myxtM0s,1,mean)#
	myxcs = cbind(myxcM0s,myxcM1s);#
	myxts = cbind(myxtM0s,myxtM1s);#
	myxmarginal = cbind(myxcs,myxts)#
#
	mycMresp = c(rep(0,NumberOfCM0),rep(1,NumberOfCM1)) #
	mytMresp = c(rep(0,NumberOfTM0),rep(1,NumberOfTM1)) #
	# DENSITY RATIO ESTIMATION#
#
	# install.packages("densratio")#
	library(densratio)#
	densratio_obj1 = densratio(t(cbind(myxcM1s,myxcM1s,myxcM1s,myxcM1s)),t(myxmarginal),method=thismethod)#
	densratio_obj3 = densratio(t(cbind(myxtM1s,myxtM1s,myxtM1s,myxtM1s)),t(myxmarginal),method=thismethod)#
#
	new_x = t(matrix(runif(1000*mydim),nrow=mydim));#
#
	w_hat1 = densratio_obj1$compute_density_ratio(new_x);#
	w_hat3 = densratio_obj3$compute_density_ratio(new_x);#
    # library(rgl)#
    # plot3d(new_x[,1],new_x[,2],w_hat1)#
    plot(new_x[,1],w_hat1)#
#
	densratio_obj1#
#
	densratio_obj3#
	hat_pi_c = length(myxcM1s)/(length(myxcM1s)+length(myxcM0s))#
	hat_pi_t = length(myxtM1s)/(length(myxtM1s)+length(myxtM0s))#
#
	hat_pi_c#
	hat_pi_t#
	hat_gsubc = w_hat1 * hat_pi_c;#
	hat_gsubt = w_hat3 * hat_pi_t;#
	# ESTIMATE THETA0 AND THETA1 with DR approach#
#
	theta0vec = rep(NA,length(w_hat1));#
	theta1vec = rep(NA,length(w_hat1));#
#
	for (i in 1:length(w_hat1)) {#
		thismax = max(hat_gsubc[i],hat_gsubt[i]);#
		theta0vec[i] = thismax - hat_gsubc[i];#
		theta1vec[i] = thismax - hat_gsubt[i];#
	}#
#
	DRapproachTheta0 = mean(theta0vec)#
	seDRapproachTheta0 = sqrt(var(theta0vec)/length(theta0vec))#
#
	DRapproachTheta1 = mean(theta1vec)#
	seDRapproachTheta1 = sqrt(var(theta1vec)/length(theta1vec))#
#
	DRapproachTheta0#
	seDRapproachTheta0#
#
	DRapproachTheta1#
	seDRapproachTheta1#
	# ESTIMATE THETA0 AND THETA1 WITH LOGISTIC REGRESSION + JANES TREATMENTSELECTION PACKAGE#
#
	myxAll = cbind(myxcs,myxts)#
	myresp = c(mycMresp,mytMresp)#
	mytrtAll = c(rep(0,length(mycMresp)),rep(1,length(mytMresp)));#
	mylogreg = glm(myresp ~ t(myxAll) + mytrtAll + t(myxAll):mytrtAll, family=binomial(link='logit'))#
    firstindex = 1 + mydim + 1 + 1;#
    lastindex = firstindex + (mydim - 1);#
    betas = as.numeric(coef(mylogreg)[firstindex:lastindex]);#
    betalength = sqrt(sum(betas^2));#
    mydir = betas/betalength;#
    mynewxcM1s = as.vector(mydir %*% myxcM1s) #
    mynewxtM1s = as.vector(mydir %*% myxtM1s)#
    mynewxcM0s = as.vector(mydir %*% myxcM0s)#
    mynewxtM0s = as.vector(mydir %*% myxtM0s)#
    boxplot(mynewxcM1s,mynewxtM1s,mynewxcM0s,mynewxtM0s)#
	library(TreatmentSelection)#
#
	myoutcomes = c(rep(1,length(mynewxcM1s)),rep(0,length(mynewxcM0s)),rep(1,length(mynewxtM1s)),rep(0,length(mynewxtM0s)));#
	mymarker = c(mynewxcM1s,mynewxcM0s,mynewxtM1s,mynewxtM0s);#
	mytreatment = c(rep(0,myn/2),rep(1,myn/2))#
#
	datafraforjanes = data.frame(event=myoutcomes,trt=mytreatment,Y1=mymarker);#
	mytrtsel = trtsel(event ~ Y1*trt,treatment.name="trt",data=datafraforjanes,#
	                      study.design="RCT",family=binomial("logit"),default.trt="trt all")#
	tmp = evaluate(mytrtsel,bootstraps=1000);#
#
	mytrtsel#
#
	tmp#
#
	JanesTheta1 = tmp$estimates$Theta.emp#
#
	JanesTheta1#
#
	datafraforjanes = data.frame(event=myoutcomes,trt=mytreatment,Y1=mymarker);#
	mytrtsel = trtsel(event ~ Y1*trt,treatment.name="trt",data=datafraforjanes,#
	                      study.design="RCT",family=binomial("logit"),default.trt="trt none")#
	tmp = evaluate(mytrtsel,bootstraps=1000);#
#
	JanesTheta0 = tmp$estimates$Theta.emp#
#
	JanesTheta0#
#
# ESTIMATE THETA0 AND THETA1 WITH LOGISTIC + DR APPROACH#
#
    mynewmarginal = c(mynewxcM1s,mynewxtM1s,mynewxcM0s,mynewxtM0s)#
#
  	densratio_obj1 = densratio(rep(mynewxcM1s,4),mynewmarginal,method=thismethod)#
	densratio_obj3 = densratio(rep(mynewxtM1s,4),mynewmarginal,method=thismethod)#
#
	new_x = rnorm(1000,mean=mean(mynewmarginal),sd=sqrt(var(mynewmarginal)));#
#
	w_hat1 = densratio_obj1$compute_density_ratio(new_x);#
	w_hat3 = densratio_obj3$compute_density_ratio(new_x);#
#
	hat_pi_c = length(myxcM1s)/(length(myxcM1s)+length(myxcM0s))#
	hat_pi_t = length(myxtM1s)/(length(myxtM1s)+length(myxtM0s))#
#
	hat_gsubc = w_hat1 * hat_pi_c;#
	hat_gsubt = w_hat3 * hat_pi_t;#
	theta0vec = rep(NA,length(w_hat1));#
	theta1vec = rep(NA,length(w_hat1));#
#
	for (i in 1:length(w_hat1)) {#
		thismax = max(hat_gsubc[i],hat_gsubt[i]);#
		theta0vec[i] = thismax - hat_gsubc[i];#
		theta1vec[i] = thismax - hat_gsubt[i];#
	}#
#
	logitDRapproachTheta0 = mean(theta0vec)#
	seDRapproachTheta0 = sqrt(var(theta0vec)/length(theta0vec))#
#
	logitDRapproachTheta1 = mean(theta1vec)#
	seDRapproachTheta1 = sqrt(var(theta1vec)/length(theta1vec))#
	DRtheta0s[thismc] = DRapproachTheta0;#
	DRtheta1s[thismc] = DRapproachTheta1;#
	logitDRtheta0s[thismc] = logitDRapproachTheta0;#
	logitDRtheta1s[thismc] = logitDRapproachTheta1;#
	HJtheta0s[thismc] = JanesTheta0; #
	HJtheta1s[thismc] = JanesTheta1;#
}#
myfilename <- paste("SimTriangleDim",as.character(mydim),"n",as.character(myn),".txt",sep="")#
#
write.table(cbind(DRtheta0s,DRtheta1s,HJtheta0s,HJtheta1s),file=myfilename)#
#
cbind(DRtheta0s,DRtheta1s,HJtheta0s,HJtheta1s)#
#
}
ls()
cbind(DRtheta0s,DRtheta1s,HJtheta0s,HJtheta1s,logitDRtheta0s,logitDRtheta1s)
q()
x = matrix(c(1,1,1,1,88.6,71.6,93.3),ncol=2)
x = matrix(c(1,1,1,1,88.6,71.6,93.3,84.3),ncol=2)
x
t(x) %*% x
solve( t(x) %*% x )
solve( t(x) %*% x ) %*% t(x)
y = t(c(20,16,19.8,18.4))
solve( t(x) %*% x ) %*% t(x) %*% y
dim(y)
y = c(20,16,19.8,18.4)
solve( t(x) %*% x ) %*% t(x) %*% y
x
y
plot(x[,2],y)
abline(0.1913,2.3947)
abline(2.3947,0.1913)
q()
# SIMULATE DATA FROM THE MODEL#
#
thismethod = "uLSIF"#
myn = 1000;#
MCRUNS = 3;#
dimlist = 2:5;#
#
for (mydim in dimlist) {#
#
myregion = function(x) {#
	myreturn = -1;#
	xsum = sum(x);#
	if (xsum < (mydim/2)) { myreturn = 1; }#
	else { myreturn = 2; }#
}#
#
myalphasubcM1s = c(0.2,1.8)#
myalphasubcM0s = 2-myalphasubcM1s;#
#
myalphasubtM1s = c(1.8,0.2)#
myalphasubtM0s = 2-myalphasubtM1s;#
#
mybaseareas = c(0.5,0.5)#
#
mycM1probs = myalphasubcM1s*mybaseareas;#
mycM0probs = myalphasubcM0s*mybaseareas;#
mytM1probs = myalphasubtM1s*mybaseareas;#
mytM0probs = myalphasubtM0s*mybaseareas;#
#
sum(mycM1probs);#
sum(mycM0probs);#
sum(mytM1probs)#
sum(mytM0probs)#
#
mycM1probs;#
mycM0probs;#
mytM1probs#
mytM0probs#
#
myxcM1s = rep(NA,myn/4)#
myxtM1s = rep(NA,myn/4)#
myxcM0s = rep(NA,myn/4)#
myxtM0s = rep(NA,myn/4)#
#
DRtheta0s = rep(NA,MCRUNS)#
DRtheta1s = rep(NA,MCRUNS)#
HJtheta0s = rep(NA,MCRUNS)#
HJtheta1s = rep(NA,MCRUNS)#
logitDRtheta0s = rep(NA,MCRUNS)#
logitDRtheta1s = rep(NA,MCRUNS)#
mygeneratefromArea1 = function() {#
	xtry = runif(mydim);#
	while (sum(xtry) > (mydim/2)) { xtry = runif(mydim)  }#
	return(xtry);#
}#
mygeneratefromArea2 = function() {#
	xtry = runif(mydim);#
	while (sum(xtry) < (mydim/2)) { xtry = runif(mydim)  }#
	return(xtry);#
}#
# RETURN A mydim BY N MATRIX OF BIOMARKER VALUES#
generateCM1rnvs = function(numberneeded) {#
	myreturn = matrix(rep(NA, mydim*numberneeded),nrow=mydim);#
#
	for (i in 1:numberneeded) {#
		myx = c(NA,NA);#
		thismultinom = rmultinom(1,1,mycM1probs);#
#
		if (as.vector(thismultinom)[1] == 1 ) { myx <- mygeneratefromArea1() }#
		if (as.vector(thismultinom)[2] == 1 ) { myx <- mygeneratefromArea2() }#
		myreturn[,i] = myx;#
	}#
	myreturn;#
}#
#
generateTM1rnvs = function(numberneeded) {#
	myreturn = matrix(rep(NA, mydim*numberneeded),nrow=mydim);#
#
	for (i in 1:numberneeded) {#
		myx = c(NA,NA);#
		thismultinom = rmultinom(1,1,mytM1probs);#
#
		if (as.vector(thismultinom)[1] == 1 ) { myx <- mygeneratefromArea1() }#
		if (as.vector(thismultinom)[2] == 1 ) { myx <- mygeneratefromArea2() }#
		myreturn[,i] = myx;#
	}#
	myreturn;#
}#
#
generateCM0rnvs = function(numberneeded) {#
	myreturn = matrix(rep(NA, mydim*numberneeded),nrow=mydim);#
#
	for (i in 1:numberneeded) {#
		myx = c(NA,NA);#
		thismultinom = rmultinom(1,1,mycM0probs);#
#
		if (as.vector(thismultinom)[1] == 1 ) { myx <- mygeneratefromArea1() }#
		if (as.vector(thismultinom)[2] == 1 ) { myx <- mygeneratefromArea2() }#
		myreturn[,i] = myx;#
	}#
	myreturn;#
}#
generateTM0rnvs = function(numberneeded) {#
	myreturn = matrix(rep(NA, mydim*numberneeded),nrow=mydim);#
#
	for (i in 1:numberneeded) {#
		myx = c(NA,NA);#
		thismultinom = rmultinom(1,1,mytM0probs);#
#
		if (as.vector(thismultinom)[1] == 1 ) { myx <- mygeneratefromArea1() }#
		if (as.vector(thismultinom)[2] == 1 ) { myx <- mygeneratefromArea2() }#
		myreturn[,i] = myx;#
	}#
	myreturn;#
}#
for (thismc in 1:MCRUNS)  {#
    mytrt1ctrl0 = rbinom(myn,1,0.5);  # indicates randomization to trt/ctrl#
    myM1is1M0is0 = rbinom(myn,1,0.5); # the conditional probabilities of M1 and M0 are 0.5 for both trt and control#
#
    NumberOfCM1 = length(intersect(which(mytrt1ctrl0==0),which(myM1is1M0is0==1)))#
    NumberOfTM1 = length(intersect(which(mytrt1ctrl0==1),which(myM1is1M0is0==1)))#
    NumberOfCM0 = length(intersect(which(mytrt1ctrl0==0),which(myM1is1M0is0==0)))#
    NumberOfTM0 = length(intersect(which(mytrt1ctrl0==1),which(myM1is1M0is0==0)))#
#
    myxcM1s = generateCM1rnvs(NumberOfCM1)#
    myxtM1s = generateTM1rnvs(NumberOfTM1)#
    myxcM0s = generateCM0rnvs(NumberOfCM0)#
    myxtM0s = generateTM0rnvs(NumberOfTM0)#
#
	apply(myxcM1s,1,mean)#
	apply(myxtM1s,1,mean)#
	apply(myxcM0s,1,mean)#
	apply(myxtM0s,1,mean)#
	myxcs = cbind(myxcM0s,myxcM1s);#
	myxts = cbind(myxtM0s,myxtM1s);#
	myxmarginal = cbind(myxcs,myxts)#
#
	mycMresp = c(rep(0,NumberOfCM0),rep(1,NumberOfCM1)) #
	mytMresp = c(rep(0,NumberOfTM0),rep(1,NumberOfTM1)) #
	# DENSITY RATIO ESTIMATION#
#
	# install.packages("densratio")#
	library(densratio)#
	densratio_obj1 = densratio(t(cbind(myxcM1s,myxcM1s,myxcM1s,myxcM1s)),t(myxmarginal),method=thismethod)#
	densratio_obj3 = densratio(t(cbind(myxtM1s,myxtM1s,myxtM1s,myxtM1s)),t(myxmarginal),method=thismethod)#
#
	new_x = t(matrix(runif(1000*mydim),nrow=mydim));#
#
	w_hat1 = densratio_obj1$compute_density_ratio(new_x);#
	w_hat3 = densratio_obj3$compute_density_ratio(new_x);#
    # library(rgl)#
    # plot3d(new_x[,1],new_x[,2],w_hat1)#
    plot(new_x[,1],w_hat1)#
#
	densratio_obj1#
#
	densratio_obj3#
	hat_pi_c = length(myxcM1s)/(length(myxcM1s)+length(myxcM0s))#
	hat_pi_t = length(myxtM1s)/(length(myxtM1s)+length(myxtM0s))#
#
	hat_pi_c#
	hat_pi_t#
	hat_gsubc = w_hat1 * hat_pi_c;#
	hat_gsubt = w_hat3 * hat_pi_t;#
	# ESTIMATE THETA0 AND THETA1 with DR approach#
#
	theta0vec = rep(NA,length(w_hat1));#
	theta1vec = rep(NA,length(w_hat1));#
#
	for (i in 1:length(w_hat1)) {#
		thismax = max(hat_gsubc[i],hat_gsubt[i]);#
		theta0vec[i] = thismax - hat_gsubc[i];#
		theta1vec[i] = thismax - hat_gsubt[i];#
	}#
#
	DRapproachTheta0 = mean(theta0vec)#
	seDRapproachTheta0 = sqrt(var(theta0vec)/length(theta0vec))#
#
	DRapproachTheta1 = mean(theta1vec)#
	seDRapproachTheta1 = sqrt(var(theta1vec)/length(theta1vec))#
#
	DRapproachTheta0#
	seDRapproachTheta0#
#
	DRapproachTheta1#
	seDRapproachTheta1#
	# ESTIMATE THETA0 AND THETA1 WITH LOGISTIC REGRESSION + JANES TREATMENTSELECTION PACKAGE#
#
	myxAll = cbind(myxcs,myxts)#
	myresp = c(mycMresp,mytMresp)#
	mytrtAll = c(rep(0,length(mycMresp)),rep(1,length(mytMresp)));#
	mylogreg = glm(myresp ~ t(myxAll) + mytrtAll + t(myxAll):mytrtAll, family=binomial(link='logit'))#
    firstindex = 1 + mydim + 1 + 1;#
    lastindex = firstindex + (mydim - 1);#
    betas = as.numeric(coef(mylogreg)[firstindex:lastindex]);#
    betalength = sqrt(sum(betas^2));#
    mydir = betas/betalength;#
    mynewxcM1s = as.vector(mydir %*% myxcM1s) #
    mynewxtM1s = as.vector(mydir %*% myxtM1s)#
    mynewxcM0s = as.vector(mydir %*% myxcM0s)#
    mynewxtM0s = as.vector(mydir %*% myxtM0s)#
    boxplot(mynewxcM1s,mynewxtM1s,mynewxcM0s,mynewxtM0s)#
	library(TreatmentSelection)#
#
	myoutcomes = c(rep(1,length(mynewxcM1s)),rep(0,length(mynewxcM0s)),rep(1,length(mynewxtM1s)),rep(0,length(mynewxtM0s)));#
	mymarker = c(mynewxcM1s,mynewxcM0s,mynewxtM1s,mynewxtM0s);#
	mytreatment = c(rep(0,myn/2),rep(1,myn/2))#
#
	datafraforjanes = data.frame(event=myoutcomes,trt=mytreatment,Y1=mymarker);#
	mytrtsel = trtsel(event ~ Y1*trt,treatment.name="trt",data=datafraforjanes,#
	                      study.design="RCT",family=binomial("logit"),default.trt="trt all")#
	tmp = evaluate(mytrtsel,bootstraps=1000);#
#
	mytrtsel#
#
	tmp#
#
	JanesTheta1 = tmp$estimates$Theta.emp#
#
	JanesTheta1#
#
	datafraforjanes = data.frame(event=myoutcomes,trt=mytreatment,Y1=mymarker);#
	mytrtsel = trtsel(event ~ Y1*trt,treatment.name="trt",data=datafraforjanes,#
	                      study.design="RCT",family=binomial("logit"),default.trt="trt none")#
	tmp = evaluate(mytrtsel,bootstraps=1000);#
#
	JanesTheta0 = tmp$estimates$Theta.emp#
#
	JanesTheta0#
#
# ESTIMATE THETA0 AND THETA1 WITH LOGISTIC + DR APPROACH#
#
    mynewmarginal = c(mynewxcM1s,mynewxtM1s,mynewxcM0s,mynewxtM0s)#
#
  	densratio_obj1 = densratio(rep(mynewxcM1s,4),mynewmarginal,method=thismethod)#
	densratio_obj3 = densratio(rep(mynewxtM1s,4),mynewmarginal,method=thismethod)#
#
	new_x = rnorm(1000,mean=mean(mynewmarginal),sd=sqrt(var(mynewmarginal)));#
#
	w_hat1 = densratio_obj1$compute_density_ratio(new_x);#
	w_hat3 = densratio_obj3$compute_density_ratio(new_x);#
#
	hat_pi_c = length(myxcM1s)/(length(myxcM1s)+length(myxcM0s))#
	hat_pi_t = length(myxtM1s)/(length(myxtM1s)+length(myxtM0s))#
#
	hat_gsubc = w_hat1 * hat_pi_c;#
	hat_gsubt = w_hat3 * hat_pi_t;#
	theta0vec = rep(NA,length(w_hat1));#
	theta1vec = rep(NA,length(w_hat1));#
#
	for (i in 1:length(w_hat1)) {#
		thismax = max(hat_gsubc[i],hat_gsubt[i]);#
		theta0vec[i] = thismax - hat_gsubc[i];#
		theta1vec[i] = thismax - hat_gsubt[i];#
	}#
#
	logitDRapproachTheta0 = mean(theta0vec)#
	seDRapproachTheta0 = sqrt(var(theta0vec)/length(theta0vec))#
#
	logitDRapproachTheta1 = mean(theta1vec)#
	seDRapproachTheta1 = sqrt(var(theta1vec)/length(theta1vec))#
	DRtheta0s[thismc] = DRapproachTheta0;#
	DRtheta1s[thismc] = DRapproachTheta1;#
	logitDRtheta0s[thismc] = logitDRapproachTheta0;#
	logitDRtheta1s[thismc] = logitDRapproachTheta1;#
	HJtheta0s[thismc] = JanesTheta0; #
	HJtheta1s[thismc] = JanesTheta1;#
}#
myfilename <- paste("SimTriangleDim",as.character(mydim),"n",as.character(myn),".txt",sep="")#
#
write.table(cbind(DRtheta0s,DRtheta1s,HJtheta0s,HJtheta1s,logitDRtheta0s,logitDRtheta1s),file=myfilename)#
}
cbind(DRtheta0s,DRtheta1s,HJtheta0s,HJtheta1s,logitDRtheta0s,logitDRtheta1s)
q()
# Example 1:  three-dimensional data#
# Dataset: airquality #
install.packages(c("rgl","car"))#
library(car)#
names(airquality)#
head(airquality)#
#
scatter3d(airquality$Ozone ~ airquality$Wind+airquality$Temp)
options(rgl.useNULL=TRUE)
.rs.restartR()
# Example 1:  three-dimensional data#
# Dataset: airquality #
install.packages(c("rgl","car"))#
library(car)#
names(airquality)#
head(airquality)#
#
scatter3d(airquality$Ozone ~ airquality$Wind+airquality$Temp)
q()
install.packages("rgl", repos="http://R-Forge.R-project.org")
# Example 1:  three-dimensional data#
# Dataset: airquality #
install.packages(c("rgl","car"))#
library(car)#
names(airquality)#
head(airquality)#
#
scatter3d(airquality$Ozone ~ airquality$Wind+airquality$Temp)
capabilities9)
capabilities()
# Example 1:  three-dimensional data#
# Dataset: airquality #
install.packages(c("rgl","car"))#
library(car)#
names(airquality)#
head(airquality)#
#
scatter3d(airquality$Ozone ~ airquality$Wind+airquality$Temp)
library(ggfortify)#
df <- iris[1:4]#
pca_res <- prcomp(df, scale. = TRUE)#
#
autoplot(pca_res)
install.packages("ggfortify")
library(ggfortify)#
df <- iris[1:4]#
pca_res <- prcomp(df, scale. = TRUE)#
#
autoplot(pca_res)
str(iris)
autoplot(pca_res)
x=c(5,3)
A = matrix(c(9,4,4,6),ncol=2)
t(x) %*% A %*% x
x
A
A %*% x
214+505+423
+31+48+53
1142+31+48+53
mytab = matrix(c(96,149,226,327,173,303),ncol=3)
mytab
chisq.test(mytab)
help(chisq.test)
choose(15,5)
choose(10,5)
choose(10,5)*choose(15,5)
Q()
q()
choose(3,1)*choose(5,2)*choose(5,2)
choose(2,1)*choose(3,2)*choose(3,2)
300*18
-135.50 + (11.75*21)
A = matrix(c(6,3,3,9),ncol=2)
x = c(3,-2)
t(x)%*% A %*% x
-51.26215/23.98854
-36.90884 + (2.136943 * 19.96432)
5.753774 - (2.136943 * 100)
3*15*15*2*6*6
80*15
mytimes <- c(1,1,1,1,4,5,7,8,10,10,12,16,16,10)
mytimes <- c(1,1,1,1,4,5,7,8,10,10,12,16,16,16)
length(mytimes)
mystati = c(1,1,1,0,0,1,1,1,1,0,0,0,0,0)
length(mystati)
library(survival)
Surv(mytimes,mystati)
mysurv = Surv(mytimes,mystati)
survfit(mysurv ~1)
myfitsurvfit(mysurv ~1)
myfit= survfit(mysurv ~1)
plot(myfit)
help(survfit)
myfit2 = survfit(mysurv ~ 1,conf.type="log-log")
par(mfrow=c(1,2))
plot(myfit)
plot(myfit2)
mytimes = c(1,1,1,1,4,5,7,8,10,10,12,16,16,16)
mystati = c(1,1,1,0,1,1,1,1,0,0,0,0,0)
length(mytimes)
length(mystati)
mystati = c(1,1,1,0,,01,1,1,1,0,0,0,0,0)
mystati = c(1,1,1,0,0,1,1,1,1,0,0,0,0,0)
table(mytimes,mystati)
mysurv = Surv(mytimes,mystati)
library(survival)
mysurv = Surv(mytimes,mystati)
mysurg
mysurv
par(mfrow=c(1,2))
plot(surv.fit(mysurv~1,conf.type=))
plot(surv.fit(mysurv~1,conf.type="log"))
plot(survfit(mysurv~1,conf.type="log"))
plot(survfit(mysurv~1,conf.type="log-log"))
0.196-(1.96*0.0818)
c(1/5,9/20,47/60,107/60)
log(1.756)
mytimes = c(281,604,457,384,341,842,1514,182,1121,1411,814,1071)
mystatus = c(1,0,1,1,0,1,1,0,1,0,1,1)
mytrt = c(rep(0,6),rep(1,6))
mysurv = Surv(mytimes,mystatus)
library(survival)
mysurv = Surv(mytimes,mystatus)
plot(surv.fit(mysurv ~ mytrt))
plot(survfit(mysurv ~ mytrt))
plot(survfit(mysurv ~ mytrt,type="fh"))
myfit = survfit(mysurv ~ mytrt,type="fh")
plot(myfit$time,-log(temp$surv))
plot(myfit$time,-log(myfit$surv))
myday = c(1,0,-1);#
#
myvolunteer = 120 + 5 *  rnorm(10);#
#
mypersonnel =  rnorm(3)#
#
mySBP = rep(myvolunteer, each=3) + ;
myday = c(1,0,-1);#
#
myvolunteer = 120 + 5 *  rnorm(10);#
#
mypersonnel =  rnorm(3)#
#
myvolunteerFac = rep(1:10,3)#
#
myvolunteerFac
myday = c(1,0,-1);#
#
myvolunteer = 120 + 5 *  rnorm(10);#
#
mypersonnel =  rnorm(3)#
#
myvolunteerFac = factor(rep(1:10,each=3));#
#
myvolunteerFac;#
#
mypersonnelFac = factor(rep(1:3,10))#
#
mypersonnelFac#
#
seq1 = c(1,2,3);#
seq2 = c(1,3,2);#
seq3 = c(2,1,3);#
seq4 = c(2,3,1);#
seq5 = c(3,1,2);#
seq6 = c(3,2,1);#
#
mydayFac = (seq1,seq2,seq3,seq4,seq5,seq6,seq1,seq2,seq3,seq4)#
#
mydayFac
myday = c(1,0,-1);#
#
myvolunteer = 120 + 5 *  rnorm(10);#
#
mypersonnel =  rnorm(3)#
#
myvolunteerFac = factor(rep(1:10,each=3));#
#
myvolunteerFac;#
#
mypersonnelFac = factor(rep(1:3,10))#
#
mypersonnelFac#
#
seq1 = c(1,2,3);#
seq2 = c(1,3,2);#
seq3 = c(2,1,3);#
seq4 = c(2,3,1);#
seq5 = c(3,1,2);#
seq6 = c(3,2,1);#
#
mydayFac = c(seq1,seq2,seq3,seq4,seq5,seq6,seq1,seq2,seq3,seq4)#
#
mydayFac
myday = c(1,0,-1);#
#
myvolunteer = 120 + 5 *  rnorm(10);#
#
mypersonnel =  rnorm(3)#
#
myvolunteerFac = factor(rep(1:10,each=3));#
#
myvolunteerFac;#
#
mypersonnelFac = factor(rep(1:3,10))#
#
mypersonnelFac#
#
seq1 = c(1,2,3);#
seq2 = c(1,3,2);#
seq3 = c(2,1,3);#
seq4 = c(2,3,1);#
seq5 = c(3,1,2);#
seq6 = c(3,2,1);#
#
mydayFac = c(seq1,seq2,seq3,seq4,seq5,seq6,seq1,seq2,seq3,seq4)#
#
mydayFac#
#
mySBPs = myvolunteer[as.numeric(myvolunteerFac)] + mypersonnel[as.numeric(mypersonnelFac)] +#
          myday[as.numeric(mydayFac)] + 0.2*rnorm(30)
mySBPs
myday = c(1,0,-1);#
#
myvolunteer = 120 + 5 *  rnorm(10);#
#
mypersonnel =  rnorm(3)#
#
myvolunteerFac = factor(rep(1:10,each=3));#
#
myvolunteerFac;#
#
mypersonnelFac = factor(rep(1:3,10))#
#
mypersonnelFac#
#
seq1 = c(1,2,3);#
seq2 = c(1,3,2);#
seq3 = c(2,1,3);#
seq4 = c(2,3,1);#
seq5 = c(3,1,2);#
seq6 = c(3,2,1);#
#
mydayFac = c(seq1,seq2,seq3,seq4,seq5,seq6,seq1,seq2,seq3,seq4)#
#
mydayFac#
#
mySBPs = myvolunteer[as.numeric(myvolunteerFac)] + mypersonnel[as.numeric(mypersonnelFac)] +#
          myday[as.numeric(mydayFac)] + 0.2*rnorm(30)#
#
mylm = lm(mySBPs ~ mydayFac + mypersonnelFacn + myvolunteerFac)#
#
summary(mylm)
myday = c(1,0,-1);#
#
myvolunteer = 120 + 5 *  rnorm(10);#
#
mypersonnel =  rnorm(3)#
#
myvolunteerFac = factor(rep(1:10,each=3));#
#
myvolunteerFac;#
#
mypersonnelFac = factor(rep(1:3,10))#
#
mypersonnelFac#
#
seq1 = c(1,2,3);#
seq2 = c(1,3,2);#
seq3 = c(2,1,3);#
seq4 = c(2,3,1);#
seq5 = c(3,1,2);#
seq6 = c(3,2,1);#
#
mydayFac = c(seq1,seq2,seq3,seq4,seq5,seq6,seq1,seq2,seq3,seq4)#
#
mydayFac#
#
mySBPs = myvolunteer[as.numeric(myvolunteerFac)] + mypersonnel[as.numeric(mypersonnelFac)] +#
          myday[as.numeric(mydayFac)] + 0.2*rnorm(30)#
#
mylm = lm(mySBPs ~ mydayFac + mypersonnelFac + myvolunteerFac)#
#
summary(mylm)
myday = c(1,0,-1);#
#
myvolunteer = 120 + 5 *  rnorm(10);#
#
mypersonnel =  rnorm(3)#
#
myvolunteerFac = factor(rep(1:10,each=3));#
#
myvolunteerFac;#
#
mypersonnelFac = factor(rep(1:3,10))#
#
mypersonnelFac#
#
seq1 = c(1,2,3);#
seq2 = c(1,3,2);#
seq3 = c(2,1,3);#
seq4 = c(2,3,1);#
seq5 = c(3,1,2);#
seq6 = c(3,2,1);#
#
mydayFac = c(seq1,seq2,seq3,seq4,seq5,seq6,seq1,seq2,seq3,seq4)#
#
mydayFac#
#
mySBPs = myvolunteer[as.numeric(myvolunteerFac)] + mypersonnel[as.numeric(mypersonnelFac)] +#
          myday[as.numeric(mydayFac)] + 0.2*rnorm(30)#
#
mylm = lm(mySBPs ~ mydayFac  + myvolunteerFac+ mypersonnelFac)#
#
summary(mylm)#
#
anova(mylm)
myday = c(1,0,-1);#
#
myvolunteer = 120 + 5 *  rnorm(10);#
#
mypersonnel =  rnorm(3)#
#
myvolunteerFac = factor(rep(1:10,each=3));#
#
myvolunteerFac;#
#
mypersonnelFac = factor(rep(1:3,10))#
#
mypersonnelFac#
#
seq1 = c(1,2,3);#
seq2 = c(1,3,2);#
seq3 = c(2,1,3);#
seq4 = c(2,3,1);#
seq5 = c(3,1,2);#
seq6 = c(3,2,1);#
#
mydayFac = c(seq1,seq2,seq3,seq4,seq5,seq6,seq1,seq2,seq3,seq4)#
#
mydayFac#
#
mySBPs = myvolunteer[as.numeric(myvolunteerFac)] + mypersonnel[as.numeric(mypersonnelFac)] +#
          myday[as.numeric(mydayFac)] + 2*rnorm(30)#
#
for (i in 1:length(mySBPs)) { mySBPs[i] = round(mySBPs[i]); }#
#
mySBPs;#
#
mylm = lm(mySBPs ~ mydayFac  + myvolunteerFac+ mypersonnelFac)#
#
summary(mylm)#
#
anova(mylm)
boxplot(mySBPs ~ mydayFac + mypersonnelFac)
boxplot(mySBPs ~ myvolunteerFac + mypersonnelFac)
par(mfrow=c(1,3))
boxplot(mySBPs ~ myvolunteerFac)
boxplot(mySBPs ~ mypersonnelFac)
boxplot(mySBPs ~ mydayFac)
plot(fitted.values(mylm),residuals(mylm))
plot(fitted.values(mylm),cooks.distance(mylm))
par(mfrow=c(1,2))
plot(fitted.values(mylm),residuals(mylm))
plot(fitted.values(mylm),cooks.distance(mylm))
mydayfac
mydayFac
mylm
mydayFac
table(mydayFac,myvolunteerFac,mypersonnelFac)
myday = c(3,1,-4);#
#
myvolunteer = 120 + 5 *  rnorm(10);#
#
mypersonnel =  rnorm(3)#
#
myvolunteerFac = factor(rep(1:10,each=3));#
#
myvolunteerFac;#
#
mypersonnelFac = factor(rep(1:3,10))#
#
mypersonnelFac#
#
seq1 = c(1,2,3);#
seq2 = c(1,3,2);#
seq3 = c(2,1,3);#
seq4 = c(2,3,1);#
seq5 = c(3,1,2);#
seq6 = c(3,2,1);#
#
mydayFac = c(seq1,seq2,seq3,seq4,seq5,seq6,seq1,seq2,seq3,seq4)#
#
mydayFac#
#
mySBPs = myvolunteer[as.numeric(myvolunteerFac)] + mypersonnel[as.numeric(mypersonnelFac)] +#
          myday[as.numeric(mydayFac)] + 2*rnorm(30)#
#
for (i in 1:length(mySBPs)) { mySBPs[i] = round(mySBPs[i]); }#
#
mySBPs;#
#
mylm = lm(mySBPs ~ mydayFac  + myvolunteerFac+ mypersonnelFac)#
#
summary(mylm)#
#
anova(mylm)
mydayFac
myday = c(3,1,-4);#
#
myvolunteer = 120 + 5 *  rnorm(10);#
#
mypersonnel =  rnorm(3)#
#
myvolunteerFac = factor(rep(1:10,each=3));#
#
myvolunteerFac;#
#
mypersonnelFac = factor(rep(1:3,10))#
#
mypersonnelFac#
#
seq1 = c(1,2,3);#
seq2 = c(1,3,2);#
seq3 = c(2,1,3);#
seq4 = c(2,3,1);#
seq5 = c(3,1,2);#
seq6 = c(3,2,1);#
#
mydayFac = c(seq1,seq2,seq3,seq4,seq5,seq6,seq1,seq2,seq3,seq4)#
#
mydayFac#
#
mySBPs = myvolunteer[as.numeric(myvolunteerFac)] + mypersonnel[as.numeric(mypersonnelFac)] +#
          myday[as.numeric(mydayFac)] + 2*rnorm(30)#
#
for (i in 1:length(mySBPs)) { mySBPs[i] = round(mySBPs[i]); }#
#
mySBPs;#
#
mylm = lm(mySBPs ~ mydayFac  + myvolunteerFac+ mypersonnelFac)#
#
summary(mylm)#
#
anova(mylm)#
#
table(mydayFac,myvolunteerFac,mypersonnelFac)
table(myvolunteerFac,mypersonnelFac,mydayFac)
(0.3961-0.0396)/0.3961
sqrt(28.32)
.01/.01^1
.01/.01^2
-1.04516 + 1.04074 * 8 + 1.66813*4
-1.04516 + (1.04074 * 8) + (1.66813*4)
# setwd("Set this to the directory that contains the downloaded file")#
source(file="SS4TrtSelSurv.R")#
#
# Parameter settings#
normalmean = 0.5;#
normalsd = sqrt(1/12)#
#
#  Parameter for the number of MC runs for each estimation (fixed)#
# The k-values for input#
ExpPropOfDeaths = 1.00;#
NumberOfBootstraps = 200;#
mydesign = "stratified"#
k1 = 0.25; k2 = 0.75;#
k3 = 0.75; k4 = 0.25;#
t0=5;#
#
start1 = Sys.time()#
temp1 <- Calculate.sample.size(targetwidth=0.10,k1,k2,k3,k4,t0,#
                        mydesign=mydesign,ExpPropOfDeaths=ExpPropOfDeaths,#
                        NumberOfBootstraps=NumberOfBootstraps)#
end1 = Sys.time()#
#
print(temp1);#
#
plot(as.numeric(temp1[[3]]),as.numeric(temp1[[4]]),xlab="Sample Size", ylab="Inverse squared Width")
q()
